import Boom from '@hapi/boom';
import Intercept from 'apr-intercept';
import {
  RestCalendar,
  Calendar,
  Query,
  SquidexGraphqlClient,
  SquidexRest,
  SquidexRestClient,
  parseToSquidex,
  InputCalendar,
} from '@asap-hub/squidex';
import {
  ListCalendarResponse,
  CalendarResponse,
  isGoogleLegacyCalendarColor,
} from '@asap-hub/model';
import { parseGraphqlCalendar, parseRestCalendar } from '../entities';
import logger from '../utils/logger';
import { FETCH_CALENDAR, FETCH_CALENDARS } from '../queries/calendars.queries';
import {
  FetchCalendarQuery,
  FetchCalendarQueryVariables,
  FetchCalendarsQuery,
  FetchCalendarsQueryVariables,
} from '../autogenerated-gql/graphql';
import { FetchPaginationOptions } from '../utils/types';

export default class Calendars implements CalendarController {
  calendarSquidexRestClient: SquidexRestClient<RestCalendar, InputCalendar>;
  squidexGraphqlClient: SquidexGraphqlClient;

  constructor(squidexGraphqlClient: SquidexGraphqlClient) {
    this.calendarSquidexRestClient = new SquidexRest<
      RestCalendar,
      InputCalendar
    >('calendars');
    this.squidexGraphqlClient = squidexGraphqlClient;
  }

  async fetch(): Promise<ListCalendarResponse> {
    const take = 50;
    const skip = 0;

    const { queryCalendarsContentsWithTotal } =
      await this.squidexGraphqlClient.request<
        FetchCalendarsQuery,
        FetchCalendarsQueryVariables
      >(FETCH_CALENDARS, {
        top: take,
        skip,
        filter: '',
        order: 'data/name/iv asc',
      });

    if (queryCalendarsContentsWithTotal === null) {
      logger.warn('queryCalendarsContentsWithTotal returned null');
      return {
        total: 0,
        items: [],
      };
    }

    const { items: calendars } = queryCalendarsContentsWithTotal;

    if (calendars === null) {
      logger.warn('queryCalendarsContentsWithTotal items returned null');
      return {
        total: 0,
        items: [],
      };
    }

    const activeCalendars = calendars.filter((calendar) => {
      if (
        !calendar?.referencingGroupsContents ||
        calendar.referencingGroupsContents.length === 0
      ) {
        return true;
      }

      return (
        calendar.referencingGroupsContents.findIndex(
          (group) => group.flatData.active === true,
        ) !== -1
      );
    });

    return {
      total: activeCalendars.length,
      items: activeCalendars.map(parseGraphqlCalendar),
    };
  }

  async fetchRaw(
    options: { maxExpiration?: number } & FetchPaginationOptions,
  ): Promise<CalendarRaw[]> {
    const { maxExpiration, take, skip } = options;

    const query: Query = {
      take,
      skip,
      sort: [{ path: 'data.name.iv', order: 'ascending' }],
    };

    if (maxExpiration) {
      query.filter = {
        path: 'data.expirationDate.iv',
        op: 'lt',
        value: maxExpiration,
      };
    }

    const { items: calendars } = await this.calendarSquidexRestClient.fetch(
      query,
    );

    return calendars.map(
      (restCalendar): CalendarRaw => ({
        id: restCalendar.id,
        googleCalendarId: restCalendar.data.googleCalendarId.iv,
        color: restCalendar.data.color.iv,
        name: restCalendar.data.name.iv,
        expirationDate: restCalendar.data.expirationDate?.iv,
        resourceId: restCalendar.data.resourceId?.iv,
        syncToken: restCalendar.data.syncToken?.iv,
        version: restCalendar.version,
      }),
    );
  }

  async fetchByResourceId(resourceId: string): Promise<RestCalendar> {
    const [err, res] = await Intercept(
      this.calendarSquidexRestClient.client
        .get('calendars', {
          searchParams: {
            $top: 1,
            $filter: `data/resourceId/iv eq '${resourceId}'`,
          },
        })
        .json() as Promise<{ items: RestCalendar[] }>,
    );

    if (err) {
      logger.error(err, 'Error fetching calendar by resourceId');
      throw Boom.badGateway();
    }

    if (res.items.length === 0 || !res.items[0]) {
      throw Boom.notFound();
    }

    return res.items[0];
  }

  fetchById(id: string, options?: { raw: false }): Promise<CalendarResponse>;
  fetchById(id: string, options?: { raw: true }): Promise<CalendarRaw>;
  async fetchById(
    calendarId: string,
    options?: { raw: boolean },
  ): Promise<CalendarRaw | CalendarResponse> {
    const calendarResponse = await this.squidexGraphqlClient.request<
      FetchCalendarQuery,
      FetchCalendarQueryVariables
    >(FETCH_CALENDAR, { id: calendarId });

    const { findCalendarsContent: calendar } = calendarResponse;

    if (!calendar) {
      throw Boom.notFound();
    }

    const { googleCalendarId, color, name } = calendar.flatData;
    if (!googleCalendarId || !name || !color) {
      throw Boom.badGateway('Missing required data');
    }

    if (!isGoogleLegacyCalendarColor(color)) {
      throw Boom.badGateway('Invalid colour');
    }

    if (options?.raw === true) {
      return {
        id: calendar.id,
        version: calendar.version,
        googleCalendarId,
        color,
        name,
        expirationDate: calendar.flatData.expirationDate ?? undefined,
        resourceId: calendar.flatData.resourceId,
        syncToken: calendar.flatData.syncToken ?? undefined,
      };
    }

    return {
      id: googleCalendarId,
      name,
      color,
    };
  }

  async getSyncToken(calendarId: string): Promise<string | undefined> {
    const res = await this.calendarSquidexRestClient.fetchById(calendarId);
    return res.data.syncToken?.iv;
  }

  async update(
    calendarId: string,
    data: Partial<Calendar>,
  ): Promise<CalendarResponse> {
    const update = parseToSquidex(data);
    const res = await this.calendarSquidexRestClient.patch(calendarId, update);
    return parseRestCalendar(res);
  }
}

export interface CalendarController {
  fetch: (options: FetchPaginationOptions) => Promise<ListCalendarResponse>;
  fetchRaw: (
    options: { maxExpiration: number } & FetchPaginationOptions,
  ) => Promise<CalendarRaw[]>;
  fetchByResourceId: (resourceId: string) => Promise<RestCalendar>;
  getSyncToken: (calendarId: string) => Promise<string | undefined>;
  update: (
    calendarId: string,
    data: Partial<Calendar>,
  ) => Promise<CalendarResponse>;
  fetchById(id: string, options?: { raw: false }): Promise<CalendarResponse>;
  fetchById(id: string, options?: { raw: true }): Promise<CalendarRaw>;
}

export type CalendarRaw = Calendar & {
  id: string;
  version: number;
};
