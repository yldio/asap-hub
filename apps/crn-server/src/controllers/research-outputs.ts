import {
  ExternalAuthorInput,
  ListResearchOutputResponse,
  ResearchOutputPostRequest,
  ResearchOutputResponse,
  ResearchTagCategory,
  ValidationErrorResponse,
  VALIDATION_ERROR_MESSAGE,
  ResearchOutputPutRequest,
} from '@asap-hub/model';
import {
  RestExternalAuthor,
  RestResearchOutput,
  RestTeam,
  sanitiseForSquidex,
  parseToSquidex,
  SquidexGraphqlClient,
  SquidexRest,
  SquidexRestClient,
  InputResearchOutput,
} from '@asap-hub/squidex';
import Boom from '@hapi/boom';
import {
  FetchResearchOutputQuery,
  FetchResearchOutputQueryVariables,
  FetchResearchOutputsQuery,
  FetchResearchOutputsQueryVariables,
  FetchResearchTagsQuery,
  FetchResearchTagsQueryVariables,
} from '../autogenerated-gql/graphql';
import {
  convertBooleanToDecision,
  parseGraphQLResearchOutput,
} from '../entities/research-output';
import {
  FETCH_RESEARCH_OUTPUT,
  FETCH_RESEARCH_OUTPUTS,
} from '../queries/research-outputs.queries';
import { FETCH_RESEARCH_TAGS } from '../queries/research-tags.queries';
import logger from '../utils/logger';

export default class ResearchOutputs implements ResearchOutputController {
  squidexGraphqlClient: SquidexGraphqlClient;
  researchOutputSquidexRestClient: SquidexRestClient<
    RestResearchOutput,
    InputResearchOutput
  >;
  teamSquidexRestClient: SquidexRestClient<RestTeam>;
  externalAuthorSquidexRestClient: SquidexRestClient<RestExternalAuthor>;

  constructor(squidexGraphqlClient: SquidexGraphqlClient) {
    this.squidexGraphqlClient = squidexGraphqlClient;
    this.researchOutputSquidexRestClient = new SquidexRest('research-outputs');
    this.teamSquidexRestClient = new SquidexRest('teams', {
      unpublished: true,
    });
    this.externalAuthorSquidexRestClient = new SquidexRest('external-authors');
  }

  async fetchById(id: string): Promise<ResearchOutputResponse> {
    const researchOutputGraphqlResponse =
      await this.squidexGraphqlClient.request<
        FetchResearchOutputQuery,
        FetchResearchOutputQueryVariables
      >(FETCH_RESEARCH_OUTPUT, { id, withTeams: true });

    const { findResearchOutputsContent: researchOutputContent } =
      researchOutputGraphqlResponse;

    if (!researchOutputContent) {
      throw Boom.notFound();
    }

    return parseGraphQLResearchOutput(researchOutputContent, {
      includeAuthors: true,
      includeTeams: true,
    }) as ResearchOutputResponse;
  }

  async fetch(options: {
    take?: number;
    skip?: number;
    search?: string;
    filter?: ResearchOutputFilter;
    includeDrafts?: boolean;
  }): Promise<ListResearchOutputResponse> {
    const { search, filter, take = 8, skip = 0, includeDrafts } = options;

    const searchQ = (search || '')
      .split(' ')
      .filter(Boolean)
      .map(sanitiseForSquidex)
      .reduce(
        (acc: string[], word: string) =>
          acc.concat(
            `contains(data/title/iv, '${word}') or contains(data/tags/iv, '${word}')`,
          ),
        [],
      )
      .join(' or ');

    const filterQ = makeODataFilter(filter);

    const filterGraphql = [filterQ && `(${filterQ})`, searchQ && `(${searchQ})`]
      .filter(Boolean)
      .join(' and ');

    const { queryResearchOutputsContentsWithTotal } =
      await this.squidexGraphqlClient.request<
        FetchResearchOutputsQuery,
        FetchResearchOutputsQueryVariables
      >(
        FETCH_RESEARCH_OUTPUTS,
        {
          top: take,
          skip,
          filter: filterGraphql,
          withTeams: true,
        },
        {
          includeDrafts,
        },
      );

    if (queryResearchOutputsContentsWithTotal === null) {
      logger.warn('queryResearchOutputsContentsWithTotal returned null');
      return {
        total: 0,
        items: [],
      };
    }

    const { total, items: researchOutputs } =
      queryResearchOutputsContentsWithTotal;

    if (researchOutputs === null) {
      logger.warn('queryResearchOutputsContentsWithTotal items returned null');
      return {
        total: 0,
        items: [],
      };
    }

    return {
      total,
      items: researchOutputs.map(
        (item) =>
          parseGraphQLResearchOutput(item, {
            includeAuthors: true,
            includeTeams: true,
          }) as ResearchOutputResponse,
      ),
    };
  }

  async create(
    researchOutputData: ResearchOutputCreateData,
  ): Promise<Partial<ResearchOutputResponse>> {
    return this.upsertResearchOutput(researchOutputData);
  }

  async update(
    researchOutputId: string,
    researchOutputData: ResearchOutputUpdateData,
  ): Promise<Partial<ResearchOutputResponse>> {
    return this.upsertResearchOutput({
      researchOutputId,
      ...researchOutputData,
    });
  }

  private async upsertResearchOutput(
    researchOutputData:
      | (ResearchOutputUpdateData & { researchOutputId: string })
      | ResearchOutputCreateData,
  ) {
    await this.validateResearchOutputUniques(
      researchOutputData,
      ('researchOutputId' in researchOutputData &&
        researchOutputData.researchOutputId) ||
        '',
    );

    const researchOutputAuthors = await Promise.all(
      (researchOutputData.authors || []).map((author) =>
        this.mapAuthorInputToId(author),
      ),
    );

    const { methods, organisms, environments, subtype } =
      await this.parseResearchTags({ ...researchOutputData });

    let researchOutputId: string;

    if ('researchOutputId' in researchOutputData) {
      const {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        researchOutputId: _,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        teams: __,
        ...researchOutputUpdateData
      } = researchOutputData;

      await this.updateResearchOutput(researchOutputData.researchOutputId, {
        ...researchOutputUpdateData,
        authors: researchOutputAuthors,
        methods,
        organisms,
        environments,
        subtype,
      });

      researchOutputId = researchOutputData.researchOutputId;
    } else {
      const { teams, ...researchOutputCreateData } = researchOutputData;
      const result = await this.createResearchOutput({
        ...researchOutputCreateData,
        authors: researchOutputAuthors,
        methods,
        organisms,
        environments,
        subtype,
      });

      researchOutputId = result.id;

      await Promise.all(
        teams.map((teamId) =>
          this.associateResearchOutputToTeam(teamId, researchOutputId),
        ),
      );
    }

    return this.fetchById(researchOutputId);
  }

  private async createResearchOutput({
    authors,
    createdBy,
    ...researchOutputData
  }: Omit<ResearchOutputPostRequest, 'teams' | 'authors' | 'subtype'> & {
    authors: string[];
    createdBy: string;
    subtype: string[];
  }) {
    const { usedInPublication, ...researchOutput } = parseToSquidex({
      ...researchOutputData,
      asapFunded: convertBooleanToDecision(researchOutputData.asapFunded),
      usedInPublication: convertBooleanToDecision(
        researchOutputData.usedInPublication,
      ),
      authors,
      createdBy: [createdBy],
      updatedBy: [createdBy],
    });

    return this.researchOutputSquidexRestClient.create(
      {
        ...researchOutput,
        usedInAPublication: usedInPublication,
        labs: researchOutput.labs || { iv: null },
      },
      true,
    );
  }

  private async updateResearchOutput(
    researchOutputId: string,
    {
      authors,
      updatedBy,
      ...researchOutputData
    }: Omit<ResearchOutputPostRequest, 'teams' | 'authors' | 'subtype'> & {
      authors: string[];
      updatedBy: string;
      subtype: string[];
    },
  ) {
    const { usedInPublication, ...researchOutput } = parseToSquidex({
      ...researchOutputData,
      asapFunded: convertBooleanToDecision(researchOutputData.asapFunded),
      usedInPublication: convertBooleanToDecision(
        researchOutputData.usedInPublication,
      ),
      authors,
      updatedBy: [updatedBy],
    });

    return this.researchOutputSquidexRestClient.patch(researchOutputId, {
      ...researchOutput,
      usedInAPublication: usedInPublication,
      labs: researchOutput.labs || { iv: null },
    });
  }

  private async validateResearchOutputUniques(
    researchOutputData: ResearchOutputCreateData | ResearchOutputUpdateData,
    resarchOutputId?: string,
  ): Promise<void> {
    const isError = (
      error: ValidationErrorResponse['data'][0] | null,
    ): error is ValidationErrorResponse['data'][0] => !!error;

    const errors = (
      await Promise.all([
        this.validateTitleUniqueness(researchOutputData, resarchOutputId),
        this.validateLinkUniqueness(researchOutputData, resarchOutputId),
      ])
    ).filter(isError);

    if (errors.length > 0) {
      // TODO: Remove Boom from the controller layer
      // https://asaphub.atlassian.net/browse/CRN-777
      throw Boom.badRequest<ValidationErrorResponse['data']>(
        VALIDATION_ERROR_MESSAGE,
        errors,
      );
    }
  }

  private async validateTitleUniqueness(
    researchOutputData: ResearchOutputCreateData | ResearchOutputUpdateData,
    researchOutputId?: string,
  ): Promise<ValidationErrorResponse['data'][0] | null> {
    const result = await this.fetch({
      filter: {
        documentType: researchOutputData.documentType,
        title: sanitiseForSquidex(researchOutputData.title),
      },
      includeDrafts: true,
    });

    if (result.total === 0) {
      return null;
    }

    if (result.total === 1 && result.items[0]?.id === researchOutputId) {
      return null;
    }

    return {
      instancePath: '/title',
      keyword: 'unique',
      message: 'must be unique',
      params: {
        type: 'string',
      },
      schemaPath: '#/properties/title/unique',
    };
  }

  private async validateLinkUniqueness(
    researchOutputData: ResearchOutputCreateData | ResearchOutputUpdateData,
    researchOutputId?: string,
  ): Promise<ValidationErrorResponse['data'][0] | null> {
    const result = await this.fetch({
      filter: {
        link: sanitiseForSquidex(researchOutputData.link || ''),
      },
      includeDrafts: true,
    });

    if (result.total === 0) {
      return null;
    }

    if (result.total === 1 && result.items[0]?.id === researchOutputId) {
      return null;
    }

    return {
      instancePath: '/link',
      keyword: 'unique',
      message: 'must be unique',
      params: {
        type: 'string',
      },
      schemaPath: '#/properties/link/unique',
    };
  }

  private async associateResearchOutputToTeam(
    teamId: string,
    researchOutputId: string,
  ) {
    const { data } = await this.teamSquidexRestClient.fetchById(teamId);

    const existingOutputs = data.outputs?.iv || [];
    await this.teamSquidexRestClient.patch(teamId, {
      outputs: {
        iv: [...existingOutputs, researchOutputId],
      },
    });
  }

  private async mapAuthorInputToId(data: ExternalAuthorInput) {
    if ('userId' in data) return data.userId;
    if ('externalAuthorId' in data) return data.externalAuthorId;

    const { id } = await this.externalAuthorSquidexRestClient.create({
      name: { iv: data.externalAuthorName },
    });
    return id;
  }

  private async parseResearchTags(
    researchOutputData: ResearchOutputInputTags,
  ): Promise<ResearchOutputParsedTags> {
    const { queryResearchTagsContentsWithTotal } =
      await this.squidexGraphqlClient.request<
        FetchResearchTagsQuery,
        FetchResearchTagsQueryVariables
      >(FETCH_RESEARCH_TAGS, {
        top: 100,
        skip: 0,
        filter: `data/entities/iv eq 'Research Output'`,
      });

    const researchTags = queryResearchTagsContentsWithTotal?.items || [];

    const methods = mapResearchTags(
      researchTags,
      'Method',
      researchOutputData.methods,
      'methods',
    );

    const organisms = mapResearchTags(
      researchTags,
      'Organism',
      researchOutputData.organisms,
      'organisms',
    );

    const environments = mapResearchTags(
      researchTags,
      'Environment',
      researchOutputData.environments,
      'environments',
    );

    const subtype = researchOutputData.subtype
      ? [
          mapResearchTag(
            researchTags,
            'Subtype',
            researchOutputData.subtype,
            'subtype',
          ),
        ]
      : [];

    return {
      methods,
      organisms,
      environments,
      subtype,
    };
  }
}

export interface ResearchOutputController {
  fetch: (options: {
    take?: number;
    skip?: number;
    search?: string;
    filter?: ResearchOutputFilter;
    includeDrafts?: boolean;
  }) => Promise<ListResearchOutputResponse>;

  fetchById: (id: string) => Promise<ResearchOutputResponse>;
  create: (
    researchOutputRequest: ResearchOutputCreateData,
  ) => Promise<Partial<ResearchOutputResponse>>;
  update: (
    id: string,
    researchOutputRequest: ResearchOutputUpdateData,
  ) => Promise<Partial<ResearchOutputResponse>>;
}
export type ResearchOutputCreateData = ResearchOutputPostRequest & {
  createdBy: string;
};

export type ResearchOutputUpdateData = ResearchOutputPutRequest & {
  updatedBy: string;
};

const makeODataFilter = (filter?: ResearchOutputFilter): string => {
  if (Array.isArray(filter)) {
    return filter.map((val) => `data/documentType/iv eq '${val}'`).join(' or ');
  }

  if (filter) {
    return Object.entries(filter)
      .map(([key, val]) => `data/${key}/iv eq '${val}'`)
      .join(' and ');
  }

  return '';
};

const mapResearchTags = (
  researchTags: ResearchTagsResponse,
  category: ResearchTagCategory,
  values: string[],
  instancePath: string,
): string[] =>
  values.map((singleValue) =>
    mapResearchTag(researchTags, category, singleValue, instancePath),
  );

const mapResearchTag = (
  researchTags: ResearchTagsResponse,
  category: ResearchTagCategory,
  value: string,
  instancePath: string,
): string => {
  const filteredTags = researchTags.filter(
    (tag) => tag.flatData.name === value && tag.flatData.category === category,
  );

  if (filteredTags && filteredTags.length > 0 && filteredTags[0]) {
    return filteredTags[0].id;
  }

  const categoryLowercase = category.toLocaleLowerCase();

  throw Boom.badRequest('Validation error', [
    {
      instancePath,
      keyword: 'invalid',
      message: `${value} does not exist`,
      params: {
        type: 'string',
      },
      schemaPath: `#/properties/${categoryLowercase}/invalid`,
    },
  ]);
};

type ResearchOutputFilter =
  | string[]
  | {
      documentType?: string;
      title?: string;
      link?: string;
    };

type ResearchTagsResponse = NonNullable<
  NonNullable<
    FetchResearchTagsQuery['queryResearchTagsContentsWithTotal']
  >['items']
>;

type ResearchOutputInputTags = {
  methods: string[];
  organisms: string[];
  environments: string[];
  subtype?: string;
};
type ResearchOutputParsedTags = {
  methods: string[];
  organisms: string[];
  environments: string[];
  subtype: string[];
};
