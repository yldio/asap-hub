import {
  CalendarCreateDataObject,
  CalendarDataObject,
  CalendarDataProvider,
  CalendarUpdateDataObject,
  FetchCalendarProviderOptions,
  ListCalendarDataObject,
} from '@asap-hub/model';
import {
  InputCalendar,
  parseToSquidex,
  RestCalendar,
  SquidexGraphqlClient,
  SquidexRestClient,
} from '@asap-hub/squidex';
import {
  FetchCalendarQuery,
  FetchCalendarQueryVariables,
  FetchCalendarsQuery,
  FetchCalendarsQueryVariables,
} from '../autogenerated-gql/graphql';
import { parseGraphqlCalendarPartialToDataObject } from '../entities';
import { FETCH_CALENDAR, FETCH_CALENDARS } from '../queries/calendars.queries';
import logger from '../utils/logger';

type GraphqlCalendar = NonNullable<FetchCalendarQuery['findCalendarsContent']>;

export class CalendarSquidexDataProvider implements CalendarDataProvider {
  squidexRestClient: SquidexRestClient<RestCalendar, InputCalendar>;
  squidexGraphqlClient: SquidexGraphqlClient;

  constructor(
    squidexRestClient: SquidexRestClient<RestCalendar, InputCalendar>,
    squidexGraphqlClient: SquidexGraphqlClient,
  ) {
    this.squidexRestClient = squidexRestClient;
    this.squidexGraphqlClient = squidexGraphqlClient;
  }

  async fetchById(id: string): Promise<CalendarDataObject | null> {
    const { findCalendarsContent: calendar } =
      await this.squidexGraphqlClient.request<
        FetchCalendarQuery,
        FetchCalendarQueryVariables
      >(FETCH_CALENDAR, { id });

    if (!calendar) {
      return null;
    }

    return parseGraphQlCalendarToDataObject(calendar);
  }

  async fetch(
    options?: FetchCalendarProviderOptions,
  ): Promise<ListCalendarDataObject> {
    const { maxExpiration, active, resourceId } = options || {};

    let filter = '';
    if (maxExpiration) {
      filter = `data/expirationDate/iv lt ${maxExpiration}`;
    }

    if (resourceId) {
      filter = `data/resourceId/iv eq '${resourceId}'`;
    }

    const { queryCalendarsContentsWithTotal } =
      await this.squidexGraphqlClient.request<
        FetchCalendarsQuery,
        FetchCalendarsQueryVariables
      >(FETCH_CALENDARS, {
        top: 50,
        skip: 0,
        filter,
        order: 'data/name/iv asc',
      });

    if (queryCalendarsContentsWithTotal === null) {
      logger.warn('queryCalendarsContentsWithTotal returned null');

      return {
        items: [],
        total: 0,
      };
    }

    const { items: calendars } = queryCalendarsContentsWithTotal;

    if (calendars === null) {
      logger.warn('queryCalendarsContentsWithTotal items returned null');

      return {
        items: [],
        total: 0,
      };
    }

    let graphqlCalendars: GraphqlCalendar[] = calendars;

    if (active) {
      graphqlCalendars = graphqlCalendars.filter(
        (calendar: GraphqlCalendar) => {
          if (
            (!calendar?.referencingGroupsContents ||
              calendar.referencingGroupsContents.length === 0) &&
            (!calendar?.referencingWorkingGroupsContents ||
              calendar.referencingWorkingGroupsContents.length === 0)
          ) {
            return true;
          }

          return (
            calendar.referencingGroupsContents?.some(
              ({ flatData }) => flatData.active,
            ) ||
            calendar.referencingWorkingGroupsContents?.some(
              ({ flatData: { complete } }) => !complete,
            )
          );
        },
      );
    }

    return {
      items: graphqlCalendars.map(parseGraphQlCalendarToDataObject),
      total: graphqlCalendars.length,
    };
  }

  async create(create: CalendarCreateDataObject): Promise<string> {
    const { id } = await this.squidexRestClient.create(parseToSquidex(create));

    return id;
  }

  async update(id: string, update: CalendarUpdateDataObject): Promise<void> {
    await this.squidexRestClient.patch(id, parseToSquidex(update));
  }
}

export const parseGraphQlCalendarToDataObject = (
  item: GraphqlCalendar,
): CalendarDataObject => ({
  ...parseGraphqlCalendarPartialToDataObject(item.flatData),
  resourceId: item.flatData.resourceId,
  id: item.id,
  version: item.version,
  expirationDate: item.flatData.expirationDate,
  syncToken: item.flatData.syncToken,
  groups: item.referencingGroupsContents?.map(
    ({ id, flatData: { active } }) => ({ id, active: !!active }),
  ),
  workingGroups: item.referencingWorkingGroupsContents?.map(
    ({ id, flatData: { complete } }) => ({ id, complete: !!complete }),
  ),
});
