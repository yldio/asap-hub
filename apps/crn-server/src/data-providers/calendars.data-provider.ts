import {
  CalendarDataObject,
  CalendarRawDataObject,
  FetchCalendarError,
  FetchCalendarOptions,
  isGoogleLegacyCalendarColor,
} from '@asap-hub/model';
import Intercept from 'apr-intercept';
import {
  Calendar,
  InputCalendar,
  parseToSquidex,
  RestCalendar,
  SquidexGraphqlClient,
  SquidexRestClient,
} from '@asap-hub/squidex';
import {
  Calendars,
  CalendarsFlatDataDto,
  FetchCalendarQuery,
  FetchCalendarQueryVariables,
  FetchCalendarsQuery,
  FetchCalendarsQueryVariables,
  GroupsFlatDataDto,
  Maybe,
} from '../autogenerated-gql/graphql';
import { FETCH_CALENDAR, FETCH_CALENDARS } from '../queries/calendars.queries';
import logger from '../utils/logger';

export interface CalendarDataProvider {
  create(create: CalendarDataObject): Promise<CalendarRawDataObject>;
  update(
    id: string,
    update: Partial<CalendarDataObject>,
  ): Promise<CalendarRawDataObject>;
  fetch(
    options: FetchCalendarOptions,
  ): Promise<CalendarRawDataObject[] | FetchCalendarError>;
  fetchById(id: string): Promise<CalendarRawDataObject | FetchCalendarError>;
  fetchByResourceId(
    resourceId: string,
  ): Promise<RestCalendar | FetchCalendarError>;
}

export type GraphqlCalendar = Maybe<
  Pick<Calendars, 'id' | 'created' | 'lastModified' | 'version'> & {
    flatData: Pick<
      CalendarsFlatDataDto,
      | 'googleCalendarId'
      | 'name'
      | 'color'
      | 'syncToken'
      | 'resourceId'
      | 'expirationDate'
    >;
    referencingGroupsContents: Maybe<
      {
        flatData: Pick<GroupsFlatDataDto, 'active'>;
      }[]
    >;
  }
>;

export default class CalendarSquidexDataProvider {
  squidexRestClient: SquidexRestClient<RestCalendar, InputCalendar>;
  squidexGraphqlClient: SquidexGraphqlClient;

  constructor(
    squidexRestClient: SquidexRestClient<RestCalendar, InputCalendar>,
    squidexGraphqlClient: SquidexGraphqlClient,
  ) {
    this.squidexRestClient = squidexRestClient;
    this.squidexGraphqlClient = squidexGraphqlClient;
  }

  async parseSquidexRestResponseToRaw(
    calendar: RestCalendar,
  ): Promise<CalendarRawDataObject> {
    return {
      googleCalendarId: calendar.data.googleCalendarId.iv,
      color: calendar.data.color.iv,
      name: calendar.data.name.iv,
      syncToken: calendar.data.syncToken?.iv,
      resourceId: calendar.data.resourceId?.iv,
      expirationDate: calendar.data.expirationDate?.iv,
      id: calendar.id,
      version: calendar.version,
    };
  }

  async parseSquidexGraphqlResponseToRaw(calendar: GraphqlCalendar) {
    if (!calendar) {
      return FetchCalendarError.CalendarNotFound;
    }

    if (!calendar.flatData.googleCalendarId || !calendar.flatData.name) {
      return FetchCalendarError.MissingRequiredData;
    }

    if (!isGoogleLegacyCalendarColor(calendar.flatData.color)) {
      return FetchCalendarError.InvalidColor;
    }

    return {
      id: calendar.id,
      version: calendar.version,
      googleCalendarId: calendar.flatData.googleCalendarId,
      color: calendar.flatData.color,
      name: calendar.flatData.name,
      expirationDate: calendar.flatData.expirationDate ?? null,
      resourceId: calendar.flatData.resourceId ?? null,
      syncToken: calendar.flatData.syncToken ?? null,
    };
  }

  async create(create: Calendar): Promise<CalendarRawDataObject> {
    const res = await this.squidexRestClient.create(parseToSquidex(create));

    return this.parseSquidexRestResponseToRaw(res);
  }

  async update(
    id: string,
    update: Partial<Calendar>,
  ): Promise<CalendarRawDataObject> {
    const res = await this.squidexRestClient.patch(id, parseToSquidex(update));

    return this.parseSquidexRestResponseToRaw(res);
  }

  async fetch(
    options: FetchCalendarOptions,
  ): Promise<CalendarRawDataObject[] | FetchCalendarError> {
    const { maxExpiration, onlyActive, take, skip } = options;

    const { queryCalendarsContentsWithTotal } =
      await this.squidexGraphqlClient.request<
        FetchCalendarsQuery,
        FetchCalendarsQueryVariables
      >(FETCH_CALENDARS, {
        top: take || 0,
        skip: skip || 0,
        filter: '',
        order: 'data/name/iv asc',
      });

    if (queryCalendarsContentsWithTotal === null) {
      logger.warn('queryCalendarsContentsWithTotal returned null');
      return FetchCalendarError.FetchError;
    }

    const { items: calendars } = queryCalendarsContentsWithTotal;

    if (calendars === null) {
      logger.warn('queryCalendarsContentsWithTotal items returned null');
      return FetchCalendarError.CalendarNotFound;
    }

    let graphqlCalendars: GraphqlCalendar[] = calendars;

    if (!!onlyActive) {
      graphqlCalendars = graphqlCalendars.filter(
        (calendar: GraphqlCalendar) => {
          if (
            !calendar?.referencingGroupsContents ||
            calendar.referencingGroupsContents.length === 0
          ) {
            return true;
          }

          return (
            calendar.referencingGroupsContents.findIndex(
              (group) => group.flatData.active === true,
            ) !== -1
          );
        },
      );
    }

    if (maxExpiration) {
      graphqlCalendars = graphqlCalendars.filter(
        (calendar: GraphqlCalendar) => {
          return (
            calendar?.flatData.expirationDate &&
            calendar.flatData.expirationDate < maxExpiration
          );
        },
      );
    }

    if (graphqlCalendars.length === 0) {
      return FetchCalendarError.CalendarNotFound;
    }

    const res = await Promise.all(
      calendars.map(this.parseSquidexGraphqlResponseToRaw),
    );

    const errors: FetchCalendarError[] = res.filter(
      (el: any) => el in FetchCalendarError,
    ) as FetchCalendarError[];
    const resCalendars: CalendarRawDataObject[] = res.filter(
      (el: any) => !(el in FetchCalendarError),
    ) as CalendarRawDataObject[];

    if (resCalendars.length > 0) {
      return resCalendars;
    }

    return errors[0] || FetchCalendarError.FetchError;
  }

  async fetchById(
    id: string,
  ): Promise<CalendarRawDataObject | FetchCalendarError> {
    const { findCalendarsContent: calendar } =
      await this.squidexGraphqlClient.request<
        FetchCalendarQuery,
        FetchCalendarQueryVariables
      >(FETCH_CALENDAR, { id });

    return await this.parseSquidexGraphqlResponseToRaw(calendar);
  }

  async fetchByResourceId(
    resourceId: string,
  ): Promise<RestCalendar | FetchCalendarError> {
    const [err, res] = await Intercept(
      this.squidexRestClient.client
        .get('calendars', {
          searchParams: {
            $top: 1,
            $filter: `data/resourceId/iv eq '${resourceId}`,
          },
        })
        .json() as Promise<{ items: RestCalendar[] }>,
    );

    if (err) {
      return FetchCalendarError.FetchError;
    }

    if (res.items.length === 0 || !res.items[0]) {
      return FetchCalendarError.CalendarNotFound;
    }

    return res.items[0];
  }
}
