import {
  CalendarCreateDataObject,
  CalendarDataObject,
  CalendarUpdateDataObject,
  ListCalendarDataObject,
} from '@asap-hub/model';
import {
  InputCalendar,
  parseToSquidex,
  RestCalendar,
  SquidexGraphqlClient,
  SquidexRestClient,
} from '@asap-hub/squidex';
import {
  FetchCalendarQuery,
  FetchCalendarQueryVariables,
  FetchCalendarsQuery,
  FetchCalendarsQueryVariables,
} from '../autogenerated-gql/graphql';
import { parseGraphqlCalendarPartialToDataObject } from '../entities';
import { FETCH_CALENDAR, FETCH_CALENDARS } from '../queries/calendars.queries';
import logger from '../utils/logger';

export type FetchCalendarProviderOptions = {
  maxExpiration?: number;
  active?: boolean;
};

type GraphqlCalendar = NonNullable<FetchCalendarQuery['findCalendarsContent']>;

export interface CalendarDataProvider {
  create(create: CalendarCreateDataObject): Promise<string>;
  update(id: string, update: CalendarUpdateDataObject): Promise<void>;
  fetch(
    options?: FetchCalendarProviderOptions,
  ): Promise<ListCalendarDataObject>;
  fetchById(id: string): Promise<CalendarDataObject | null>;
}

export default class CalendarSquidexDataProvider {
  squidexRestClient: SquidexRestClient<RestCalendar, InputCalendar>;
  squidexGraphqlClient: SquidexGraphqlClient;

  constructor(
    squidexRestClient: SquidexRestClient<RestCalendar, InputCalendar>,
    squidexGraphqlClient: SquidexGraphqlClient,
  ) {
    this.squidexRestClient = squidexRestClient;
    this.squidexGraphqlClient = squidexGraphqlClient;
  }

  async fetchById(id: string): Promise<CalendarDataObject | null> {
    const { findCalendarsContent: calendar } =
      await this.squidexGraphqlClient.request<
        FetchCalendarQuery,
        FetchCalendarQueryVariables
      >(FETCH_CALENDAR, { id });

    if (!calendar) {
      return null;
    }

    return parseGraphQlCalendarToDataObject(calendar);
  }

  async fetch(
    options?: FetchCalendarProviderOptions,
  ): Promise<ListCalendarDataObject> {
    const { maxExpiration, active } = options || {};

    let filter = '';
    if (maxExpiration) {
      filter = `data/expirationDate/iv lt ${maxExpiration}`;
    }

    const { queryCalendarsContentsWithTotal } =
      await this.squidexGraphqlClient.request<
        FetchCalendarsQuery,
        FetchCalendarsQueryVariables
      >(FETCH_CALENDARS, {
        top: 50,
        skip: 0,
        filter,
        order: 'data/name/iv asc',
      });

    if (queryCalendarsContentsWithTotal === null) {
      logger.warn('queryCalendarsContentsWithTotal returned null');

      return {
        items: [],
        total: 0,
      };
    }

    const { items: calendars } = queryCalendarsContentsWithTotal;

    if (calendars === null) {
      logger.warn('queryCalendarsContentsWithTotal items returned null');

      return {
        items: [],
        total: 0,
      };
    }

    let graphqlCalendars: GraphqlCalendar[] = calendars;

    if (active) {
      graphqlCalendars = graphqlCalendars.filter(
        (calendar: GraphqlCalendar) => {
          if (
            !calendar?.referencingGroupsContents ||
            calendar.referencingGroupsContents.length === 0
          ) {
            return true;
          }

          return (
            calendar.referencingGroupsContents.findIndex(
              (group) => group.flatData.active === true,
            ) !== -1
          );
        },
      );
    }

    return {
      items: graphqlCalendars.map(parseGraphQlCalendarToDataObject),
      total: graphqlCalendars.length,
    };
  }

  async create(create: CalendarCreateDataObject): Promise<string> {
    const res = await this.squidexRestClient.create(parseToSquidex(create));

    return res.id;
  }

  async update(id: string, update: CalendarUpdateDataObject): Promise<void> {
    await this.squidexRestClient.patch(id, parseToSquidex(update));
  }
}

export const parseGraphQlCalendarToDataObject = (
  item: GraphqlCalendar,
): CalendarDataObject => ({
  ...parseGraphqlCalendarPartialToDataObject(item.flatData),
  resourceId: item.flatData.resourceId,
  id: item.id,
  version: item.version,
  expirationDate: item.flatData.expirationDate,
  syncToken: item.flatData.syncToken,
});
