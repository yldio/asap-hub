import {
  WorkingGroupLeader,
  WorkingGroupMember,
  WorkingGroupRole,
  WorkingGroupDataObject,
  CalendarResponse,
  WorkingGroupResponse,
} from '@asap-hub/model';
import { FetchWorkingGroupQuery } from '../../autogenerated-gql/graphql';
import { createUrl } from '../../utils/urls';
import { parseGraphqlCalendarToResponse } from './calendar';

export const parseGraphQLWorkingGroupMembers = (
  members: NonNullable<
    NonNullable<FetchWorkingGroupQuery['findWorkingGroupsContent']>['flatData']
  >['members'],
): WorkingGroupMember[] =>
  members?.flatMap((member) =>
    member.user?.[0]
      ? {
          inactiveSinceDate: member.inactiveSinceDate,
          user: {
            id: member.user[0]?.id || '',
            firstName: member.user[0]?.flatData.firstName || '',
            lastName: member.user[0]?.flatData.lastName || '',
            displayName: `${member.user[0]?.flatData.firstName} ${member.user[0]?.flatData.lastName}`,
            alumniSinceDate: member.user[0]?.flatData.alumniSinceDate,
            email: member.user[0]?.flatData.email || '',
            avatarUrl: member.user[0]?.flatData.avatar?.length
              ? createUrl(member.user[0]?.flatData.avatar.map((a) => a.id))[0]
              : undefined,
          },
        }
      : [],
  ) || [];

export const parseGraphQLWorkingGroupLeaders = (
  leaders: NonNullable<
    NonNullable<FetchWorkingGroupQuery['findWorkingGroupsContent']>['flatData']
  >['leaders'],
): WorkingGroupLeader[] =>
  leaders?.flatMap((leader) =>
    leader.user?.[0]
      ? {
          role: leader.role as WorkingGroupRole,
          workstreamRole: leader.workstreamRole || '',
          inactiveSinceDate: leader.inactiveSinceDate,
          user: {
            id: leader.user[0]?.id || '',
            firstName: leader.user[0]?.flatData.firstName || '',
            lastName: leader.user[0]?.flatData.lastName || '',
            displayName: `${leader.user[0]?.flatData.firstName} ${leader.user[0]?.flatData.lastName}`,
            alumniSinceDate: leader.user[0]?.flatData.alumniSinceDate,
            email: leader.user[0]?.flatData.email || '',
            avatarUrl: leader.user[0]?.flatData.avatar?.length
              ? createUrl(leader.user[0]?.flatData.avatar.map((a) => a.id))[0]
              : undefined,
          },
        }
      : [],
  ) || [];

export const parseGraphQlWorkingGroup = (
  workingGroupGraphQl: NonNullable<
    FetchWorkingGroupQuery['findWorkingGroupsContent']
  >,
): WorkingGroupDataObject => {
  const leaders = parseGraphQLWorkingGroupLeaders(
    workingGroupGraphQl.flatData.leaders,
  );

  const calendars: CalendarResponse[] = (
    workingGroupGraphQl.flatData?.calendars || []
  ).map((c) => parseGraphqlCalendarToResponse(c.flatData));

  const workingGroup: WorkingGroupDataObject = {
    id: workingGroupGraphQl.id,
    title: workingGroupGraphQl.flatData.title || '',
    description: workingGroupGraphQl.flatData.description || '',
    shortText: workingGroupGraphQl.flatData.shortText || '',
    members: parseGraphQLWorkingGroupMembers(
      workingGroupGraphQl.flatData.members,
    ),
    leaders,
    pointOfContact: leaders.find(
      ({ role, inactiveSinceDate, user: { alumniSinceDate } }) =>
        role === 'Project Manager' && !alumniSinceDate && !inactiveSinceDate,
    ),
    complete: !!workingGroupGraphQl.flatData.complete,
    deliverables: workingGroupGraphQl.flatData.deliverables
      ? workingGroupGraphQl.flatData.deliverables.map(
          (deliverable) =>
            ({
              status: deliverable.status ?? 'Not Started',
              description: deliverable.description ?? '',
            } as WorkingGroupDataObject['deliverables'][number]),
        )
      : [],
    lastModifiedDate: workingGroupGraphQl.lastModified,
    calendars,
  };

  if (!workingGroupGraphQl.flatData.externalLink) {
    return workingGroup;
  }

  return {
    ...workingGroup,
    externalLink: workingGroupGraphQl.flatData.externalLink,
  };
};

export const toWorkingGroupResponse = (
  workingGroup: WorkingGroupDataObject,
): WorkingGroupResponse => ({
  ...workingGroup,
  leaders: workingGroup.leaders.map((leader) => ({
    ...leader,
    isActive: workingGroup.complete
      ? false
      : !!leader?.user?.alumniSinceDate === false &&
        !!leader?.inactiveSinceDate === false,
  })),
  members: workingGroup.members.map((member) => ({
    ...member,
    isActive: workingGroup.complete
      ? false
      : !!member?.user?.alumniSinceDate === false &&
        !!member?.inactiveSinceDate === false,
  })),
});
