import {
  EventCreateDataObject,
  EventDataObject,
  EventUpdateDataObject,
  FetchEventsOptions,
  ListEventDataObject,
} from '@asap-hub/model';
import {
  InputEvent,
  RestEvent,
  sanitiseForSquidex,
  SquidexGraphqlClient,
  SquidexRestClient,
} from '@asap-hub/squidex';
import Boom from '@hapi/boom';
import {
  FetchEventQuery,
  FetchEventQueryVariables,
  FetchEventsQuery,
  FetchEventsQueryVariables,
  FetchGroupCalendarQuery,
  FetchGroupCalendarQueryVariables,
  FetchWorkingGroupCalendarQuery,
  FetchWorkingGroupCalendarQueryVariables,
} from '../autogenerated-gql/graphql';
import { parseGraphQLEvent } from '../entities/event';
import {
  FETCH_EVENT,
  FETCH_EVENTS,
  FETCH_GROUP_CALENDAR,
  FETCH_WORKING_GROUP_CALENDAR,
} from '../queries/events.queries';
import logger from '../utils/logger';

export type FetchEventProviderOptions = {
  maxExpiration?: number;
  active?: boolean;
  resourceId?: string;
};

export interface EventDataProvider {
  create(create: EventCreateDataObject): Promise<string>;
  update(id: string, update: EventUpdateDataObject): Promise<void>;
  fetch(options?: FetchEventsOptions): Promise<ListEventDataObject>;
  fetchById(id: string): Promise<EventDataObject | null>;
}

export class EventSquidexDataProvider {
  constructor(
    private squidexRestClient: SquidexRestClient<RestEvent, InputEvent>,
    private squidexGraphqlClient: SquidexGraphqlClient,
  ) {}

  async fetchById(id: string): Promise<EventDataObject | null> {
    const { findEventsContent: event } =
      await this.squidexGraphqlClient.request<
        FetchEventQuery,
        FetchEventQueryVariables
      >(FETCH_EVENT, { id });

    if (!event) {
      return null;
    }

    return parseGraphQLEvent(event);
  }

  async fetch(options: FetchEventsOptions): Promise<ListEventDataObject> {
    const {
      take = 10,
      skip = 0,
      before,
      after,
      search,
      sortBy,
      sortOrder,
      filter,
    } = options;

    const filters = (search || '')
      .split(' ')
      .filter(Boolean)
      .map(sanitiseForSquidex)
      .reduce(
        (acc: string[], word: string) =>
          acc.concat(
            `(${[
              [`contains(data/title/iv, '${word}')`],
              [`contains(data/tags/iv, '${word}')`],
            ].join(' or ')})`,
          ),
        [],
      );

    if (filter?.hidden !== true) {
      filters.push('data/hidden/iv ne true');
    }

    if (after) {
      filters.push(`data/endDate/iv gt ${after}`);
    }

    if (before) {
      filters.push(`data/endDate/iv lt ${before}`);
    }

    let orderby = '';

    if (sortBy && sortOrder) {
      orderby = `data/${sortBy}/iv ${sortOrder}`;
    }

    if (filter?.groupId) {
      const { findGroupsContent } = await this.squidexGraphqlClient.request<
        FetchGroupCalendarQuery,
        FetchGroupCalendarQueryVariables
      >(FETCH_GROUP_CALENDAR, {
        id: filter.groupId,
      });

      if (!findGroupsContent) {
        throw Boom.notFound();
      }

      const calendarIds = (findGroupsContent.flatData.calendars ?? []).map(
        ({ id }) => `'${id}'`,
      );

      filters.push(`data/calendar/iv in [${calendarIds.join(', ')}]`);
    }

    if (filter?.workingGroupId) {
      const { findWorkingGroupsContent } =
        await this.squidexGraphqlClient.request<
          FetchWorkingGroupCalendarQuery,
          FetchWorkingGroupCalendarQueryVariables
        >(FETCH_WORKING_GROUP_CALENDAR, {
          id: filter.workingGroupId,
        });

      if (!findWorkingGroupsContent) {
        throw Boom.notFound();
      }

      const calendarIds = (
        findWorkingGroupsContent.flatData.calendars ?? []
      ).map(({ id }) => `'${id}'`);

      filters.push(`data/calendar/iv in [${calendarIds.join(', ')}]`);
    }

    if (filter?.userId) {
      filters.push(`data/speakers/iv/user eq '${filter.userId}'`);
    }

    if (filter?.externalAuthorId) {
      filters.push(`data/speakers/iv/user eq '${filter.externalAuthorId}'`);
    }

    if (filter?.teamId) {
      filters.push(`data/speakers/iv/team eq '${filter.teamId}'`);
    }

    if (filter?.googleId) {
      filters.push(`data/googleId/iv eq '${filter.googleId}'`);
    }

    const { queryEventsContentsWithTotal } =
      await this.squidexGraphqlClient.request<
        FetchEventsQuery,
        FetchEventsQueryVariables
      >(FETCH_EVENTS, {
        filter: filters.join(' and '),
        top: take,
        skip,
        order: orderby,
      });

    if (
      !queryEventsContentsWithTotal?.total ||
      !queryEventsContentsWithTotal?.items
    ) {
      logger.warn('queryEventsContentsWithTotal returned null');
      return {
        total: 0,
        items: [],
      };
    }

    return {
      total: queryEventsContentsWithTotal.total,
      items: queryEventsContentsWithTotal.items.map((item) =>
        parseGraphQLEvent(item),
      ),
    };
  }

  async create(create: EventCreateDataObject): Promise<string> {
    const { id } = await this.squidexRestClient.create(toEventData(create));

    return id;
  }

  async update(id: string, update: EventUpdateDataObject): Promise<void> {
    await this.squidexRestClient.patch(id, toEventData(update));
  }
}

const toEventData = (
  data: EventCreateDataObject | EventUpdateDataObject,
): RestEvent['data'] => {
  const parsed = Object.entries(data).reduce((acc, [key, value]) => {
    acc[key] = { iv: value };
    return acc;
  }, {} as { [key: string]: { iv: unknown } }) as RestEvent['data'];

  return {
    ...parsed,
    ...(data.calendar && { calendar: { iv: [data.calendar] } }),
  };
};
