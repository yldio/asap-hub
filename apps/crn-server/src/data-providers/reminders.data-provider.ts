import {
  VideoEventReminder,
  EventHappeningNowReminder,
  EventHappeningTodayReminder,
  FetchRemindersOptions,
  isResearchOutputDocumentType,
  ListReminderDataObject,
  ReminderDataObject,
  ResearchOutputPublishedReminder,
  PresentationUpdatedReminder,
} from '@asap-hub/model';
import { SquidexGraphqlClient } from '@asap-hub/squidex';
import { DateTime } from 'luxon';
import {
  FetchReminderDataQuery,
  FetchReminderDataQueryVariables,
  Maybe,
  Teams,
} from '../autogenerated-gql/graphql';
import { FETCH_REMINDER_DATA } from '../queries/reminders.queries';

export interface ReminderDataProvider {
  fetch: (options: FetchRemindersOptions) => Promise<ListReminderDataObject>;
}

export class ReminderSquidexDataProvider implements ReminderDataProvider {
  constructor(private squidexGraphqlClient: SquidexGraphqlClient) {
    this.squidexGraphqlClient = squidexGraphqlClient;
  }

  async fetch(options: FetchRemindersOptions): Promise<ListReminderDataObject> {
    const researchOutputFilter = getResearchOutputFilter();

    const {
      findUsersContent,
      queryResearchOutputsContents,
      queryEventsContents,
    } = await this.squidexGraphqlClient.request<
      FetchReminderDataQuery,
      FetchReminderDataQueryVariables
    >(FETCH_REMINDER_DATA, {
      researchOutputFilter,
      eventFilter: getEventFilter(options.timezone),
      userId: options.userId,
    });

    const researchOutputReminders = getResearchOutputRemindersFromQuery(
      queryResearchOutputsContents,
      findUsersContent,
    );

    const eventReminders = getEventRemindersFromQuery(queryEventsContents);
    const eventMaterialsReminders =
      getEventMaterialsRemindersFromQuery(queryEventsContents);

    const reminders = [
      ...researchOutputReminders,
      ...eventReminders,
      ...eventMaterialsReminders,
    ];

    const sortedReminders = reminders.sort((reminderA, reminderB) => {
      const aStartDate = getSortDate(reminderA);
      const bStartDate = getSortDate(reminderB);

      return bStartDate.diff(aStartDate).as('seconds');
    });

    return {
      total: sortedReminders.length,
      items: sortedReminders,
    };
  }
}

const getResearchOutputFilter = (): string => {
  const date = new Date();
  date.setDate(date.getDate() - 1);
  const date24hAgo = date.toISOString();

  const filter = `data/addedDate/iv ge ${date24hAgo}`;
  return filter;
};

export const getEventFilter = (zone: string): string => {
  const lastMidnightISO = DateTime.fromObject({
    zone,
  })
    .set({ hour: 0, minute: 0, second: 0, millisecond: 0 })
    .toUTC();

  const todayMidnightISO = DateTime.fromObject({
    zone,
  })
    .set({ hour: 0, minute: 0, second: 0, millisecond: 0 })
    .plus({ day: 1 })
    .toUTC();

  const lastDayISO = DateTime.fromObject({
    zone,
  })
    .minus({ day: 1 })
    .toUTC();

  return `data/videoRecordingUpdatedAt/iv ge ${lastDayISO} or data/presentationUpdatedAt/iv ge ${lastDayISO} or (data/startDate/iv ge ${lastMidnightISO} and data/startDate/iv le ${todayMidnightISO})`;
};

const getUserTeamIds = (
  teams: { id: Maybe<Pick<Teams, 'id'>[]> }[],
): string[] => {
  const teamWithId = (team: {
    id: Maybe<Pick<Teams, 'id'>[]>;
  }): team is { id: [{ id: string }] } => !!team.id && team.id.length > 0;

  const userTeams = teams.filter(teamWithId).map((team) => team.id[0].id);
  return userTeams;
};

const getResearchOutputRemindersFromQuery = (
  queryResearchOutputsContents: FetchReminderDataQuery['queryResearchOutputsContents'],
  findUsersContent: FetchReminderDataQuery['findUsersContent'],
): ResearchOutputPublishedReminder[] => {
  if (!findUsersContent || !findUsersContent.flatData.teams) {
    return [];
  }

  const userTeamIds = getUserTeamIds(findUsersContent.flatData.teams);

  if (!queryResearchOutputsContents) {
    return [];
  }

  return queryResearchOutputsContents.reduce<ResearchOutputPublishedReminder[]>(
    (researchOutputReminders, researchOutput) => {
      if (!researchOutput.referencingTeamsContents) {
        return researchOutputReminders;
      }

      const researchOutputTeams = researchOutput.referencingTeamsContents.map(
        (team) => team.id,
      );

      const isInTeam = researchOutputTeams.some((team) =>
        userTeamIds.includes(team),
      );

      if (
        !researchOutput.flatData.documentType ||
        !isResearchOutputDocumentType(researchOutput.flatData.documentType) ||
        !researchOutput.flatData.title
      ) {
        return researchOutputReminders;
      }

      if (isInTeam) {
        researchOutputReminders.push({
          id: `research-output-published-${researchOutput.id}`,
          entity: 'Research Output',
          type: 'Published',
          data: {
            researchOutputId: researchOutput.id,
            documentType: researchOutput.flatData.documentType,
            title: researchOutput.flatData.title,
            addedDate: researchOutput.flatData.addedDate,
          },
        });
      }

      return researchOutputReminders;
    },
    [],
  );
};

const getEventRemindersFromQuery = (
  queryEventsContents: FetchReminderDataQuery['queryEventsContents'],
): (EventHappeningTodayReminder | EventHappeningNowReminder)[] => {
  const eventReminders = (queryEventsContents || []).reduce<
    (EventHappeningTodayReminder | EventHappeningNowReminder)[]
  >((events, event) => {
    const startDate = DateTime.fromISO(event.flatData.startDate);
    const endDate = DateTime.fromISO(event.flatData.endDate);

    if (startDate > DateTime.local()) {
      return [
        ...events,
        {
          id: `event-happening-today-${event.id}`,
          entity: 'Event',
          type: 'Happening Today',
          data: {
            eventId: event.id,
            title: event.flatData.title || '',
            startDate: event.flatData.startDate,
          },
        },
      ];
    }

    if (endDate > DateTime.local()) {
      return [
        ...events,
        {
          id: `event-happening-now-${event.id}`,
          entity: 'Event',
          type: 'Happening Now',
          data: {
            eventId: event.id,
            title: event.flatData.title || '',
            startDate: event.flatData.startDate,
            endDate: event.flatData.endDate,
          },
        },
      ];
    }

    return events;
  }, []);

  return eventReminders;
};

const wasMaterialUpdatedInLast24Hours = (date: string) => {
  const ONE_DAY_IN_MS = 24 * 60 * 60 * 1000;

  const msBetweenNowAndMaterialUpdatedAt = DateTime.now().diff(
    DateTime.fromISO(date),
  ).milliseconds;

  return (
    msBetweenNowAndMaterialUpdatedAt <= ONE_DAY_IN_MS &&
    msBetweenNowAndMaterialUpdatedAt > 0
  );
};

const getEventMaterialsRemindersFromQuery = (
  queryEventsContents: FetchReminderDataQuery['queryEventsContents'],
): (VideoEventReminder | PresentationUpdatedReminder)[] => {
  const eventReminders = (queryEventsContents || []).reduce<
    (VideoEventReminder | PresentationUpdatedReminder)[]
  >((events, event) => {
    const {
      id: eventId,
      flatData: { title, videoRecordingUpdatedAt, presentationUpdatedAt },
    } = event;

    if (wasMaterialUpdatedInLast24Hours(videoRecordingUpdatedAt)) {
      events.push({
        id: `video-event-updated-${eventId}`,
        entity: 'Event',
        type: 'Video Updated',
        data: { eventId, title: title || '', videoRecordingUpdatedAt },
      });
    }

    if (wasMaterialUpdatedInLast24Hours(presentationUpdatedAt)) {
      events.push({
        id: `presentation-event-updated-${eventId}`,
        entity: 'Event',
        type: 'Presentation Updated',
        data: { eventId, title: title || '', presentationUpdatedAt },
      });
    }

    return events;
  }, []);

  return eventReminders;
};

const getSortDate = (reminder: ReminderDataObject): DateTime => {
  if (reminder.entity === 'Research Output') {
    return DateTime.fromISO(reminder.data.addedDate);
  }

  if (reminder.type === 'Happening Today') {
    return DateTime.fromISO(reminder.data.startDate);
  }

  if (reminder.type === 'Video Updated') {
    return DateTime.fromISO(reminder.data.videoRecordingUpdatedAt);
  }

  if (reminder.type === 'Presentation Updated') {
    return DateTime.fromISO(reminder.data.presentationUpdatedAt);
  }

  return DateTime.fromISO(reminder.data.endDate);
};
