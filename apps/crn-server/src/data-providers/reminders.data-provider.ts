import {
  DataProvider,
  EventHappeningNowReminder,
  EventHappeningTodayReminder,
  EventNotesReminder,
  FetchRemindersOptions,
  isResearchOutputDocumentType,
  ListReminderDataObject,
  PresentationUpdatedReminder,
  PublishMaterialReminder,
  ReminderDataObject,
  ResearchOutputDraftReminder,
  ResearchOutputInReviewReminder,
  ResearchOutputPublishedReminder,
  Role,
  SharePresentationReminder,
  TeamRole,
  UploadPresentationReminder,
  VideoEventReminder,
} from '@asap-hub/model';
import { SquidexGraphqlClient } from '@asap-hub/squidex';
import { isCMSAdministrator } from '@asap-hub/validation';
import { DateTime } from 'luxon';
import {
  FetchReminderDataQuery,
  FetchReminderDataQueryVariables,
  Maybe,
  Teams,
  WorkingGroups,
} from '../autogenerated-gql/graphql';
import { FETCH_REMINDER_DATA } from '../queries/reminders.queries';

export type ReminderDataProvider = DataProvider<
  ReminderDataObject,
  FetchRemindersOptions
>;

type DraftResearchOutputQueried = NonNullable<
  FetchReminderDataQuery['draftResearchOutputs']
>[number];

type InReviewResearchOutputQueried = NonNullable<
  FetchReminderDataQuery['inReviewResearchOutputs']
>[number];

export class ReminderSquidexDataProvider implements ReminderDataProvider {
  constructor(private squidexGraphqlClient: SquidexGraphqlClient) {
    this.squidexGraphqlClient = squidexGraphqlClient;
  }

  async fetchById(): Promise<null> {
    throw new Error('Method not implemented.');
  }

  async fetch(options: FetchRemindersOptions): Promise<ListReminderDataObject> {
    const researchOutputFilter = getResearchOutputFilter();
    const researchOutputDraftFilter = getResearchOutputDraftFilter();
    const researchOutputInReviewFilter = getResearchOutputInReviewFilter();

    const {
      findUsersContent,
      queryResearchOutputsContents,
      draftResearchOutputs,
      inReviewResearchOutputs,
      queryEventsContents,
    } = await this.squidexGraphqlClient.request<
      FetchReminderDataQuery,
      FetchReminderDataQueryVariables
    >(
      FETCH_REMINDER_DATA,
      {
        researchOutputFilter,
        researchOutputDraftFilter,
        researchOutputInReviewFilter,
        eventFilter: getEventFilter(options.timezone),
        userId: options.userId,
      },
      { includeDrafts: true },
    );

    const researchOutputReminders = getResearchOutputRemindersFromQuery(
      queryResearchOutputsContents,
      findUsersContent,
    );

    const researchOutputDraftReminders =
      getResearchOutputDraftRemindersFromQuery(
        draftResearchOutputs,
        findUsersContent,
      );

    const inReviewResearchOutputReminders =
      getResearchOutputInReviewRemindersFromQuery(
        inReviewResearchOutputs,
        findUsersContent,
        options.userId,
      );

    const eventReminders = getEventRemindersFromQuery(queryEventsContents);

    const sharePresentationReminders = getSharePresentationRemindersFromQuery(
      queryEventsContents,
      options.userId,
    );

    const publishPresentationReminders = getPublishMaterialRemindersFromQuery(
      queryEventsContents,
      findUsersContent,
    );

    const uploadPresentationReminders = getUploadPresentationRemindersFromQuery(
      queryEventsContents,
      findUsersContent,
    );

    const eventMaterialsReminders =
      getEventMaterialsRemindersFromQuery(queryEventsContents);

    const reminders = [
      ...researchOutputReminders,
      ...eventReminders,
      ...sharePresentationReminders,
      ...eventMaterialsReminders,
      ...publishPresentationReminders,
      ...uploadPresentationReminders,
      ...researchOutputDraftReminders,
      ...inReviewResearchOutputReminders,
    ];

    const sortedReminders = reminders.sort((reminderA, reminderB) => {
      const aStartDate = getSortDate(reminderA);
      const bStartDate = getSortDate(reminderB);

      return bStartDate.diff(aStartDate).as('seconds');
    });

    return {
      total: sortedReminders.length,
      items: sortedReminders,
    };
  }
}

const getResearchOutputFilter = (): string => {
  const date = new Date();
  date.setDate(date.getDate() - 1);
  const date24hAgo = date.toISOString();

  const filter = `data/addedDate/iv ge ${date24hAgo} and status ne 'Draft'`;
  return filter;
};

const getResearchOutputDraftFilter = (): string => {
  const date = new Date();
  date.setDate(date.getDate() - 1);
  const date24hAgo = date.toISOString();

  const filter = `created ge ${date24hAgo} and status eq 'Draft' and data/addedDate/iv eq null and empty(data/reviewRequestedBy/iv)`;
  return filter;
};

const getResearchOutputInReviewFilter = (): string =>
  `status eq 'Draft' and data/addedDate/iv eq null and exists(data/reviewRequestedBy/iv)`;

export const getEventFilter = (zone: string): string => {
  const lastMidnightISO = DateTime.fromObject({
    zone,
  })
    .set({ hour: 0, minute: 0, second: 0, millisecond: 0 })
    .toUTC();

  const todayMidnightISO = DateTime.fromObject({
    zone,
  })
    .set({ hour: 0, minute: 0, second: 0, millisecond: 0 })
    .plus({ day: 1 })
    .toUTC();

  const lastDayISO = DateTime.fromObject({
    zone,
  })
    .minus({ day: 1 })
    .toUTC();

  const last72HoursISO = DateTime.fromObject({
    zone,
  })
    .minus({ hours: 72 })
    .toUTC();

  const now = DateTime.fromObject({
    zone,
  }).toUTC();

  const eventFilter = `data/videoRecordingUpdatedAt/iv ge ${lastDayISO} or data/presentationUpdatedAt/iv ge ${lastDayISO} or data/notesUpdatedAt/iv ge ${lastDayISO} or (data/startDate/iv ge ${lastMidnightISO} and data/startDate/iv le ${todayMidnightISO}) or (data/endDate/iv ge ${last72HoursISO} and data/endDate/iv le ${now})`;
  const eventFilterPublished = `(${eventFilter}) and status ne 'Draft'`;

  return eventFilterPublished;
};

const getUserTeamIds = (
  teams: { id: Maybe<Pick<Teams, 'id'>[]> }[],
): string[] => {
  const teamWithId = (team: {
    id: Maybe<Pick<Teams, 'id'>[]>;
  }): team is { id: [{ id: string }] } => !!team.id && team.id.length > 0;

  const userTeams = teams.filter(teamWithId).map((team) => team.id[0].id);
  return userTeams;
};

const getUserWorkingGroupIds = (
  workingGroups: NonNullable<
    FetchReminderDataQuery['findUsersContent']
  >['referencingWorkingGroupsContents'],
): string[] => {
  if (!workingGroups) {
    return [];
  }

  const idIsPresent = (
    workingGroup: Pick<WorkingGroups, 'id'>,
  ): workingGroup is { id: string } =>
    !!workingGroup && typeof workingGroup.id === 'string';

  const userWorkingGroupIds = workingGroups
    .filter(idIsPresent)
    .map((workingGroup) => workingGroup.id);

  return userWorkingGroupIds;
};

const getResearchOutputRemindersFromQuery = (
  queryResearchOutputsContents: FetchReminderDataQuery['queryResearchOutputsContents'],
  findUsersContent: FetchReminderDataQuery['findUsersContent'],
): ResearchOutputPublishedReminder[] => {
  if (!findUsersContent || !findUsersContent.flatData.teams) {
    return [];
  }

  const userTeamIds = getUserTeamIds(findUsersContent.flatData.teams);

  if (!queryResearchOutputsContents) {
    return [];
  }

  return queryResearchOutputsContents.reduce<ResearchOutputPublishedReminder[]>(
    (researchOutputReminders, researchOutput) => {
      if (!researchOutput.flatData.teams) {
        return researchOutputReminders;
      }

      const researchOutputTeams = researchOutput.flatData.teams.map(
        (team) => team.id,
      );

      const isInTeam = researchOutputTeams.some((team) =>
        userTeamIds.includes(team),
      );

      if (
        !researchOutput.flatData.documentType ||
        !isResearchOutputDocumentType(researchOutput.flatData.documentType) ||
        !researchOutput.flatData.title
      ) {
        return researchOutputReminders;
      }

      if (isInTeam) {
        researchOutputReminders.push({
          id: `research-output-published-${researchOutput.id}`,
          entity: 'Research Output',
          type: 'Published',
          data: {
            researchOutputId: researchOutput.id,
            documentType: researchOutput.flatData.documentType,
            title: researchOutput.flatData.title,
            addedDate: researchOutput.flatData.addedDate,
          },
        });
      }

      return researchOutputReminders;
    },
    [],
  );
};

const getResearchOutputDraftRemindersFromQuery = (
  queryResearchOutputsContents: FetchReminderDataQuery['draftResearchOutputs'],
  findUsersContent: FetchReminderDataQuery['findUsersContent'],
): ResearchOutputDraftReminder[] => {
  if (!findUsersContent || !findUsersContent.flatData.teams) {
    return [];
  }

  const userTeamIds = getUserTeamIds(findUsersContent.flatData.teams);
  const userWorkingGroupIds = getUserWorkingGroupIds(
    findUsersContent.referencingWorkingGroupsContents,
  );

  const isAsapStaff = findUsersContent.flatData.role === 'Staff';

  if (!queryResearchOutputsContents) {
    return [];
  }

  return queryResearchOutputsContents.reduce<ResearchOutputDraftReminder[]>(
    (researchOutputReminders, researchOutput) => {
      const userName = getUserName(researchOutput);
      const { associationName, associationType } =
        getAssociationNameAndType(researchOutput);

      if (
        !researchOutput.flatData.teams ||
        !researchOutput.flatData.title ||
        userName === null ||
        associationName === null ||
        associationType === null
      ) {
        return researchOutputReminders;
      }

      const researchOutputTeams = researchOutput.flatData.teams.map(
        (team) => team.id,
      );
      const researchOutputWorkingGroups = (
        researchOutput.flatData.workingGroups || []
      ).map((workingGroup) => workingGroup.id);

      const isInTeam = researchOutputTeams.some((team) =>
        userTeamIds.includes(team),
      );

      const isInWorkingGroup = researchOutputWorkingGroups.some(
        (workingGroup) => userWorkingGroupIds.includes(workingGroup),
      );

      if (
        (associationType === 'team' && !isInTeam && !isAsapStaff) ||
        (associationType === 'working group' &&
          !isInWorkingGroup &&
          !isAsapStaff)
      ) {
        return researchOutputReminders;
      }

      researchOutputReminders.push({
        id: `research-output-draft-${researchOutput.id}`,
        entity: 'Research Output',
        type: 'Draft',
        data: {
          researchOutputId: researchOutput.id,
          title: researchOutput.flatData.title,
          addedDate: researchOutput.created,
          createdBy: userName,
          associationType,
          associationName,
        },
      });

      return researchOutputReminders;
    },
    [],
  );
};

const getResearchOutputInReviewRemindersFromQuery = (
  queryResearchOutputsContents: FetchReminderDataQuery['inReviewResearchOutputs'],
  findUsersContent: FetchReminderDataQuery['findUsersContent'],
  userId: string,
): ResearchOutputInReviewReminder[] => {
  if (!findUsersContent || !findUsersContent.flatData.teams) {
    return [];
  }

  const leadTeams = findUsersContent.flatData.teams.filter(({ role }) =>
    ['ASAP Staff', 'Project Manager'].includes(role || ''),
  );
  const leadTeamIds = getUserTeamIds(leadTeams);

  const userWorkingGroupIds = getUserWorkingGroupIds(
    findUsersContent.referencingWorkingGroupsContents,
  );

  const isAsapStaff = findUsersContent.flatData.role === 'Staff';

  if (!queryResearchOutputsContents) {
    return [];
  }

  return queryResearchOutputsContents.reduce<ResearchOutputInReviewReminder[]>(
    (researchOutputReminders, researchOutput) => {
      const { associationName, associationType } =
        getAssociationNameAndType(researchOutput);

      if (
        !researchOutput.flatData.teams ||
        !researchOutput.flatData.title ||
        associationName === null ||
        associationType === null ||
        !researchOutput.flatData.documentType ||
        !isResearchOutputDocumentType(researchOutput.flatData.documentType) ||
        !researchOutput.flatData.reviewRequestedBy?.[0]
      ) {
        return researchOutputReminders;
      }

      const researchOutputTeams = researchOutput.flatData.teams.map(
        (team) => team.id,
      );

      const isTeamLeader = researchOutputTeams.some((team) =>
        leadTeamIds.includes(team),
      );

      let isWorkingGroupPM = false;
      (researchOutput.flatData.workingGroups || [])
        .filter((workingGroup) => userWorkingGroupIds.includes(workingGroup.id))
        .forEach((workingGroup) => {
          const pms = workingGroup.flatData.leaders?.filter(
            (leader) => leader.role === 'Project Manager',
          );
          if (pms?.find((pm) => pm.user?.some((u) => u.id === userId))) {
            isWorkingGroupPM = true;
          }
        });

      if (
        (associationType === 'team' && !isTeamLeader && !isAsapStaff) ||
        (associationType === 'working group' &&
          !isWorkingGroupPM &&
          !isAsapStaff)
      ) {
        return researchOutputReminders;
      }

      const { firstName, lastName } =
        researchOutput.flatData.reviewRequestedBy[0].flatData;

      researchOutputReminders.push({
        id: `research-output-in-review-${researchOutput.id}`,
        entity: 'Research Output',
        type: 'In Review',
        data: {
          researchOutputId: researchOutput.id,
          title: researchOutput.flatData.title,
          addedDate: researchOutput.created,
          documentType: researchOutput.flatData.documentType,
          reviewRequestedBy: `${firstName} ${lastName}`,
          associationType,
          associationName,
        },
      });

      return researchOutputReminders;
    },
    [],
  );
};

const getEventRemindersFromQuery = (
  queryEventsContents: FetchReminderDataQuery['queryEventsContents'],
): (EventHappeningTodayReminder | EventHappeningNowReminder)[] => {
  const eventReminders = (queryEventsContents || []).reduce<
    (EventHappeningTodayReminder | EventHappeningNowReminder)[]
  >((events, event) => {
    const startDate = DateTime.fromISO(event.flatData.startDate);
    const endDate = DateTime.fromISO(event.flatData.endDate);

    const endOfToday = DateTime.now().set({ hour: 24 }).set({ minute: 59 });

    if (startDate > DateTime.local() && startDate < endOfToday) {
      return [
        ...events,
        {
          id: `event-happening-today-${event.id}`,
          entity: 'Event',
          type: 'Happening Today',
          data: {
            eventId: event.id,
            title: event.flatData.title || '',
            startDate: event.flatData.startDate,
          },
        },
      ];
    }

    if (endDate > DateTime.local() && startDate < endOfToday) {
      return [
        ...events,
        {
          id: `event-happening-now-${event.id}`,
          entity: 'Event',
          type: 'Happening Now',
          data: {
            eventId: event.id,
            title: event.flatData.title || '',
            startDate: event.flatData.startDate,
            endDate: event.flatData.endDate,
          },
        },
      ];
    }

    return events;
  }, []);

  return eventReminders;
};
const inLastNHours = (n: number, date: string) => {
  const ONE_DAY_IN_MS = n * 60 * 60 * 1000;

  const msBetweenNowAndDate = DateTime.now().diff(
    DateTime.fromISO(date),
  ).milliseconds;

  return msBetweenNowAndDate <= ONE_DAY_IN_MS && msBetweenNowAndDate > 0;
};

const inLast24Hours = (date: string) => inLastNHours(24, date);

const inLast72Hours = (date: string) => inLastNHours(72, date);

const eventHasEnded = (date: string) =>
  DateTime.fromISO(date) <= DateTime.now();

const getSharePresentationRemindersFromQuery = (
  queryEventsContents: FetchReminderDataQuery['queryEventsContents'],
  userId: string,
): SharePresentationReminder[] => {
  const eventReminders = (queryEventsContents || []).reduce<
    SharePresentationReminder[]
  >((events, event) => {
    const loggedUserSpeaker = event.flatData.speakers?.find(
      (speaker) =>
        speaker.user?.[0] &&
        'id' in speaker.user[0] &&
        speaker.user[0].id === userId,
    );
    const isLoggedUserSpeaker = !!loggedUserSpeaker;

    if (!isLoggedUserSpeaker) {
      // If user is not a speaker, we do not show share
      // presentation reminder
      return events;
    }

    const { user: speakerUserList, team: speakerTeamList } = loggedUserSpeaker;
    const speakerUser = speakerUserList?.[0];
    const speakerTeam = speakerTeamList?.[0];

    if (speakerUser && speakerTeam && 'id' in speakerUser) {
      const speakerUserTeam = speakerUser.flatData.teams?.find(
        (team) => team.id?.[0]?.id === speakerTeam?.id,
      );

      const shouldShowSharePresentation =
        !isCMSAdministrator(
          speakerUser.flatData.role as Role,
          speakerUserTeam?.role as TeamRole,
        ) && speakerUserTeam?.role !== 'Project Manager';

      if (
        shouldShowSharePresentation &&
        eventHasEnded(event.flatData.endDate) &&
        inLast72Hours(event.flatData.endDate)
      ) {
        const loggedUserSpeakerTeamId = speakerTeam.id;

        const pmFromSpeakersTeam = speakerTeam.referencingUsersContents?.find(
          (teamMember) =>
            teamMember.flatData.teams?.find(
              (team) =>
                team.id?.[0]?.id === loggedUserSpeakerTeamId &&
                team.role === 'Project Manager',
            ),
        );

        return [
          ...events,
          {
            id: `share-presentation-${event.id}`,
            entity: 'Event',
            type: 'Share Presentation',
            data: {
              pmId: pmFromSpeakersTeam?.id,
              eventId: event.id,
              title: event.flatData.title || '',
              endDate: event.flatData.endDate,
            },
          },
        ];
      }
    }
    return events;
  }, []);

  return eventReminders;
};

const getPublishMaterialRemindersFromQuery = (
  queryEventsContents: FetchReminderDataQuery['queryEventsContents'],
  findUsersContent: FetchReminderDataQuery['findUsersContent'],
): PublishMaterialReminder[] => {
  const eventReminders = (queryEventsContents || []).reduce<
    PublishMaterialReminder[]
  >((events, event) => {
    const shouldShowPublishMaterial = isCMSAdministrator(
      findUsersContent?.flatData.role as Role,
    );

    if (
      shouldShowPublishMaterial &&
      eventHasEnded(event.flatData.endDate) &&
      inLast72Hours(event.flatData.endDate)
    ) {
      return [
        ...events,
        {
          id: `publish-material-${event.id}`,
          entity: 'Event',
          type: 'Publish Material',
          data: {
            eventId: event.id,
            title: event.flatData.title || '',
            endDate: event.flatData.endDate,
          },
        },
      ];
    }
    return events;
  }, []);

  return eventReminders;
};

const getUploadPresentationRemindersFromQuery = (
  queryEventsContents: FetchReminderDataQuery['queryEventsContents'],
  findUsersContent: FetchReminderDataQuery['findUsersContent'],
): UploadPresentationReminder[] => {
  const eventReminders = (queryEventsContents || []).reduce<
    UploadPresentationReminder[]
  >((events, event) => {
    if (!isCMSAdministrator(findUsersContent?.flatData.role as Role)) {
      const userTeamRoleByTeamId = findUsersContent?.flatData?.teams?.reduce(
        (teamRoleByTeamId: { [teamId: string]: string }, team) => {
          const teamId = team.id?.[0]?.id;
          if (teamId && team.role) {
            return { ...teamRoleByTeamId, [teamId]: team.role };
          }
          return teamRoleByTeamId;
        },
        {},
      );
      const userTeamIds = Object.keys(userTeamRoleByTeamId || {});

      const shouldShowUploadPresentation = event.flatData.speakers?.some(
        (speaker) => {
          const { team: speakerTeamList } = speaker;

          const speakerTeam = speakerTeamList?.[0];

          return (
            userTeamIds &&
            speakerTeam &&
            userTeamIds?.includes(speakerTeam.id) &&
            userTeamRoleByTeamId?.[speakerTeam.id] === 'Project Manager'
          );
        },
      );

      if (
        shouldShowUploadPresentation &&
        eventHasEnded(event.flatData.endDate) &&
        inLast72Hours(event.flatData.endDate)
      ) {
        return [
          ...events,
          {
            id: `upload-presentation-${event.id}`,
            entity: 'Event',
            type: 'Upload Presentation',
            data: {
              eventId: event.id,
              title: event.flatData.title || '',
              endDate: event.flatData.endDate,
            },
          },
        ];
      }
    }
    return events;
  }, []);

  return eventReminders;
};

const getEventMaterialsRemindersFromQuery = (
  queryEventsContents: FetchReminderDataQuery['queryEventsContents'],
): (
  | VideoEventReminder
  | PresentationUpdatedReminder
  | EventNotesReminder
)[] => {
  const eventReminders = (queryEventsContents || []).reduce<
    (VideoEventReminder | PresentationUpdatedReminder | EventNotesReminder)[]
  >((events, event) => {
    const {
      id: eventId,
      flatData: {
        title,
        videoRecordingUpdatedAt,
        presentationUpdatedAt,
        notesUpdatedAt,
      },
    } = event;

    if (inLast24Hours(videoRecordingUpdatedAt)) {
      events.push({
        id: `video-event-updated-${eventId}`,
        entity: 'Event',
        type: 'Video Updated',
        data: { eventId, title: title || '', videoRecordingUpdatedAt },
      });
    }

    if (inLast24Hours(presentationUpdatedAt)) {
      events.push({
        id: `presentation-event-updated-${eventId}`,
        entity: 'Event',
        type: 'Presentation Updated',
        data: { eventId, title: title || '', presentationUpdatedAt },
      });
    }

    if (inLast24Hours(notesUpdatedAt)) {
      events.push({
        id: `notes-event-updated-${eventId}`,
        entity: 'Event',
        type: 'Notes Updated',
        data: { eventId, title: title || '', notesUpdatedAt },
      });
    }

    return events;
  }, []);

  return eventReminders;
};

const getSortDate = (reminder: ReminderDataObject): DateTime => {
  if (reminder.entity === 'Research Output') {
    return DateTime.fromISO(reminder.data.addedDate);
  }

  if (reminder.type === 'Happening Today') {
    return DateTime.fromISO(reminder.data.startDate);
  }

  if (reminder.type === 'Video Updated') {
    return DateTime.fromISO(reminder.data.videoRecordingUpdatedAt);
  }

  if (reminder.type === 'Presentation Updated') {
    return DateTime.fromISO(reminder.data.presentationUpdatedAt);
  }

  if (reminder.type === 'Notes Updated') {
    return DateTime.fromISO(reminder.data.notesUpdatedAt);
  }

  return DateTime.fromISO(reminder.data.endDate);
};

const getAssociationNameAndType = (
  researchOutput: DraftResearchOutputQueried | InReviewResearchOutputQueried,
): {
  associationType: 'team' | 'working group' | null;
  associationName: string | null;
} => {
  if (
    researchOutput.flatData?.workingGroups &&
    researchOutput.flatData.workingGroups[0]
  ) {
    return {
      associationType: 'working group',
      associationName:
        researchOutput.flatData.workingGroups[0].flatData.title || null,
    };
  }
  if (researchOutput.flatData?.teams && researchOutput.flatData.teams[0]) {
    return {
      associationType: 'team',
      associationName:
        researchOutput.flatData.teams[0].flatData.displayName || null,
    };
  }
  return {
    associationType: null,
    associationName: null,
  };
};

const getUserName = (researchOutput: DraftResearchOutputQueried) => {
  if (
    researchOutput.flatData &&
    researchOutput.flatData.createdBy &&
    researchOutput.flatData.createdBy.length > 0
  ) {
    return `${researchOutput.flatData.createdBy[0]?.flatData.firstName} ${researchOutput.flatData.createdBy[0]?.flatData.lastName}`;
  }
  return null;
};
