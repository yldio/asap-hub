import {
  FetchRemindersOptions,
  isResearchOutputDocumentType,
  ListReminderDataObject,
  ResearchOutputPublishedReminder,
} from '@asap-hub/model';
import { SquidexGraphqlClient } from '@asap-hub/squidex';
import {
  FetchUserTeamsAndResearchOutputsQuery,
  FetchUserTeamsAndResearchOutputsQueryVariables,
  Maybe,
  Teams,
} from '../autogenerated-gql/graphql';
import { FETCH_USER_TEAMS_AND_RESEARCH_OUTPUTS } from '../queries/reminders.queries';

export interface ReminderDataProvider {
  fetch: (options: FetchRemindersOptions) => Promise<ListReminderDataObject>;
}

export class ReminderSquidexDataProvider implements ReminderDataProvider {
  constructor(private squidexGraphqlClient: SquidexGraphqlClient) {
    this.squidexGraphqlClient = squidexGraphqlClient;
  }

  async fetch(options: FetchRemindersOptions): Promise<ListReminderDataObject> {
    const date = new Date();
    date.setDate(date.getDate() - 1);
    const date24hAgo = date.toISOString();

    const filter = `data/publishDate/iv ge ${date24hAgo}`;

    const { findUsersContent, queryResearchOutputsContents } =
      await this.squidexGraphqlClient.request<
        FetchUserTeamsAndResearchOutputsQuery,
        FetchUserTeamsAndResearchOutputsQueryVariables
      >(FETCH_USER_TEAMS_AND_RESEARCH_OUTPUTS, {
        filter,
        userId: options.userId,
      });

    const emptyResult = {
      total: 0,
      items: [],
    };

    if (!findUsersContent || !findUsersContent.flatData.teams) {
      return emptyResult;
    }

    const teamWithId = (team: {
      id: Maybe<Pick<Teams, 'id'>[]>;
    }): team is { id: [{ id: string }] } => !!team.id && team.id.length > 0;

    const userTeams = findUsersContent.flatData.teams
      .filter(teamWithId)
      .map((team) => team.id[0].id);

    if (!queryResearchOutputsContents) {
      return emptyResult;
    }

    const researchOutputs = queryResearchOutputsContents.reduce<
      (ResearchOutputPublishedReminder['data'] & { publishDate: string })[]
    >((prev, next) => {
      if (!next.referencingTeamsContents) {
        return prev;
      }

      const researchOutputTeams = next.referencingTeamsContents.map(
        (team) => team.id,
      );
      const isInTeam = researchOutputTeams.some((team) =>
        userTeams.includes(team),
      );

      if (
        !next.flatData.documentType ||
        !isResearchOutputDocumentType(next.flatData.documentType) ||
        !next.flatData.title
      ) {
        return prev;
      }

      if (isInTeam) {
        prev.push({
          researchOutputId: next.id,
          publishDate: next.flatData.publishDate,
          documentType: next.flatData.documentType,
          title: next.flatData.title,
        });
      }

      return prev;
    }, []);

    const researchOutputsSorted = researchOutputs.sort(
      (a, b) =>
        new Date(b.publishDate).getTime() - new Date(a.publishDate).getTime(),
    );

    return {
      total: researchOutputsSorted.length,
      items: researchOutputsSorted.map((researchOutput) => ({
        id: `research-output-published-${researchOutput.researchOutputId}`,
        entity: 'Research Output',
        type: 'Published',
        data: {
          researchOutputId: researchOutput.researchOutputId,
          documentType: researchOutput.documentType,
          title: researchOutput.title,
        },
      })),
    };
  }
}
