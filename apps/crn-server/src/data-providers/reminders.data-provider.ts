import {
  EventHappeningTodayReminder,
  FetchRemindersOptions,
  isResearchOutputDocumentType,
  ListReminderDataObject,
  ResearchOutputPublishedReminder,
} from '@asap-hub/model';
import { SquidexGraphqlClient } from '@asap-hub/squidex';
import { DateTime } from 'luxon';
import {
  FetchReminderDataQuery,
  FetchReminderDataQueryVariables,
  Maybe,
  Teams,
} from '../autogenerated-gql/graphql';
import { FETCH_REMINDER_DATA } from '../queries/reminders.queries';

export interface ReminderDataProvider {
  fetch: (options: FetchRemindersOptions) => Promise<ListReminderDataObject>;
}

export class ReminderSquidexDataProvider implements ReminderDataProvider {
  constructor(private squidexGraphqlClient: SquidexGraphqlClient) {
    this.squidexGraphqlClient = squidexGraphqlClient;
  }

  async fetch(options: FetchRemindersOptions): Promise<ListReminderDataObject> {
    const researchOutputFilter = getResearchOutputFilter();

    const {
      findUsersContent,
      queryResearchOutputsContents,
      queryEventsContents,
    } = await this.squidexGraphqlClient.request<
      FetchReminderDataQuery,
      FetchReminderDataQueryVariables
    >(FETCH_REMINDER_DATA, {
      researchOutputFilter,
      eventFilter: getEventFilter(options.timezone),
      userId: options.userId,
    });

    const researchOutputReminders = getResearchOutputRemindersFromQuery(
      queryResearchOutputsContents,
      findUsersContent,
    );
    const eventReminders = getEventRemindersFromQuery(queryEventsContents);
    const reminders = [...researchOutputReminders, ...eventReminders];

    const sortedReminders = reminders.sort((a, b) => {
      const aStartDate = DateTime.fromISO(
        a.entity === 'Research Output' ? a.data.addedDate : a.data.startDate,
      );
      const bStartDate = DateTime.fromISO(
        b.entity === 'Research Output' ? b.data.addedDate : b.data.startDate,
      );
      return bStartDate.diff(aStartDate).as('seconds');
    });

    return {
      total: sortedReminders.length,
      items: sortedReminders,
    };
  }
}

const getResearchOutputFilter = (): string => {
  const date = new Date();
  date.setDate(date.getDate() - 1);
  const date24hAgo = date.toISOString();

  const filter = `data/addedDate/iv ge ${date24hAgo}`;
  return filter;
};

export const getEventFilter = (zone: string): string => {
  const lastMidnightISO = DateTime.fromObject({
    zone,
  })
    .set({ hour: 0, minute: 0, second: 0, millisecond: 0 })
    .toUTC();

  const todayMidnightISO = DateTime.fromObject({
    zone,
  })
    .set({ hour: 0, minute: 0, second: 0, millisecond: 0 })
    .plus({ day: 1 })
    .toUTC();

  return `data/startDate/iv ge ${lastMidnightISO} and data/startDate/iv le ${todayMidnightISO}`;
};

const getUserTeamIds = (
  teams: { id: Maybe<Pick<Teams, 'id'>[]> }[],
): string[] => {
  const teamWithId = (team: {
    id: Maybe<Pick<Teams, 'id'>[]>;
  }): team is { id: [{ id: string }] } => !!team.id && team.id.length > 0;

  const userTeams = teams.filter(teamWithId).map((team) => team.id[0].id);
  return userTeams;
};

const getResearchOutputRemindersFromQuery = (
  queryResearchOutputsContents: FetchReminderDataQuery['queryResearchOutputsContents'],
  findUsersContent: FetchReminderDataQuery['findUsersContent'],
): ResearchOutputPublishedReminder[] => {
  if (!findUsersContent || !findUsersContent.flatData.teams) {
    return [];
  }

  const userTeamIds = getUserTeamIds(findUsersContent.flatData.teams);

  if (!queryResearchOutputsContents) {
    return [];
  }

  return queryResearchOutputsContents.reduce<ResearchOutputPublishedReminder[]>(
    (researchOutputReminders, researchOutput) => {
      if (!researchOutput.referencingTeamsContents) {
        return researchOutputReminders;
      }

      const researchOutputTeams = researchOutput.referencingTeamsContents.map(
        (team) => team.id,
      );

      const isInTeam = researchOutputTeams.some((team) =>
        userTeamIds.includes(team),
      );

      if (
        !researchOutput.flatData.documentType ||
        !isResearchOutputDocumentType(researchOutput.flatData.documentType) ||
        !researchOutput.flatData.title
      ) {
        return researchOutputReminders;
      }

      if (isInTeam) {
        researchOutputReminders.push({
          id: `research-output-published-${researchOutput.id}`,
          entity: 'Research Output',
          type: 'Published',
          data: {
            researchOutputId: researchOutput.id,
            documentType: researchOutput.flatData.documentType,
            title: researchOutput.flatData.title,
            addedDate: researchOutput.flatData.addedDate,
          },
        });
      }

      return researchOutputReminders;
    },
    [],
  );
};

const getEventRemindersFromQuery = (
  queryEventsContents: FetchReminderDataQuery['queryEventsContents'],
): EventHappeningTodayReminder[] => {
  const eventReminders = (
    queryEventsContents || []
  ).map<EventHappeningTodayReminder>((event) => ({
    id: `event-happening-today-${event.id}`,
    entity: 'Event',
    type: 'Happening Today',
    data: {
      eventId: event.id,
      title: event.flatData.title || '',
      startDate: event.flatData.startDate,
    },
  }));

  // remove event reminders that have already started
  const filteredEventReminders = eventReminders.filter((event) => {
    const startDate = DateTime.fromISO(event.data.startDate);
    return startDate > DateTime.local();
  });
  return filteredEventReminders;
};
