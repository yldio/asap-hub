import {
  VideoEventReminder,
  EventHappeningNowReminder,
  EventHappeningTodayReminder,
  FetchRemindersOptions,
  isResearchOutputDocumentType,
  ListReminderDataObject,
  ReminderDataObject,
  ResearchOutputPublishedReminder,
  PresentationUpdatedReminder,
  EventNotesReminder,
  SharePresentationReminder,
  Role,
  TeamRole,
  PublishMaterialReminder,
  UploadPresentationReminder,
  DataProvider,
} from '@asap-hub/model';
import { SquidexGraphqlClient } from '@asap-hub/squidex';
import { isCMSAdministrator } from '@asap-hub/validation';
import { DateTime } from 'luxon';
import {
  FetchReminderDataQuery,
  FetchReminderDataQueryVariables,
  Maybe,
  Teams,
} from '../autogenerated-gql/graphql';
import { FETCH_REMINDER_DATA } from '../queries/reminders.queries';

export type ReminderDataProvider = DataProvider<
  ReminderDataObject,
  FetchRemindersOptions
>;

export class ReminderSquidexDataProvider implements ReminderDataProvider {
  constructor(private squidexGraphqlClient: SquidexGraphqlClient) {
    this.squidexGraphqlClient = squidexGraphqlClient;
  }

  async fetchById(): Promise<null> {
    throw new Error('Method not implemented.');
  }

  async fetch(options: FetchRemindersOptions): Promise<ListReminderDataObject> {
    const researchOutputFilter = getResearchOutputFilter();

    const {
      findUsersContent,
      queryResearchOutputsContents,
      queryEventsContents,
    } = await this.squidexGraphqlClient.request<
      FetchReminderDataQuery,
      FetchReminderDataQueryVariables
    >(FETCH_REMINDER_DATA, {
      researchOutputFilter,
      eventFilter: getEventFilter(options.timezone),
      userId: options.userId,
    });

    const researchOutputReminders = getResearchOutputRemindersFromQuery(
      queryResearchOutputsContents,
      findUsersContent,
    );

    const eventReminders = getEventRemindersFromQuery(queryEventsContents);

    const sharePresentationReminders = getSharePresentationRemindersFromQuery(
      queryEventsContents,
      options.userId,
    );

    const publishPresentationReminders = getPublishMaterialRemindersFromQuery(
      queryEventsContents,
      findUsersContent,
    );

    const uploadPresentationReminders = getUploadPresentationRemindersFromQuery(
      queryEventsContents,
      findUsersContent,
    );

    const eventMaterialsReminders =
      getEventMaterialsRemindersFromQuery(queryEventsContents);

    const reminders = [
      ...researchOutputReminders,
      ...eventReminders,
      ...sharePresentationReminders,
      ...eventMaterialsReminders,
      ...publishPresentationReminders,
      ...uploadPresentationReminders,
    ];

    const sortedReminders = reminders.sort((reminderA, reminderB) => {
      const aStartDate = getSortDate(reminderA);
      const bStartDate = getSortDate(reminderB);

      return bStartDate.diff(aStartDate).as('seconds');
    });

    return {
      total: sortedReminders.length,
      items: sortedReminders,
    };
  }
}

const getResearchOutputFilter = (): string => {
  const date = new Date();
  date.setDate(date.getDate() - 1);
  const date24hAgo = date.toISOString();

  const filter = `data/addedDate/iv ge ${date24hAgo}`;
  return filter;
};

export const getEventFilter = (zone: string): string => {
  const lastMidnightISO = DateTime.fromObject({
    zone,
  })
    .set({ hour: 0, minute: 0, second: 0, millisecond: 0 })
    .toUTC();

  const todayMidnightISO = DateTime.fromObject({
    zone,
  })
    .set({ hour: 0, minute: 0, second: 0, millisecond: 0 })
    .plus({ day: 1 })
    .toUTC();

  const lastDayISO = DateTime.fromObject({
    zone,
  })
    .minus({ day: 1 })
    .toUTC();

  const last72HoursISO = DateTime.fromObject({
    zone,
  })
    .minus({ hours: 72 })
    .toUTC();

  const now = DateTime.fromObject({
    zone,
  }).toUTC();

  return `data/videoRecordingUpdatedAt/iv ge ${lastDayISO} or data/presentationUpdatedAt/iv ge ${lastDayISO} or data/notesUpdatedAt/iv ge ${lastDayISO} or (data/startDate/iv ge ${lastMidnightISO} and data/startDate/iv le ${todayMidnightISO}) or (data/endDate/iv ge ${last72HoursISO} and data/endDate/iv le ${now})`;
};

const getUserTeamIds = (
  teams: { id: Maybe<Pick<Teams, 'id'>[]> }[],
): string[] => {
  const teamWithId = (team: {
    id: Maybe<Pick<Teams, 'id'>[]>;
  }): team is { id: [{ id: string }] } => !!team.id && team.id.length > 0;

  const userTeams = teams.filter(teamWithId).map((team) => team.id[0].id);
  return userTeams;
};

const getResearchOutputRemindersFromQuery = (
  queryResearchOutputsContents: FetchReminderDataQuery['queryResearchOutputsContents'],
  findUsersContent: FetchReminderDataQuery['findUsersContent'],
): ResearchOutputPublishedReminder[] => {
  if (!findUsersContent || !findUsersContent.flatData.teams) {
    return [];
  }

  const userTeamIds = getUserTeamIds(findUsersContent.flatData.teams);

  if (!queryResearchOutputsContents) {
    return [];
  }

  return queryResearchOutputsContents.reduce<ResearchOutputPublishedReminder[]>(
    (researchOutputReminders, researchOutput) => {
      if (!researchOutput.flatData.teams) {
        return researchOutputReminders;
      }

      const researchOutputTeams = researchOutput.flatData.teams.map(
        (team) => team.id,
      );

      const isInTeam = researchOutputTeams.some((team) =>
        userTeamIds.includes(team),
      );

      if (
        !researchOutput.flatData.documentType ||
        !isResearchOutputDocumentType(researchOutput.flatData.documentType) ||
        !researchOutput.flatData.title
      ) {
        return researchOutputReminders;
      }

      if (isInTeam) {
        researchOutputReminders.push({
          id: `research-output-published-${researchOutput.id}`,
          entity: 'Research Output',
          type: 'Published',
          data: {
            researchOutputId: researchOutput.id,
            documentType: researchOutput.flatData.documentType,
            title: researchOutput.flatData.title,
            addedDate: researchOutput.flatData.addedDate,
          },
        });
      }

      return researchOutputReminders;
    },
    [],
  );
};

const getEventRemindersFromQuery = (
  queryEventsContents: FetchReminderDataQuery['queryEventsContents'],
): (EventHappeningTodayReminder | EventHappeningNowReminder)[] => {
  const eventReminders = (queryEventsContents || []).reduce<
    (EventHappeningTodayReminder | EventHappeningNowReminder)[]
  >((events, event) => {
    const startDate = DateTime.fromISO(event.flatData.startDate);
    const endDate = DateTime.fromISO(event.flatData.endDate);

    const endOfToday = DateTime.now().set({ hour: 24 }).set({ minute: 59 });

    if (startDate > DateTime.local() && startDate < endOfToday) {
      return [
        ...events,
        {
          id: `event-happening-today-${event.id}`,
          entity: 'Event',
          type: 'Happening Today',
          data: {
            eventId: event.id,
            title: event.flatData.title || '',
            startDate: event.flatData.startDate,
          },
        },
      ];
    }

    if (endDate > DateTime.local() && startDate < endOfToday) {
      return [
        ...events,
        {
          id: `event-happening-now-${event.id}`,
          entity: 'Event',
          type: 'Happening Now',
          data: {
            eventId: event.id,
            title: event.flatData.title || '',
            startDate: event.flatData.startDate,
            endDate: event.flatData.endDate,
          },
        },
      ];
    }

    return events;
  }, []);

  return eventReminders;
};
const inLastNHours = (n: number, date: string) => {
  const ONE_DAY_IN_MS = n * 60 * 60 * 1000;

  const msBetweenNowAndDate = DateTime.now().diff(
    DateTime.fromISO(date),
  ).milliseconds;

  return msBetweenNowAndDate <= ONE_DAY_IN_MS && msBetweenNowAndDate > 0;
};

const inLast24Hours = (date: string) => inLastNHours(24, date);

const inLast72Hours = (date: string) => inLastNHours(72, date);

const eventHasEnded = (date: string) =>
  DateTime.fromISO(date) <= DateTime.now();

const getSharePresentationRemindersFromQuery = (
  queryEventsContents: FetchReminderDataQuery['queryEventsContents'],
  userId: string,
): SharePresentationReminder[] => {
  const eventReminders = (queryEventsContents || []).reduce<
    SharePresentationReminder[]
  >((events, event) => {
    const loggedUserSpeaker = event.flatData.speakers?.find(
      (speaker) =>
        speaker.user?.[0] &&
        'id' in speaker.user[0] &&
        speaker.user[0].id === userId,
    );
    const isLoggedUserSpeaker = !!loggedUserSpeaker;

    if (!isLoggedUserSpeaker) {
      // If user is not a speaker, we do not show share
      // presentation reminder
      return events;
    }

    const { user: speakerUserList, team: speakerTeamList } = loggedUserSpeaker;
    const speakerUser = speakerUserList?.[0];
    const speakerTeam = speakerTeamList?.[0];

    if (speakerUser && speakerTeam && 'id' in speakerUser) {
      const speakerUserTeam = speakerUser.flatData.teams?.find(
        (team) => team.id?.[0]?.id === speakerTeam?.id,
      );

      const shouldShowSharePresentation =
        !isCMSAdministrator(
          speakerUser.flatData.role as Role,
          speakerUserTeam?.role as TeamRole,
        ) && speakerUserTeam?.role !== 'Project Manager';

      if (
        shouldShowSharePresentation &&
        eventHasEnded(event.flatData.endDate) &&
        inLast72Hours(event.flatData.endDate)
      ) {
        const loggedUserSpeakerTeamId = speakerTeam.id;

        const pmFromSpeakersTeam = speakerTeam.referencingUsersContents?.find(
          (teamMember) =>
            teamMember.flatData.teams?.find(
              (team) =>
                team.id?.[0]?.id === loggedUserSpeakerTeamId &&
                team.role === 'Project Manager',
            ),
        );

        return [
          ...events,
          {
            id: `share-presentation-${event.id}`,
            entity: 'Event',
            type: 'Share Presentation',
            data: {
              pmId: pmFromSpeakersTeam?.id,
              eventId: event.id,
              title: event.flatData.title || '',
              endDate: event.flatData.endDate,
            },
          },
        ];
      }
    }
    return events;
  }, []);

  return eventReminders;
};

const getPublishMaterialRemindersFromQuery = (
  queryEventsContents: FetchReminderDataQuery['queryEventsContents'],
  findUsersContent: FetchReminderDataQuery['findUsersContent'],
): PublishMaterialReminder[] => {
  const eventReminders = (queryEventsContents || []).reduce<
    PublishMaterialReminder[]
  >((events, event) => {
    const shouldShowPublishMaterial = isCMSAdministrator(
      findUsersContent?.flatData.role as Role,
    );

    if (
      shouldShowPublishMaterial &&
      eventHasEnded(event.flatData.endDate) &&
      inLast72Hours(event.flatData.endDate)
    ) {
      return [
        ...events,
        {
          id: `publish-material-${event.id}`,
          entity: 'Event',
          type: 'Publish Material',
          data: {
            eventId: event.id,
            title: event.flatData.title || '',
            endDate: event.flatData.endDate,
          },
        },
      ];
    }
    return events;
  }, []);

  return eventReminders;
};

const getUploadPresentationRemindersFromQuery = (
  queryEventsContents: FetchReminderDataQuery['queryEventsContents'],
  findUsersContent: FetchReminderDataQuery['findUsersContent'],
): UploadPresentationReminder[] => {
  const eventReminders = (queryEventsContents || []).reduce<
    UploadPresentationReminder[]
  >((events, event) => {
    if (!isCMSAdministrator(findUsersContent?.flatData.role as Role)) {
      const userTeamRoleByTeamId = findUsersContent?.flatData?.teams?.reduce(
        (teamRoleByTeamId: { [teamId: string]: string }, team) => {
          const teamId = team.id?.[0]?.id;
          if (teamId && team.role) {
            return { ...teamRoleByTeamId, [teamId]: team.role };
          }
          return teamRoleByTeamId;
        },
        {},
      );
      const userTeamIds = Object.keys(userTeamRoleByTeamId || {});

      const shouldShowUploadPresentation = event.flatData.speakers?.some(
        (speaker) => {
          const { team: speakerTeamList } = speaker;

          const speakerTeam = speakerTeamList?.[0];

          return (
            userTeamIds &&
            speakerTeam &&
            userTeamIds?.includes(speakerTeam.id) &&
            userTeamRoleByTeamId?.[speakerTeam.id] === 'Project Manager'
          );
        },
      );

      if (
        shouldShowUploadPresentation &&
        eventHasEnded(event.flatData.endDate) &&
        inLast72Hours(event.flatData.endDate)
      ) {
        return [
          ...events,
          {
            id: `upload-presentation-${event.id}`,
            entity: 'Event',
            type: 'Upload Presentation',
            data: {
              eventId: event.id,
              title: event.flatData.title || '',
              endDate: event.flatData.endDate,
            },
          },
        ];
      }
    }
    return events;
  }, []);

  return eventReminders;
};

const getEventMaterialsRemindersFromQuery = (
  queryEventsContents: FetchReminderDataQuery['queryEventsContents'],
): (
  | VideoEventReminder
  | PresentationUpdatedReminder
  | EventNotesReminder
)[] => {
  const eventReminders = (queryEventsContents || []).reduce<
    (VideoEventReminder | PresentationUpdatedReminder | EventNotesReminder)[]
  >((events, event) => {
    const {
      id: eventId,
      flatData: {
        title,
        videoRecordingUpdatedAt,
        presentationUpdatedAt,
        notesUpdatedAt,
      },
    } = event;

    if (inLast24Hours(videoRecordingUpdatedAt)) {
      events.push({
        id: `video-event-updated-${eventId}`,
        entity: 'Event',
        type: 'Video Updated',
        data: { eventId, title: title || '', videoRecordingUpdatedAt },
      });
    }

    if (inLast24Hours(presentationUpdatedAt)) {
      events.push({
        id: `presentation-event-updated-${eventId}`,
        entity: 'Event',
        type: 'Presentation Updated',
        data: { eventId, title: title || '', presentationUpdatedAt },
      });
    }

    if (inLast24Hours(notesUpdatedAt)) {
      events.push({
        id: `notes-event-updated-${eventId}`,
        entity: 'Event',
        type: 'Notes Updated',
        data: { eventId, title: title || '', notesUpdatedAt },
      });
    }

    return events;
  }, []);

  return eventReminders;
};

const getSortDate = (reminder: ReminderDataObject): DateTime => {
  if (reminder.entity === 'Research Output') {
    return DateTime.fromISO(reminder.data.addedDate || '');
  }

  if (reminder.type === 'Happening Today') {
    return DateTime.fromISO(reminder.data.startDate);
  }

  if (reminder.type === 'Video Updated') {
    return DateTime.fromISO(reminder.data.videoRecordingUpdatedAt);
  }

  if (reminder.type === 'Presentation Updated') {
    return DateTime.fromISO(reminder.data.presentationUpdatedAt);
  }

  if (reminder.type === 'Notes Updated') {
    return DateTime.fromISO(reminder.data.notesUpdatedAt);
  }

  return DateTime.fromISO(reminder.data.endDate);
};
