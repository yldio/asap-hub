import {
  AuthorUpsertDataObject,
  convertBooleanToDecision,
  ListResearchOutputDataObject,
  ResearchOutputCreateDataObject,
  ResearchOutputDataObject,
  ResearchOutputUpdateDataObject,
} from '@asap-hub/model';
import {
  InputResearchOutput,
  parseToSquidex,
  RestResearchOutput,
  SquidexGraphqlClient,
  SquidexRestClient,
} from '@asap-hub/squidex';
import { Filter } from 'odata-query';
import {
  FetchResearchOutputQuery,
  FetchResearchOutputQueryVariables,
  FetchResearchOutputsQuery,
  FetchResearchOutputsQueryVariables,
  FetchResearchTagsQuery,
  FetchResearchTagsQueryVariables,
} from '../autogenerated-gql/graphql';
import {
  FETCH_RESEARCH_OUTPUT,
  FETCH_RESEARCH_OUTPUTS,
} from '../queries/research-outputs.queries';
import { parseGraphQLResearchOutput } from './transformers';
import logger from '../utils/logger';
import { buildODataFilter, ResearchOutputFilter } from '../utils/odata';
import { FETCH_RESEARCH_TAGS } from '../queries/research-tags.queries';
import {
  FetchResearchOutputFilter,
  FetchResearchOutputOptions,
  ResearchOutputDataProvider,
} from './types';

export const makeODataFilter = (
  filter?: ResearchOutputFilter,
): Filter | null => {
  if (!filter) {
    return null;
  }

  const entries = Object.entries(filter).reduce<Filter[]>((res, [key, val]) => {
    if (Array.isArray(val)) {
      return res.concat({
        or: val.map((valElement) => ({
          [`data/${key}/iv`]: valElement,
        })),
      });
    }

    return res.concat({ [`data/${key}/iv`]: val });
  }, []);

  return entries.length === 1 ? (entries[0] as Filter) : entries;
};

export const makeDraftFilter = ({
  teamId,
  workingGroupId,
}: FetchResearchOutputFilter) => {
  const query = [`status eq 'Draft'`];

  if (teamId) {
    query.push(`data/teams/iv in ['${teamId}']`);
  }

  if (workingGroupId) {
    query.push(`data/workingGroups/iv in ['${workingGroupId}']`);
  }

  return query.join(' and ');
};

export class ResearchOutputSquidexDataProvider
  implements ResearchOutputDataProvider
{
  constructor(
    private squidexGraphqlClient: SquidexGraphqlClient,
    private researchOutputSquidexRestClient: SquidexRestClient<
      RestResearchOutput,
      InputResearchOutput
    >,
  ) {}
  async fetchById(id: string): Promise<ResearchOutputDataObject | null> {
    const researchOutputGraphqlResponse =
      await this.squidexGraphqlClient.request<
        FetchResearchOutputQuery,
        FetchResearchOutputQueryVariables
      >(
        FETCH_RESEARCH_OUTPUT,
        { id, withTeams: true },
        { includeDrafts: true },
      );

    const { findResearchOutputsContent: researchOutputContent } =
      researchOutputGraphqlResponse;

    if (!researchOutputContent) {
      return null;
    }

    return parseGraphQLResearchOutput(researchOutputContent);
  }

  async fetch(
    options: FetchResearchOutputOptions,
  ): Promise<ListResearchOutputDataObject> {
    const { search, filter, take = 8, skip = 0, includeDrafts } = options;

    const searchTerms = (search || '').split(' ').filter(Boolean);

    const containsFilters = searchTerms.reduce<Filter[]>(
      (res, word: string) => [
        ...res,
        {
          [`data/title/iv`]: {
            contains: word,
          },
        },
      ],
      [],
    );

    const keywordIds = await getkeywordIds(
      searchTerms,
      this.squidexGraphqlClient,
    );

    if (keywordIds.length) {
      containsFilters.push({
        'data/keywords/iv': {
          in: keywordIds,
        },
      });
    }

    const searchQ = containsFilters.length
      ? containsFilters.length === 1
        ? containsFilters[0]
        : { or: containsFilters }
      : null;
    const filterQ =
      filter?.status === 'draft'
        ? makeDraftFilter(filter)
        : makeODataFilter(filter);
    const filtersAndSearch = [filterQ, searchQ].filter(Boolean);
    const query =
      filtersAndSearch.length === 1 ? filtersAndSearch[0] : filtersAndSearch;
    const filterGraphql = buildODataFilter(query as Filter);

    const { queryResearchOutputsContentsWithTotal } =
      await this.squidexGraphqlClient.request<
        FetchResearchOutputsQuery,
        FetchResearchOutputsQueryVariables
      >(
        FETCH_RESEARCH_OUTPUTS,
        {
          top: take,
          skip,
          filter: filterGraphql,
          withTeams: true,
        },
        {
          includeDrafts,
        },
      );

    if (queryResearchOutputsContentsWithTotal === null) {
      logger.warn('queryResearchOutputsContentsWithTotal returned null');
      return {
        total: 0,
        items: [],
      };
    }

    const { total, items: researchOutputs } =
      queryResearchOutputsContentsWithTotal;

    if (researchOutputs === null) {
      logger.warn('queryResearchOutputsContentsWithTotal items returned null');
      return {
        total: 0,
        items: [],
      };
    }

    return {
      total,
      items: researchOutputs.map((item) => parseGraphQLResearchOutput(item)),
    };
  }

  async create(
    input: ResearchOutputCreateDataObject,
    createOptions = { publish: true },
  ): Promise<string> {
    const {
      authors,
      teamIds,
      relatedResearchIds,
      relatedEventIds,
      labIds,
      methodIds,
      environmentIds,
      organismIds,
      subtypeId,
      keywordIds,
      workingGroups,
      ...researchOutputData
    } = input;

    const { usedInPublication, ...researchOutput } = parseToSquidex({
      ...researchOutputData,
      description: researchOutputData.description,
      descriptionMD: researchOutputData.descriptionMD,
      asapFunded: convertBooleanToDecision(researchOutputData.asapFunded),
      usedInPublication: convertBooleanToDecision(
        researchOutputData.usedInPublication,
      ),
      authors: authors.map(getAuthorIdList),
      createdBy: [researchOutputData.createdBy],
      updatedBy: [researchOutputData.createdBy],
      labs: labIds,
      teams: teamIds,
      relatedResearch: relatedResearchIds,
      relatedEvents: relatedEventIds,
      methods: methodIds,
      keywords: keywordIds,
      environments: environmentIds,
      organisms: organismIds,
      workingGroups,
      subtype: (subtypeId && [subtypeId]) || [],
    });

    const { id: researchOutputId } =
      await this.researchOutputSquidexRestClient.create(
        {
          doi: { iv: null },
          accession: { iv: null },
          rrid: { iv: null },
          ...researchOutput,
          usedInAPublication: usedInPublication,
        },
        createOptions.publish,
      );

    return researchOutputId;
  }

  async update(
    researchOutputId: string,
    input: ResearchOutputUpdateDataObject,
    updateOptions = { publish: false },
  ): Promise<void> {
    const {
      authors,
      teamIds: _teamIds,
      statusChangedById,
      labIds,
      relatedResearchIds,
      methodIds,
      environmentIds,
      organismIds,
      subtypeId,
      keywordIds,
      relatedEventIds,
      ...researchOutputData
    } = input;
    const {
      usedInPublication,
      versions: _, // unsupported in squidex
      ...researchOutput
    } = parseToSquidex({
      ...researchOutputData,
      asapFunded: convertBooleanToDecision(researchOutputData.asapFunded),
      usedInPublication: convertBooleanToDecision(
        researchOutputData.usedInPublication,
      ),
      authors: authors.map(getAuthorIdList),
      labs: labIds,
      teams: _teamIds,
      methods: methodIds,
      relatedResearch: relatedResearchIds,
      relatedEvents: relatedEventIds,
      environments: environmentIds,
      organisms: organismIds,
      subtype: (subtypeId && [subtypeId]) || [],
      keywords: keywordIds,
      updatedBy: [researchOutputData.updatedBy],
      statusChangedBy: statusChangedById ? [statusChangedById] : [],
    });

    await this.researchOutputSquidexRestClient.patch(researchOutputId, {
      doi: { iv: null },
      accession: { iv: null },
      rrid: { iv: null },
      ...researchOutput,
      usedInAPublication: usedInPublication,
      labs: researchOutput.labs,
      teams: researchOutput.teams,
    });

    if (updateOptions.publish) {
      await this.researchOutputSquidexRestClient.publish(researchOutputId);
    }
  }
}

const getAuthorIdList = (authorDataObject: AuthorUpsertDataObject) => {
  if ('userId' in authorDataObject) {
    return authorDataObject.userId;
  }

  return authorDataObject.externalAuthorId;
};

const getkeywordIds = async (
  searchTerms: string[],
  squidexGraphqlClient: SquidexGraphqlClient,
) => {
  if (!searchTerms.length) {
    return [];
  }

  const keywordFilters = searchTerms.reduce<Filter[]>(
    (res, word: string) => [
      ...res,
      {
        [`data/name/iv`]: {
          contains: word,
        },
      },
    ],
    [],
  );

  const keywordQ =
    keywordFilters.length === 1 ? keywordFilters[0] : { or: keywordFilters };

  const filter = buildODataFilter(keywordQ as Filter);

  const { queryResearchTagsContentsWithTotal } =
    await squidexGraphqlClient.request<
      FetchResearchTagsQuery,
      FetchResearchTagsQueryVariables
    >(FETCH_RESEARCH_TAGS, {
      top: 200,
      skip: 0,
      filter,
    });

  if (queryResearchTagsContentsWithTotal === null) {
    return [];
  }

  const { items } = queryResearchTagsContentsWithTotal;

  return (items || []).map((i) => i.id);
};
