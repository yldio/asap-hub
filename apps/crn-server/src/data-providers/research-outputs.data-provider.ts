import {
  AuthorUpsertDataObject,
  convertBooleanToDecision,
  FetchOptions,
  ListResearchOutputDataObject,
  ResearchOutputCreateDataObject,
  ResearchOutputDataObject,
  ResearchOutputUpdateDataObject,
} from '@asap-hub/model';
import {
  InputResearchOutput,
  parseToSquidex,
  RestResearchOutput,
  RestTeam,
  sanitiseForSquidex,
  SquidexGraphqlClient,
  SquidexRestClient,
} from '@asap-hub/squidex';
import Boom from '@hapi/boom';
import {
  FetchResearchOutputQuery,
  FetchResearchOutputQueryVariables,
  FetchResearchOutputsQuery,
  FetchResearchOutputsQueryVariables,
} from '../autogenerated-gql/graphql';
import {
  FETCH_RESEARCH_OUTPUT,
  FETCH_RESEARCH_OUTPUTS,
} from '../queries/research-outputs.queries';
import { parseGraphQLResearchOutput } from '../entities/research-output';
import logger from '../utils/logger';

export interface ResearchOutputDataProvider {
  fetchById(id: string): Promise<ResearchOutputDataObject | null>;
  fetch(
    options: FetchResearchOutputOptions,
  ): Promise<ListResearchOutputDataObject>;
  create(input: ResearchOutputCreateDataObject): Promise<string>;
  update(id: string, input: ResearchOutputUpdateDataObject): Promise<string>;
}

export class ResearchOutputSquidexDataProvider
  implements ResearchOutputDataProvider
{
  constructor(
    private squidexGraphqlClient: SquidexGraphqlClient,
    private researchOutputSquidexRestClient: SquidexRestClient<
      RestResearchOutput,
      InputResearchOutput
    >,
    private teamSquidexRestClient: SquidexRestClient<RestTeam>,
  ) {}
  async fetchById(id: string): Promise<ResearchOutputDataObject | null> {
    const researchOutputGraphqlResponse =
      await this.squidexGraphqlClient.request<
        FetchResearchOutputQuery,
        FetchResearchOutputQueryVariables
      >(FETCH_RESEARCH_OUTPUT, { id, withTeams: true });

    const { findResearchOutputsContent: researchOutputContent } =
      researchOutputGraphqlResponse;

    if (!researchOutputContent) {
      throw Boom.notFound();
    }

    return parseGraphQLResearchOutput(researchOutputContent);
  }

  async fetch(options: {
    take?: number;
    skip?: number;
    search?: string;
    filter?: ResearchOutputFilter;
    includeDrafts?: boolean;
  }): Promise<ListResearchOutputDataObject> {
    const { search, filter, take = 8, skip = 0, includeDrafts } = options;

    const searchQ = (search || '')
      .split(' ')
      .filter(Boolean)
      .map(sanitiseForSquidex)
      .reduce(
        (acc: string[], word: string) =>
          acc.concat(
            `contains(data/title/iv, '${word}') or contains(data/tags/iv, '${word}')`,
          ),
        [],
      )
      .join(' or ');

    const filterQ = makeODataFilter(filter);

    const filterGraphql = [filterQ && `(${filterQ})`, searchQ && `(${searchQ})`]
      .filter(Boolean)
      .join(' and ');

    const { queryResearchOutputsContentsWithTotal } =
      await this.squidexGraphqlClient.request<
        FetchResearchOutputsQuery,
        FetchResearchOutputsQueryVariables
      >(
        FETCH_RESEARCH_OUTPUTS,
        {
          top: take,
          skip,
          filter: filterGraphql,
          withTeams: true,
        },
        {
          includeDrafts,
        },
      );

    if (queryResearchOutputsContentsWithTotal === null) {
      logger.warn('queryResearchOutputsContentsWithTotal returned null');
      return {
        total: 0,
        items: [],
      };
    }

    const { total, items: researchOutputs } =
      queryResearchOutputsContentsWithTotal;

    if (researchOutputs === null) {
      logger.warn('queryResearchOutputsContentsWithTotal items returned null');
      return {
        total: 0,
        items: [],
      };
    }

    return {
      total,
      items: researchOutputs.map((item) => parseGraphQLResearchOutput(item)),
    };
  }

  async create(input: ResearchOutputCreateDataObject): Promise<string> {
    const {
      authors,
      teamIds,
      labIds,
      methodIds,
      environmentIds,
      organismIds,
      subtypeId,
      ...researchOutputData
    } = input;
    const { usedInPublication, ...researchOutput } = parseToSquidex({
      ...researchOutputData,
      asapFunded: convertBooleanToDecision(researchOutputData.asapFunded),
      usedInPublication: convertBooleanToDecision(
        researchOutputData.usedInPublication,
      ),
      authors: authors.map(getAuthorIdList),
      createdBy: [researchOutputData.createdBy],
      updatedBy: [researchOutputData.createdBy],
      labs: labIds,
      methods: methodIds,
      environments: environmentIds,
      organisms: organismIds,
      subtype: (subtypeId && [subtypeId]) || [],
    });

    const { id: researchOutputId } =
      await this.researchOutputSquidexRestClient.create({
        doi: { iv: null },
        accession: { iv: null },
        rrid: { iv: null },
        ...researchOutput,
        usedInAPublication: usedInPublication,
      });

    await Promise.all(
      teamIds.map((teamId) =>
        this.associateResearchOutputToTeam(teamId, researchOutputId),
      ),
    );

    return researchOutputId;
  }

  async update(
    researchOutputId: string,
    input: ResearchOutputUpdateDataObject,
  ): Promise<string> {
    const {
      authors,
      teamIds: _teamIds,
      labIds,
      methodIds,
      environmentIds,
      organismIds,
      subtypeId,
      ...researchOutputData
    } = input;
    const { usedInPublication, ...researchOutput } = parseToSquidex({
      ...researchOutputData,
      asapFunded: convertBooleanToDecision(researchOutputData.asapFunded),
      usedInPublication: convertBooleanToDecision(
        researchOutputData.usedInPublication,
      ),
      authors: authors.map(getAuthorIdList),
      labs: labIds,
      methods: methodIds,
      environments: environmentIds,
      organisms: organismIds,
      subtype: (subtypeId && [subtypeId]) || [],
      updatedBy: [researchOutputData.updatedBy],
    });

    await this.researchOutputSquidexRestClient.patch(researchOutputId, {
      doi: { iv: null },
      accession: { iv: null },
      rrid: { iv: null },
      ...researchOutput,
      usedInAPublication: usedInPublication,
      labs: researchOutput.labs || { iv: null },
    });

    return researchOutputId;
  }

  private async associateResearchOutputToTeam(
    teamId: string,
    researchOutputId: string,
  ) {
    const { data } = await this.teamSquidexRestClient.fetchById(teamId, false);
    const existingOutputs = data.outputs?.iv || [];
    await this.teamSquidexRestClient.patch(teamId, {
      outputs: {
        iv: [...existingOutputs, researchOutputId],
      },
    });
  }
}

type ResearchOutputFilter = {
  documentType?: string | string[];
  title?: string;
  link?: string;
};

export type FetchResearchOutputOptions = FetchOptions<ResearchOutputFilter> & {
  includeDrafts?: boolean;
};

const makeODataFilter = (filter?: ResearchOutputFilter): string => {
  if (filter) {
    return Object.entries(filter)
      .map(([key, val]) => {
        if (Array.isArray(val)) {
          return `(${val
            .map(
              (valElement) =>
                `data/${key}/iv eq '${sanitiseForSquidex(valElement)}'`,
            )
            .join(' or ')})`;
        }
        return `data/${key}/iv eq '${sanitiseForSquidex(val)}'`;
      })
      .join(' and ');
  }

  return '';
};

const getAuthorIdList = (authorDataObject: AuthorUpsertDataObject) => {
  if ('userId' in authorDataObject) {
    return authorDataObject.userId;
  }

  return authorDataObject.externalAuthorId;
};
