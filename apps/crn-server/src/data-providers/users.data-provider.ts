import {
  FetchUsersOptions,
  LabResponse,
  ListUserDataObject,
  OrcidWork,
  OrcidWorkType,
  orcidWorkType,
  Role,
  UserCreateDataObject,
  UserDataObject,
  UserDegree,
  crnUserDegrees,
  UserResponse,
  crnUserRoles,
  UserTeam,
  UserUpdateDataObject,
} from '@asap-hub/model';
import {
  InputUser,
  parseDate,
  RestUser,
  SquidexGraphqlClient,
  SquidexRestClient,
} from '@asap-hub/squidex';
import { Filter } from 'odata-query';
import {
  FetchUserQuery,
  FetchUserQueryVariables,
  FetchUsersQuery,
  FetchUsersQueryVariables,
  UsersContentFragment,
} from '../autogenerated-gql/graphql';
import { isTeamRole } from '../entities';
import { FETCH_USER, FETCH_USERS } from '../queries/users.queries';
import logger from '../utils/logger';
import { createUrl } from '../utils/urls';
import { buildEqFilterForWords, buildODataFilter } from '../utils/odata';

export type CMSOrcidWork = OrcidWork;

export interface UserDataProvider {
  fetchById(id: string): Promise<UserDataObject | null>;
  fetch(options: FetchUsersOptions): Promise<ListUserDataObject>;
  create(input: UserCreateDataObject): Promise<string>;
  update(id: string, update: UserUpdateDataObject): Promise<void>;
}
export class UserSquidexDataProvider implements UserDataProvider {
  constructor(
    private squidexGraphlClient: SquidexGraphqlClient,
    private userSquidexRestClient: SquidexRestClient<RestUser, InputUser>,
  ) {}
  async fetchById(id: string): Promise<UserDataObject | null> {
    const { findUsersContent } = await this.queryFetchByIdData(id);
    if (!findUsersContent) {
      return null;
    }
    return parseGraphQLUserToDataObject(findUsersContent);
  }

  async create(userCreateDataObject: UserCreateDataObject): Promise<string> {
    const { teams, labIds, ...input } = userCreateDataObject;

    const user = cleanUser(input);

    const inputUser: InputUser['data'] = {
      ...user,
      email: {
        iv: input.email,
      },
      firstName: {
        iv: input.firstName,
      },
      lastName: {
        iv: input.lastName,
      },
      role: {
        iv: input.role,
      },
      teams: {
        iv: teams?.map((team) => ({ id: [team.id], role: team.role })) || [],
      },
      labs: {
        iv: labIds,
      },
      connections: {
        iv: [],
      },
      onboarded: {
        iv: input.onboarded || false,
      },
      dismissedGettingStarted: {
        iv: input.dismissedGettingStarted || false,
      },
      avatar: {
        iv: (input.avatar && [input.avatar]) || null,
      },
      degree: {
        iv: input.degree || null,
      },
      questions: {
        iv: input.questions?.map((question) => ({ question })) || null,
      },
      social: {
        iv: (input.social && [{ ...input.social }]) || [],
      },
    };
    const { id } = await this.userSquidexRestClient.create(inputUser);

    return id;
  }

  async update(id: string, userToUpdate: UserUpdateDataObject): Promise<void> {
    const isFullUpdate = shouldDoFullUpdate(userToUpdate);

    const cleanedUser = cleanUser(userToUpdate);

    if (isFullUpdate) {
      const existingUser = await this.userSquidexRestClient.fetchById(id);

      await this.userSquidexRestClient.put(id, {
        ...existingUser.data,
        ...cleanedUser,
      });
    } else {
      await this.userSquidexRestClient.patch(id, cleanedUser);
    }
  }
  async fetch(options: FetchUsersOptions): Promise<ListUserDataObject> {
    const queryFilter = generateFetchQueryFilter(options);
    const { take = 8, skip = 0 } = options;
    return this.queryForUsers(queryFilter, take, skip);
  }

  private async queryForUsers(filter: string, top: number, skip: number) {
    const { queryUsersContentsWithTotal } = await this.queryFetchData(
      filter,
      top,
      skip,
    );

    const { total = 0, items = [] } = queryUsersContentsWithTotal || {};

    return {
      total: items ? total : 0,
      items: (items || []).map(parseGraphQLUserToDataObject),
    };
  }
  private async queryFetchData(filter: string, top: number, skip: number) {
    return this.squidexGraphlClient.request<
      FetchUsersQuery,
      FetchUsersQueryVariables
    >(FETCH_USERS, { filter, top, skip });
  }
  private async queryFetchByIdData(id: string) {
    return this.squidexGraphlClient.request<
      FetchUserQuery,
      FetchUserQueryVariables
    >(FETCH_USER, { id });
  }
}

const shouldDoFullUpdate = (userToUpdate: UserUpdateDataObject) =>
  userToUpdate.teams?.length ||
  Object.values(userToUpdate).some(
    (value) => typeof value === 'string' && value.trim() === '',
  );

const cleanUser = (userToUpdate: UserUpdateDataObject) =>
  Object.entries(userToUpdate).reduce((acc, [key, value]) => {
    const setValue = (item: unknown) => ({ ...acc, [key]: { iv: item } });
    if (typeof value === 'string' && value.trim() === '') {
      return setValue(null);
    }

    // map flat questions to squidex format
    if (key === 'questions' && Array.isArray(value) && value.length) {
      return setValue(
        (value as string[]).map((question: string) => ({ question })),
      );
    }

    // we get an object but squidex expects an array of objects
    if (key === 'social' || key === 'avatar') {
      return setValue([value]);
    }
    return setValue(value);
  }, {} as { [key: string]: { iv: unknown } });

const generateFetchQueryFilter = ({ search, filter }: FetchUsersOptions) => {
  const searchFilter = (search || '')
    .split(' ')
    .filter(Boolean) // removes whitespaces
    .reduce(
      (acc: Filter[], word: string) =>
        acc.concat({
          or: [
            { 'data/firstName/iv': { contains: word } },
            { 'data/lastName/iv': { contains: word } },
            { 'data/institution/iv': { contains: word } },
            { 'data/expertiseAndResourceTags/iv': { contains: word } },
          ],
        }),
      [],
    );
  const {
    role,
    labId,
    teamId,
    code,
    onboarded = true,
    hidden = true,
    orcid,
  } = filter || {};
  const filterRoles = buildEqFilterForWords('teams', role, 'role');

  const filterLabs = buildEqFilterForWords('labs', labId);

  const filterTeams = buildEqFilterForWords('teams', teamId, 'id');
  const filterCode = code && { 'data/connections/iv/code': code };

  const filterHidden = hidden && { not: { 'data/role/iv': 'Hidden' } };
  const filterNonOnboarded = onboarded && { 'data/onboarded/iv': true };
  const filterOrcid = orcid && { 'data/order/iv': { contains: orcid } };

  const queryFilter = [
    filterTeams,
    filterRoles,
    filterLabs,
    filterCode,
    filterNonOnboarded,
    filterHidden,
    filterOrcid,
    ...searchFilter,
  ].filter(Boolean);
  return buildODataFilter(queryFilter);
};

export type GraphqlUserTeam = NonNullable<
  NonNullable<FetchUserQuery['findUsersContent']>['flatData']['teams']
>[number];

export const parseGraphQLUserTeamConnections = (
  teams: GraphqlUserTeam[],
): UserTeam[] =>
  teams.reduce((acc: UserTeam[], item) => {
    if (item.id === null || !item.id[0]) {
      logger.warn(`Team Connection is undefined`);
      return acc;
    }
    const team = item.id[0];
    const displayName = team.flatData?.displayName;
    const proposal = team.flatData?.proposal;
    if (!item.role || !isTeamRole(item.role)) {
      logger.warn(`Invalid team role: ${item.role}`);
      return acc;
    }
    return [
      ...acc,
      {
        id: team.id,
        role: item.role,
        proposal: proposal?.length ? proposal[0]?.id : undefined,
        displayName: displayName || '',
      },
    ];
  }, []);

type GraphQLUserRequiredFlatDataProperties =
  | 'email'
  | 'firstName'
  | 'institution'
  | 'jobTitle'
  | 'lastModifiedDate'
  | 'lastName';
type GraphQLUserFlatData = UsersContentFragment['flatData'];
type GraphQLUserRequiredFlatData = Pick<
  GraphQLUserFlatData,
  GraphQLUserRequiredFlatDataProperties
>;
type GraphQLUserOptionalFlatData = Partial<
  Omit<GraphQLUserFlatData, GraphQLUserRequiredFlatDataProperties>
>;
type GraphQLUser = Omit<UsersContentFragment, 'flatData'> & {
  flatData: GraphQLUserRequiredFlatData & GraphQLUserOptionalFlatData;
};

export const parseGraphQLUser = (user: GraphQLUser): UserResponse => {
  const userDataObject = parseGraphQLUserToDataObject(user);

  return parseUserToResponse(userDataObject);
};

const getOrcidWorkPublicationDate = (
  input: NonNullable<
    GraphQLUser['flatData']['orcidWorks']
  >[number]['publicationDate'],
): OrcidWork['publicationDate'] => {
  const date: OrcidWork['publicationDate'] = {};

  if (typeof input.day === 'string') {
    date.day = input.day;
  }

  if (typeof input.month === 'string') {
    date.month = input.month;
  }

  if (typeof input.year === 'string') {
    date.year = input.year;
  }

  return date;
};

export const parseUserToDataObject = (user: RestUser): UserDataObject => {
  const teams: UserTeam[] =
    user.data.teams?.iv?.reduce((acc: UserTeam[], team) => {
      const { id, ...t } = team;
      if (!id[0]) {
        logger.warn(`Team id is undefined on user: ${user.id}`);
        return acc;
      }
      return [
        ...acc,
        {
          id: id[0],
          displayName: 'Unknown',
          ...t,
        },
      ];
    }, []) || [];

  const orcid = user.data.orcid?.iv;
  const social = {
    ...((user.data.social?.iv && user.data.social?.iv[0]) || {}),
    orcid,
  };

  return {
    id: user.id,
    onboarded: user.data.onboarded.iv,
    dismissedGettingStarted: user.data.dismissedGettingStarted.iv,
    createdDate: parseDate(user.created).toISOString(),
    lastModifiedDate: user.data.lastModifiedDate?.iv ?? user.created,
    email: user.data.email.iv,
    contactEmail: user.data?.contactEmail?.iv,
    degree: user.data.degree?.iv,
    firstName: user.data.firstName?.iv,
    lastName: user.data.lastName?.iv,
    biography: user.data.biography?.iv,
    jobTitle: user.data.jobTitle?.iv,
    institution: user.data.institution?.iv,
    teams,
    social,
    orcid: user.data.orcid?.iv,
    orcidLastModifiedDate: user.data.orcidLastModifiedDate?.iv,
    orcidLastSyncDate: user.data.orcidLastSyncDate?.iv,
    orcidWorks: user.data.orcidWorks?.iv,
    expertiseAndResourceTags: user.data.expertiseAndResourceTags?.iv || [],
    expertiseAndResourceDescription:
      user.data.expertiseAndResourceDescription?.iv,
    questions: user.data.questions?.iv?.map(({ question }) => question) || [],
    avatarUrl:
      (user.data.avatar?.iv && createUrl(user.data.avatar.iv)[0]) ?? undefined,
    role: user.data.role.iv === 'Hidden' ? 'Guest' : user.data.role.iv,
    responsibilities: user.data.responsibilities?.iv,
    researchInterests: user.data.researchInterests?.iv ?? undefined,
    reachOut: user.data.reachOut?.iv,
    labs: (user.data.labs?.iv || []).map((lab) => ({
      id: lab.id,
      name: lab.flatData?.name ?? '',
    })),
    connections: user.data.connections?.iv ?? undefined,
  };
};
const isUserRole = (data: string): data is Role =>
  (crnUserRoles as ReadonlyArray<string>).includes(data);

const isUserDegree = (data: string): data is UserDegree =>
  (crnUserDegrees as ReadonlyArray<string>).includes(data);

const isOrcidWorkType = (data: string): data is OrcidWorkType =>
  (orcidWorkType as ReadonlyArray<string>).includes(data);

export const parseUserToResponse = ({
  connections: _,
  ...user
}: UserDataObject): UserResponse => {
  const displayName = `${user.firstName} ${user.lastName}`;
  const onboarded = typeof user.onboarded === 'boolean' ? user.onboarded : true;
  const dismissedGettingStarted = !!user.dismissedGettingStarted;
  const response = {
    ...user,
    displayName,
    dismissedGettingStarted,
    onboarded,
  };
  return response;
};

export const parseGraphQLUserToDataObject = (
  item: GraphQLUser,
): UserDataObject => {
  const flatTeams = item.flatData.teams || [];
  const flatAvatar = item.flatData.avatar || [];
  const flatQuestions = item.flatData.questions || [];
  const flatExpertiseAndResourceTags =
    item.flatData.expertiseAndResourceTags || [];
  const createdDate = parseDate(item.created).toISOString();

  const role =
    item.flatData.role && isUserRole(item.flatData.role)
      ? item.flatData.role
      : 'Guest';
  const teams = parseGraphQLUserTeamConnections(flatTeams || []);

  const orcid = item.flatData.orcid || undefined;
  // merge both and remove null values
  const social = Object.entries({
    ...((item.flatData.social && item.flatData.social[0]) || {}),
    orcid,
  }).reduce((acc, [k, v]) => {
    if (!v) {
      return acc;
    }
    return { ...acc, [k]: v };
  }, {} as { [key: string]: string });

  const flatLabs =
    item.flatData.labs?.reduce<LabResponse[]>((labs, lab) => {
      // skip Labs without names
      if (!lab.flatData.name) {
        return labs;
      }
      return [
        ...labs,
        {
          name: lab.flatData.name || '',
          id: lab.id,
        },
      ];
    }, []) || [];

  const orcidWorks =
    (item.flatData.orcidWorks &&
      item.flatData.orcidWorks
        .reduce<OrcidWork[]>((orcidWorksAccumulator, orcidWork) => {
          if (orcidWork.id === null || orcidWork.lastModifiedDate === null) {
            return orcidWorksAccumulator;
          }

          return [
            ...orcidWorksAccumulator,
            {
              id: orcidWork.id,
              doi: orcidWork.doi || undefined,
              title: orcidWork.title || undefined,
              type:
                orcidWork.type && isOrcidWorkType(orcidWork.type)
                  ? orcidWork.type
                  : 'UNDEFINED',
              publicationDate: getOrcidWorkPublicationDate(
                orcidWork.publicationDate,
              ),
              lastModifiedDate: orcidWork.lastModifiedDate,
            },
          ];
        }, [])
        .slice(0, 5)) ||
    [];

  return {
    id: item.id,
    onboarded:
      item.flatData && typeof item.flatData.onboarded === 'boolean'
        ? item.flatData.onboarded
        : undefined,
    createdDate,
    orcid,
    dismissedGettingStarted: !!item.flatData?.dismissedGettingStarted,
    firstName: item.flatData.firstName || '',
    lastName: item.flatData.lastName || '',
    biography: item.flatData.biography || undefined,
    degree:
      item.flatData.degree && isUserDegree(item.flatData.degree)
        ? item.flatData.degree
        : undefined,
    email: item.flatData.email || '',
    contactEmail: item.flatData.contactEmail || undefined,
    institution: item.flatData.institution || undefined,
    jobTitle: item.flatData.jobTitle || undefined,
    country: item.flatData.country || undefined,
    city: item.flatData.city || undefined,
    orcidWorks,
    questions:
      flatQuestions
        .map((q) => q.question)
        .filter<string>((q): q is string => typeof q === 'string') || [],
    expertiseAndResourceTags: flatExpertiseAndResourceTags,
    expertiseAndResourceDescription:
      item.flatData.expertiseAndResourceDescription ?? undefined,
    lastModifiedDate: item.flatData.lastModifiedDate || createdDate,
    teams,
    social,
    avatarUrl: flatAvatar?.length
      ? createUrl(flatAvatar.map((a) => a.id))[0]
      : undefined,
    role,
    responsibilities: item.flatData.responsibilities || undefined,
    researchInterests: item.flatData.researchInterests ?? undefined,
    reachOut: item.flatData.reachOut || undefined,
    labs: flatLabs || [],
    orcidLastSyncDate: item.flatData.orcidLastSyncDate || undefined,
  };
};
