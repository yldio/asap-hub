import { GenericError } from '@asap-hub/errors';
import { UserDataObject, UserPatchDataObject } from '@asap-hub/model';
import {
  config,
  RestUser,
  sanitiseForSquidex,
  SquidexGraphqlClient,
  SquidexRest,
  SquidexRestClient,
} from '@asap-hub/squidex';
import Intercept from 'apr-intercept';
import FormData from 'form-data';
import { Got } from 'got';
import mime from 'mime-types';
import {
  FetchUserQuery,
  FetchUserQueryVariables,
  FetchUsersQuery,
  FetchUsersQueryVariables,
} from '../autogenerated-gql/graphql';
import { FetchUsersOptions } from '../controllers/users';
import {
  parseGraphQLUserToDataObject,
  parseUserToDataObject,
} from '../entities';
import { FETCH_USER, FETCH_USERS } from '../queries/users.queries';

export interface UserDataProvider {
  fetchById(id: string): Promise<UserDataObject | null>;
  update(id: string, update: UserPatchDataObject): Promise<void>;
  fetch(options: FetchUsersOptions): Promise<UserDataObject[]>;
  fetchByCode(code: string): Promise<UserDataObject[]>;
  updateAvatar(id: string, avatar: Buffer, contentType: string): Promise<void>;
  connectByCode(
    welcomeCode: string,
    userId: string,
  ): Promise<UserDataObject | null>;
}
export default function users(
  squidexGraphlClient: SquidexGraphqlClient,
): UserDataProvider {
  const userSquidexRestClient = new SquidexRest<RestUser>('users');
  const fetchById = async (id: string) => {
    const { findUsersContent } = await queryFetchByIdData(
      squidexGraphlClient,
      id,
    );
    if (!findUsersContent) {
      return null;
    }
    return parseGraphQLUserToDataObject(findUsersContent);
  };
  const update = async (id: string, userToUpdate: UserPatchDataObject) => {
    const isFullUpdate = shouldDoFullUpdate(userToUpdate);

    const cleanedUser = cleanUser(userToUpdate);

    if (isFullUpdate) {
      const existingUser = await userSquidexRestClient.fetchById(id);
      await userSquidexRestClient.put(id, {
        ...existingUser.data,
        ...cleanedUser,
      });
    } else {
      await userSquidexRestClient.patch(id, cleanedUser);
    }
  };
  const fetch = async (options: FetchUsersOptions) => {
    const queryFilter = generateFetchQueryFilter(options);
    const { take = 8, skip = 0 } = options;
    const users = await queryForUsers(
      squidexGraphlClient,
      queryFilter,
      take,
      skip,
    );
    return users.map(parseGraphQLUserToDataObject);
  };
  const fetchByCode = async (code: string) => {
    const filter = `data/connections/iv/code eq '${code}'`;
    const users = await queryForUsers(squidexGraphlClient, filter, 1, 0);
    return users.map(parseGraphQLUserToDataObject);
  };
  const updateAvatar = async (
    id: string,
    avatar: Buffer,
    contentType: string,
  ) => {
    const assetId = await uploadAvatar(
      userSquidexRestClient,
      id,
      avatar,
      contentType,
    );

    await userSquidexRestClient.patch(id, { avatar: { iv: [assetId] } });
  };

  const connectByCode = async (welcomeCode: string, userId: string) => {
    const user = await queryByCode(welcomeCode, userSquidexRestClient.client);

    if (!user) {
      return null;
    }

    if (user.data.connections.iv?.find(({ code }) => code === userId)) {
      return parseUserToDataObject(user);
    }

    const connections = (user.data.connections.iv || []).concat([
      { code: userId },
    ]);

    const res = await userSquidexRestClient.patch(user.id, {
      email: { iv: user.data.email.iv },
      connections: { iv: connections },
    });

    return parseUserToDataObject(res);
  };
  return { fetchById, update, fetch, fetchByCode, updateAvatar, connectByCode };
}
const shouldDoFullUpdate = (userToUpdate: UserPatchDataObject) =>
  userToUpdate.teams?.length ||
  Object.values(userToUpdate).some(
    (value) => value.trim && value.trim() === '',
  );

async function queryForUsers(
  squidexGraphlClient: SquidexGraphqlClient,
  filter: string,
  top: number,
  skip: number,
) {
  const { queryUsersContentsWithTotal } = await queryFetchData(
    squidexGraphlClient,
    filter,
    top,
    skip,
  );
  if (!(queryUsersContentsWithTotal && queryUsersContentsWithTotal.items)) {
    return [];
  }
  return queryUsersContentsWithTotal.items;
}
const cleanUser = (userToUpdate: UserPatchDataObject) =>
  Object.entries(userToUpdate).reduce((acc, [key, value]) => {
    const setValue = (item: unknown) => ({ ...acc, [key]: { iv: item } });
    if (value.trim && value.trim() === '') {
      return setValue(null);
    }

    // map flat questions to squidex format
    if (key === 'questions' && value.length) {
      return setValue(value.map((question: string) => ({ question })));
    }

    // we get an object but squidex expects an array of objects
    if (key === 'social') {
      return setValue([value]);
    }

    return setValue(value);
  }, {} as { [key: string]: { iv: unknown } });

async function queryFetchByIdData(
  squidexGraphlClient: SquidexGraphqlClient,
  id: string,
) {
  return squidexGraphlClient.request<FetchUserQuery, FetchUserQueryVariables>(
    FETCH_USER,
    { id },
  );
}

async function queryFetchData(
  squidexGraphlClient: SquidexGraphqlClient,
  filter: string,
  top: number,
  skip: number,
) {
  return squidexGraphlClient.request<FetchUsersQuery, FetchUsersQueryVariables>(
    FETCH_USERS,
    { filter, top, skip },
  );
}

function generateFetchQueryFilter(options: FetchUsersOptions) {
  const searchFilter = [
    ...(options.search || '')
      .split(' ')
      .filter(Boolean) // removes whitespaces
      .map(sanitiseForSquidex)
      .reduce(
        (acc: string[], word: string) =>
          acc.concat(
            `(${[
              [`contains(data/firstName/iv, '${word}')`],
              [`contains(data/lastName/iv, '${word}')`],
              [`contains(data/institution/iv, '${word}')`],
              [`contains(data/expertiseAndResourceTags/iv, '${word}')`],
            ].join(' or ')})`,
          ),
        [],
      ),
  ].join(' and ');
  const filterRoles = (options?.filter?.role || [])
    .reduce(
      (acc: string[], word: string) =>
        acc.concat([`data/teams/iv/role eq '${word}'`]),
      [],
    )
    .join(' or ');

  const filterLabs = (options?.filter?.labId || [])
    .reduce(
      (acc: string[], labId: string) =>
        acc.concat([`data/labs/iv eq '${labId}'`]),
      [],
    )
    .join(' or ');

  const filterTeams = (options?.filter?.teamId || [])
    .reduce(
      (acc: string[], teamId: string) =>
        acc.concat([`data/teams/iv/id eq '${teamId}'`]),
      [],
    )
    .join(' or ');
  const filterHidden = "data/role/iv ne 'Hidden'";
  const filterNonOnboarded = 'data/onboarded/iv eq true';

  const queryFilter = [
    filterTeams && `(${filterTeams})`,
    filterRoles && `(${filterRoles})`,
    filterLabs && `(${filterLabs})`,
    filterNonOnboarded,
    filterHidden,
    searchFilter && `(${searchFilter})`,
  ]
    .filter(Boolean)
    .join(' and ')
    .trim();
  return queryFilter;
}

async function uploadAvatar(
  userSquidexRestClient: SquidexRestClient<RestUser>,
  id: string,
  avatar: Buffer,
  contentType: string,
): Promise<string> {
  const form = new FormData();
  form.append('file', avatar, {
    filename: `${id}.${mime.extension(contentType)}`,
    contentType,
  });

  const { id: assetId } = await userSquidexRestClient.client
    .post('assets', {
      prefixUrl: `${config.baseUrl}/api/apps/${config.appName}`,
      headers: form.getHeaders(),
      body: form,
    })
    .json();
  return assetId;
}
const queryByCode = async (
  code: string,
  client: Got,
): Promise<RestUser | undefined> => {
  const [err, res] = await Intercept(
    client
      .get('users', {
        searchParams: {
          $top: 1,
          $filter: `data/connections/iv/code eq '${code}'`,
        },
      })
      .json() as Promise<{ items: RestUser[] }>,
  );

  if (err) {
    throw new GenericError(err.message);
  }

  if (res.items.length === 0 || !res.items[0]) {
    return undefined;
  }

  return res.items[0];
};
