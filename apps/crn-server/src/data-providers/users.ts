import { GenericError } from '@asap-hub/errors';
import { UserDataObject, UserPatchDataObject } from '@asap-hub/model';
import {
  config,
  RestUser,
  sanitiseForSquidex,
  SquidexGraphqlClient,
  SquidexRest,
  SquidexRestClient,
} from '@asap-hub/squidex';
import Intercept from 'apr-intercept';
import FormData from 'form-data';
import mime from 'mime-types';
import {
  FetchUserQuery,
  FetchUserQueryVariables,
  FetchUsersQuery,
  FetchUsersQueryVariables,
} from '../autogenerated-gql/graphql';
import { FetchUsersOptions } from '../controllers/users';
import {
  parseGraphQLUserToDataObject,
  parseUserToDataObject,
} from '../entities';
import { FETCH_USER, FETCH_USERS } from '../queries/users.queries';
import { fetchOrcidProfile, transformOrcidWorks } from '../utils/fetch-orcid';

export interface UserDataProvider {
  fetchById(id: string): Promise<UserDataObject | null>;
  update(id: string, update: UserPatchDataObject): Promise<void>;
  fetch(options: FetchUsersOptions): Promise<UserDataObject[]>;
  fetchByCode(code: string): Promise<UserDataObject[]>;
  updateAvatar(id: string, avatar: Buffer, contentType: string): Promise<void>;
  connectByCode(
    welcomeCode: string,
    userId: string,
  ): Promise<UserDataObject | null>;
  syncOrcidProfile(
    id: string,
    cachedUser?: RestUser | undefined,
  ): Promise<UserDataObject>;
}
export default class Users implements UserDataProvider {
  squidexGraphlClient: SquidexGraphqlClient;
  userSquidexRestClient: SquidexRestClient<RestUser>;
  constructor(squidexGraphlClient: SquidexGraphqlClient) {
    this.squidexGraphlClient = squidexGraphlClient;
    this.userSquidexRestClient = new SquidexRest<RestUser>('users');
  }
  async fetchById(id: string) {
    const { findUsersContent } = await this.queryFetchByIdData(id);
    if (!findUsersContent) {
      return null;
    }
    return parseGraphQLUserToDataObject(findUsersContent);
  }

  async update(id: string, userToUpdate: UserPatchDataObject) {
    const isFullUpdate = this.shouldDoFullUpdate(userToUpdate);

    const cleanedUser = this.cleanUser(userToUpdate);

    if (isFullUpdate) {
      const existingUser = await this.userSquidexRestClient.fetchById(id);
      await this.userSquidexRestClient.put(id, {
        ...existingUser.data,
        ...cleanedUser,
      });
    } else {
      await this.userSquidexRestClient.patch(id, cleanedUser);
    }
  }
  async fetch(options: FetchUsersOptions) {
    const queryFilter = this.generateFetchQueryFilter(options);
    const { take = 8, skip = 0 } = options;
    const users = await this.queryForUsers(queryFilter, take, skip);
    return users.map(parseGraphQLUserToDataObject);
  }
  async fetchByCode(code: string) {
    const filter = `data/connections/iv/code eq '${code}'`;
    const users = await this.queryForUsers(filter, 1, 0);
    return users.map(parseGraphQLUserToDataObject);
  }
  updateAvatar = async (id: string, avatar: Buffer, contentType: string) => {
    const assetId = await this.uploadAvatar(id, avatar, contentType);

    await this.userSquidexRestClient.patch(id, { avatar: { iv: [assetId] } });
  };

  async connectByCode(welcomeCode: string, userId: string) {
    const user = await this.queryByCode(welcomeCode);

    if (!user) {
      return null;
    }

    if (user.data.connections.iv?.find(({ code }) => code === userId)) {
      return parseUserToDataObject(user);
    }

    const connections = (user.data.connections.iv || []).concat([
      { code: userId },
    ]);

    const res = await this.userSquidexRestClient.patch(user.id, {
      email: { iv: user.data.email.iv },
      connections: { iv: connections },
    });

    return parseUserToDataObject(res);
  }

  async syncOrcidProfile(
    id: string,
    cachedUser: RestUser | undefined = undefined,
  ) {
    let fetchedUser;
    if (!cachedUser) {
      fetchedUser = await this.userSquidexRestClient.fetchById(id);
    }

    const user = cachedUser || (fetchedUser as RestUser);

    const [error, res] = await Intercept(
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      fetchOrcidProfile(user!.data.orcid!.iv),
    );

    const updateToUser: Partial<RestUser['data']> = {
      email: { iv: user.data.email.iv },
      orcidLastSyncDate: { iv: new Date().toISOString() },
    };

    if (!error) {
      const { lastModifiedDate, works } = transformOrcidWorks(res);
      updateToUser.orcidLastModifiedDate = { iv: lastModifiedDate };
      updateToUser.orcidWorks = { iv: works.slice(0, 10) };
    }

    const updatedUser = await this.userSquidexRestClient.patch(
      user.id,
      updateToUser,
    );
    return parseUserToDataObject(updatedUser);
  }
  private shouldDoFullUpdate(userToUpdate: UserPatchDataObject) {
    return (
      userToUpdate.teams?.length ||
      Object.values(userToUpdate).some(
        (value) => value.trim && value.trim() === '',
      )
    );
  }
  private async queryForUsers(filter: string, top: number, skip: number) {
    const { queryUsersContentsWithTotal } = await this.queryFetchData(
      filter,
      top,
      skip,
    );
    if (!(queryUsersContentsWithTotal && queryUsersContentsWithTotal.items)) {
      return [];
    }
    return queryUsersContentsWithTotal.items;
  }
  private async queryFetchData(filter: string, top: number, skip: number) {
    return this.squidexGraphlClient.request<
      FetchUsersQuery,
      FetchUsersQueryVariables
    >(FETCH_USERS, { filter, top, skip });
  }
  private async queryFetchByIdData(id: string) {
    return this.squidexGraphlClient.request<
      FetchUserQuery,
      FetchUserQueryVariables
    >(FETCH_USER, { id });
  }
  private async uploadAvatar(
    id: string,
    avatar: Buffer,
    contentType: string,
  ): Promise<string> {
    const form = new FormData();
    form.append('file', avatar, {
      filename: `${id}.${mime.extension(contentType)}`,
      contentType,
    });

    const { id: assetId } = await this.userSquidexRestClient.client
      .post('assets', {
        prefixUrl: `${config.baseUrl}/api/apps/${config.appName}`,
        headers: form.getHeaders(),
        body: form,
      })
      .json();
    return assetId;
  }
  private async queryByCode(code: string): Promise<RestUser | undefined> {
    const [err, res] = await Intercept(
      this.userSquidexRestClient.client
        .get('users', {
          searchParams: {
            $top: 1,
            $filter: `data/connections/iv/code eq '${code}'`,
          },
        })
        .json() as Promise<{ items: RestUser[] }>,
    );

    if (err) {
      throw new GenericError(err.message);
    }

    if (res.items.length === 0 || !res.items[0]) {
      return undefined;
    }

    return res.items[0];
  }
  private cleanUser(userToUpdate: UserPatchDataObject) {
    return Object.entries(userToUpdate).reduce((acc, [key, value]) => {
      const setValue = (item: unknown) => ({ ...acc, [key]: { iv: item } });
      if (value.trim && value.trim() === '') {
        return setValue(null);
      }

      // map flat questions to squidex format
      if (key === 'questions' && value.length) {
        return setValue(value.map((question: string) => ({ question })));
      }

      // we get an object but squidex expects an array of objects
      if (key === 'social') {
        return setValue([value]);
      }

      return setValue(value);
    }, {} as { [key: string]: { iv: unknown } });
  }
  generateFetchQueryFilter(options: FetchUsersOptions) {
    const searchFilter = [
      ...(options.search || '')
        .split(' ')
        .filter(Boolean) // removes whitespaces
        .map(sanitiseForSquidex)
        .reduce(
          (acc: string[], word: string) =>
            acc.concat(
              `(${[
                [`contains(data/firstName/iv, '${word}')`],
                [`contains(data/lastName/iv, '${word}')`],
                [`contains(data/institution/iv, '${word}')`],
                [`contains(data/expertiseAndResourceTags/iv, '${word}')`],
              ].join(' or ')})`,
            ),
          [],
        ),
    ].join(' and ');
    const filterRoles = (options?.filter?.role || [])
      .reduce(
        (acc: string[], word: string) =>
          acc.concat([`data/teams/iv/role eq '${word}'`]),
        [],
      )
      .join(' or ');

    const filterLabs = (options?.filter?.labId || [])
      .reduce(
        (acc: string[], labId: string) =>
          acc.concat([`data/labs/iv eq '${labId}'`]),
        [],
      )
      .join(' or ');

    const filterTeams = (options?.filter?.teamId || [])
      .reduce(
        (acc: string[], teamId: string) =>
          acc.concat([`data/teams/iv/id eq '${teamId}'`]),
        [],
      )
      .join(' or ');
    const filterHidden = "data/role/iv ne 'Hidden'";
    const filterNonOnboarded = 'data/onboarded/iv eq true';

    const queryFilter = [
      filterTeams && `(${filterTeams})`,
      filterRoles && `(${filterRoles})`,
      filterLabs && `(${filterLabs})`,
      filterNonOnboarded,
      filterHidden,
      searchFilter && `(${searchFilter})`,
    ]
      .filter(Boolean)
      .join(' and ')
      .trim();
    return queryFilter;
  }
}
