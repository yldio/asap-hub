import {
  FetchWorkingGroupOptions,
  WorkingGroupDataObject,
  WorkingGroupListDataObject,
  WorkingGroupUpdateDataObject,
} from '@asap-hub/model';
import {
  RestWorkingGroup,
  SquidexGraphqlClient,
  SquidexRestClient,
} from '@asap-hub/squidex';
import { Filter } from 'odata-query';
import {
  FetchWorkingGroupQuery,
  FetchWorkingGroupQueryVariables,
  FetchWorkingGroupsQuery,
  FetchWorkingGroupsQueryVariables,
} from '../autogenerated-gql/graphql';
import { parseGraphQlWorkingGroup } from '../entities/working-group';
import {
  FETCH_WORKING_GROUP,
  FETCH_WORKING_GROUPS,
} from '../queries/working-groups.queries';
import { buildODataFilter } from '../utils/odata';

export interface WorkingGroupDataProvider {
  fetchById(id: string): Promise<WorkingGroupDataObject | null>;
  fetch(options: FetchWorkingGroupOptions): Promise<WorkingGroupListDataObject>;
  patch(id: string, data: WorkingGroupUpdateDataObject): Promise<void>;
}

export class WorkingGroupSquidexDataProvider
  implements WorkingGroupDataProvider
{
  constructor(
    private squidexGraphqlClient: SquidexGraphqlClient,
    private squidexRestClient: SquidexRestClient<RestWorkingGroup>,
  ) {}

  async fetchById(id: string): Promise<WorkingGroupDataObject | null> {
    const { findWorkingGroupsContent: workingGroup } =
      await this.squidexGraphqlClient.request<
        FetchWorkingGroupQuery,
        FetchWorkingGroupQueryVariables
      >(FETCH_WORKING_GROUP, { id });

    if (!workingGroup) {
      return null;
    }

    return parseGraphQlWorkingGroup(workingGroup);
  }

  async fetch(
    options: FetchWorkingGroupOptions,
  ): Promise<WorkingGroupListDataObject> {
    const { search, take = 10, skip = 0 } = options;
    const filterList = (search || '')
      .split(' ')
      .filter(Boolean) // removes whitespaces
      .reduce(
        (acc: Filter[], word: string) =>
          acc.concat({
            or: [
              { 'data/title/iv': { contains: word } },
              { 'data/description/iv': { contains: word } },
              { 'data/shortText/iv': { contains: word } },
            ],
          }),
        [],
      );

    if (options.filter) {
      if ('complete' in options.filter) {
        filterList.push({ 'data/complete/iv': options.filter.complete });
      }
    }

    const { queryWorkingGroupsContentsWithTotal } =
      await this.squidexGraphqlClient.request<
        FetchWorkingGroupsQuery,
        FetchWorkingGroupsQueryVariables
      >(FETCH_WORKING_GROUPS, {
        filter: buildODataFilter(filterList),
        top: take,
        skip,
      });

    if (queryWorkingGroupsContentsWithTotal === null) {
      return {
        total: 0,
        items: [],
      };
    }

    const { items, total } = queryWorkingGroupsContentsWithTotal;

    if (items === null) {
      return {
        total: 0,
        items: [],
      };
    }

    return {
      total,
      items: items.map(parseGraphQlWorkingGroup),
    };
  }

  async patch(id: string, data: WorkingGroupUpdateDataObject): Promise<void> {
    await this.squidexRestClient.patch(id, mapWorkingGroupValues(data));
  }
}

const mapWorkingGroupValues = (wgToUpdate: WorkingGroupUpdateDataObject) =>
  Object.entries(wgToUpdate).reduce((acc, [key, value]) => {
    const setValue = (item: unknown) => ({ ...acc, [key]: { iv: item } });
    if (typeof value === 'string' && value.trim() === '') {
      return setValue(null);
    }
    return setValue(value);
  }, {} as { [key: string]: { iv: unknown } });
