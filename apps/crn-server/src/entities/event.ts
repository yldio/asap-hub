/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { DateTime } from 'luxon';
import {
  EventResponse,
  EventSpeaker,
  MEETING_LINK_AVAILABLE_HOURS_BEFORE_EVENT,
  isEventStatus,
  EventSpeakerUserData,
  EventSpeakerExternalUserData,
} from '@asap-hub/model';
import { createURL, parseDate } from '@asap-hub/squidex';

import { parseGraphqlCalendar } from './calendar';
import { parseGraphQLGroup } from './group';
import {
  Asset,
  EventContentFragment,
  ExternalAuthors,
  ExternalAuthorsFlatDataDto,
  Maybe,
  Teams,
  Users,
  UsersDataTeamsChildDto,
  UsersFlatDataDto,
} from '../autogenerated-gql/graphql';

export const getMeetingMaterial = <T>(
  material: T,
  isPermanentlyUnavailable: boolean,
  isStale: boolean,
  emptyState: T,
): T | null => {
  const isEmpty = !(Array.isArray(material) ? material.length : material);
  if (isPermanentlyUnavailable || (isEmpty && isStale)) {
    return null;
  }
  return isEmpty ? emptyState : material;
};

export type GraphqlEventSpeakerUser = {
  __typename: 'Users';
} & Pick<Users, 'id'> & {
    flatData: Pick<UsersFlatDataDto, 'firstName' | 'lastName'> & {
      avatar: Maybe<Pick<Asset, 'id'>[]>;
      teams: Maybe<
        (Pick<UsersDataTeamsChildDto, 'role'> & {
          id: Maybe<Pick<Teams, 'id'>[]>;
        })[]
      >;
    };
  };

export type GraphqlEventSpeakerExternalUser = {
  __typename: 'ExternalAuthors';
} & Pick<ExternalAuthors, 'id'> & {
    flatData: Pick<ExternalAuthorsFlatDataDto, 'name' | 'orcid'>;
  };

export const parseEventSpeakerUser = (
  user: GraphqlEventSpeakerUser,
): EventSpeakerUserData => {
  const flatAvatar = user.flatData.avatar || [];

  return {
    id: user.id,
    firstName: user.flatData.firstName ?? undefined,
    lastName: user.flatData.lastName ?? undefined,
    displayName: `${user.flatData.firstName} ${user.flatData.lastName}`,
    avatarUrl: flatAvatar.length
      ? createURL(flatAvatar.map((a) => a.id))[0]
      : undefined,
  };
};

export const parseEventSpeakerExternalUser = (
  user: GraphqlEventSpeakerExternalUser,
): EventSpeakerExternalUserData => ({
  name: user.flatData.name || '',
  orcid: user.flatData.orcid || '',
});

export const parseGraphQLSpeakers = (
  speakers: NonNullable<EventContentFragment['flatData']['speakers']>,
): EventSpeaker[] =>
  speakers.map((speaker) => {
    const team = speaker?.team?.[0];
    const user = speaker?.user?.[0];

    if (user?.__typename === 'ExternalAuthors') {
      return {
        externalUser: parseEventSpeakerExternalUser(user),
      };
    }

    if (!team) {
      throw new Error('Either team or external author is required');
    }

    const role =
      user?.flatData.teams
        ?.filter((t) => t.id && t.id[0]?.id === team.id)
        .filter((s) => s.role)[0]?.role || undefined;

    if (!user || !role) {
      return {
        team: {
          id: team.id,
          displayName: team.flatData.displayName ?? '',
        },
      };
    }

    return {
      team: {
        id: team.id,
        displayName: team.flatData.displayName ?? '',
      },
      user: parseEventSpeakerUser(user),
      role,
    };
  });

export const parseGraphQLEvent = (
  item: EventContentFragment,
): EventResponse => {
  if (!item.flatData.calendar?.[0]) {
    throw new Error(`Event (${item.id}) doesn't have a calendar"`);
  }

  const calendar = parseGraphqlCalendar(item.flatData.calendar[0]);
  const group =
    item.flatData.calendar![0].referencingGroupsContents?.map((calGroup) =>
      parseGraphQLGroup(calGroup),
    )[0] || undefined;
  const startDate = DateTime.fromISO(item.flatData.startDate!);
  const now = DateTime.utc();

  const meetingLink =
    now.plus({ hours: MEETING_LINK_AVAILABLE_HOURS_BEFORE_EVENT }) > startDate
      ? item.flatData.meetingLink || undefined
      : undefined;

  // fallback to group thumbnail
  const thumbnail = item.flatData.thumbnail?.length
    ? createURL(item.flatData.thumbnail.map((t) => t.id))[0]
    : group?.thumbnail;

  const speakers = parseGraphQLSpeakers(item.flatData.speakers ?? []);

  const endDate = DateTime.fromISO(item.flatData.endDate);
  const isStale = endDate.diffNow('days').get('days') < -14; // 14 days have passed after the event

  const {
    notesPermanentlyUnavailable,
    videoRecordingPermanentlyUnavailable,
    presentationPermanentlyUnavailable,
    meetingMaterialsPermanentlyUnavailable,
    notes,
    videoRecording,
    presentation,
    meetingMaterials,
  } = item.flatData;

  if (!isEventStatus(item.flatData.status)) {
    throw new Error(
      `Invalid event (${item.id}) status "${item.flatData.status}"`,
    );
  }

  return {
    id: item.id,
    description: item.flatData.description || '',
    startDate: startDate.toUTC().toString(),
    startDateTimeZone: item.flatData.startDateTimeZone!,
    endDate: endDate.toUTC().toString(),
    endDateTimeZone: item.flatData.endDateTimeZone!,
    lastModifiedDate: parseDate(item.lastModified).toISOString(),
    title: item.flatData.title!,
    notes: getMeetingMaterial(
      notes,
      !!notesPermanentlyUnavailable,
      isStale,
      undefined,
    ),
    videoRecording: getMeetingMaterial(
      videoRecording,
      !!videoRecordingPermanentlyUnavailable,
      isStale,
      undefined,
    ),
    presentation: getMeetingMaterial(
      presentation,
      !!presentationPermanentlyUnavailable,
      isStale,
      undefined,
    ),
    meetingMaterials: getMeetingMaterial(
      (meetingMaterials ?? []).map(({ title, url }) => ({
        title: title ?? '',
        url: url ?? '',
      })),
      !!meetingMaterialsPermanentlyUnavailable,
      isStale,
      [],
    ),
    thumbnail,
    meetingLink,
    hideMeetingLink: item.flatData.hideMeetingLink || false,
    status: item.flatData.status,
    tags: item.flatData.tags ?? [],
    calendar,
    group,
    speakers,
  };
};
