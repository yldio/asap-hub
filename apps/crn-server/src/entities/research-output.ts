import {
  convertDecisionToBoolean,
  isResearchOutputDocumentType,
  ResearchOutputDataObject,
  researchOutputMapType,
  ResearchOutputSharingStatus,
  sharingStatuses,
  TeamResponse,
} from '@asap-hub/model';
import { parseDate } from '@asap-hub/squidex';
import {
  EnrichedContentEventType,
  FetchResearchOutputQuery,
  Labs,
  Scalars,
} from '../autogenerated-gql/graphql';
import { parseGraphQLUser } from '../data-providers/users.data-provider';

export const parseGraphQLResearchOutput = (
  output: NonNullable<FetchResearchOutputQuery['findResearchOutputsContent']>,
): ResearchOutputDataObject => {
  const contactEmails =
    output.flatData.teams?.flatMap((team) =>
      team.referencingUsersContents
        ?.filter(
          (user) =>
            user.flatData.teams &&
            user.flatData.teams.filter(
              (innerTeam) =>
                innerTeam.role === 'Project Manager' &&
                innerTeam.id?.[0]?.id === team.id,
            ).length !== 0,
        )
        .map((user) => user.flatData?.email),
    ) || [];

  const filteredContactEmails = contactEmails?.filter(
    (email): email is string => email !== undefined,
  ) as string[];

  const uniqueContactEmails = [...new Set(filteredContactEmails)];

  const data = output.flatData;
  const type = researchOutputMapType(data.type);

  return {
    id: output.id,
    authors:
      output.flatData.authors
        ?.filter(
          (author) =>
            author.__typename !== 'Users' ||
            author.flatData?.onboarded !== false,
        )
        .map((author) => {
          if (author.__typename === 'Users') {
            return parseGraphQLUser(author);
          }

          return {
            id: author.id,
            displayName: author.flatData?.name || '',
            orcid: author.flatData?.orcid || undefined,
          };
        }) || [],
    teams:
      output.flatData.teams?.map((team) => parseGraphqlTeamLite(team)) || [],
    relatedResearch:
      output.flatData.relatedResearch?.map((research) =>
        parseGraphqlResearchOutputLite(research),
      ) || [],
    created: parseDate(output.created).toISOString(),
    link: data.link || undefined,
    documentType:
      data.documentType && isResearchOutputDocumentType(data.documentType)
        ? data.documentType
        : 'Grant Document',
    type: type || undefined,
    title: data.title || '',
    description: data.description || '',
    tags: data.tags || [],
    publishDate: data.publishDate || undefined,
    labCatalogNumber: data.labCatalogNumber || undefined,
    doi: data.doi || undefined,
    accession: data.accession || undefined,
    rrid: data.rrid || undefined,
    addedDate: data.addedDate,
    lastUpdatedPartial:
      data.lastUpdatedPartial || output.lastModified || output.created,
    usageNotes: data.usageNotes || undefined,
    sharingStatus:
      data.sharingStatus !== null && isSharingStatus(data.sharingStatus)
        ? data.sharingStatus
        : 'Network Only',
    asapFunded: convertDecisionToBoolean(data.asapFunded),
    usedInPublication: convertDecisionToBoolean(data.usedInAPublication),
    contactEmails: uniqueContactEmails,
    labs:
      data.labs
        ?.filter((lab): lab is LabWithName => lab.flatData.name !== null)
        .map((lab) => ({
          id: lab.id,
          name: lab.flatData.name,
        })) || [],
    methods:
      data.methods?.flatMap((method) =>
        method.flatData.name ? [method.flatData.name] : [],
      ) || [],
    organisms:
      data.organisms?.flatMap((organism) =>
        organism.flatData.name ? [organism.flatData.name] : [],
      ) || [],
    environments:
      data.environments?.flatMap((environment) =>
        environment.flatData.name ? [environment.flatData.name] : [],
      ) || [],
    subtype: data.subtype?.[0]?.flatData.name || undefined,
    keywords:
      data.keywords?.flatMap((method) =>
        method.flatData.name ? [method.flatData.name] : [],
      ) || [],
    workingGroups:
      data.workingGroups?.map((group) => ({
        id: group.id,
        title: group.flatData.title || '',
      })) || [],
    published: output.status === EnrichedContentEventType.Published,
  };
};

const parseGraphqlTeamLite = (
  graphqlTeam: FetchResearchOutputTeamContents,
): Pick<TeamResponse, 'id' | 'displayName' | 'inactiveSince'> => ({
  id: graphqlTeam.id,
  displayName: graphqlTeam.flatData?.displayName || '',
  inactiveSince: graphqlTeam.flatData?.inactiveSince,
});

const parseGraphqlResearchOutputLite = ({
  id: researchOutputId,
  flatData,
}: FetchResearchOutputRelatedResearch): Pick<
  ResearchOutputDataObject,
  'id' | 'title' | 'type' | 'documentType' | 'teams'
> => ({
  id: researchOutputId,
  title: flatData.title || '',
  type: researchOutputMapType(flatData.type) || undefined,
  documentType:
    flatData.documentType && isResearchOutputDocumentType(flatData.documentType)
      ? flatData.documentType
      : 'Grant Document',
  teams:
    flatData.teams?.map(({ id, flatData: { displayName } }) => ({
      id,
      displayName: displayName || '',
    })) || [],
});

const isSharingStatus = (
  status: string,
): status is ResearchOutputSharingStatus =>
  (sharingStatuses as ReadonlyArray<string>).includes(status);

type FetchResearchOutputTeamContents = NonNullable<
  NonNullable<
    FetchResearchOutputQuery['findResearchOutputsContent']
  >['flatData']['teams']
>[number];

type FetchResearchOutputRelatedResearch = NonNullable<
  NonNullable<
    FetchResearchOutputQuery['findResearchOutputsContent']
  >['flatData']['relatedResearch']
>[number];

type LabWithName = Pick<Labs, 'id'> & {
  flatData: {
    name: Scalars['String'];
  };
};
