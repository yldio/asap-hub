import {
  LabResponse,
  OrcidWork,
  OrcidWorkType,
  orcidWorkType,
  Role,
  UserDataObject,
  UserDegree,
  userDegree,
  UserResponse,
  userRole,
  UserTeam,
} from '@asap-hub/model';
import { createURL, parseDate, RestUser } from '@asap-hub/squidex';
import {
  FetchUserQuery,
  UsersContentFragment,
} from '../autogenerated-gql/graphql';
import logger from '../utils/logger';
import { isTeamRole } from './team';

export type CMSOrcidWork = OrcidWork;

export type GraphqlUserTeam = NonNullable<
  NonNullable<FetchUserQuery['findUsersContent']>['flatData']['teams']
>[number];

export const parseGraphQLUserTeamConnections = (
  teams: GraphqlUserTeam[],
): UserTeam[] =>
  teams.reduce((acc: UserTeam[], item) => {
    if (item.id === null || !item.id[0]) {
      logger.warn(`Team Connection is undefined`);
      return acc;
    }
    const team = item.id[0];
    const displayName = team.flatData?.displayName;
    const proposal = team.flatData?.proposal;
    if (!item.role || !isTeamRole(item.role)) {
      logger.warn(`Invalid team role: ${item.role}`);
      return acc;
    }
    return [
      ...acc,
      {
        id: team.id,
        role: item.role,
        proposal: proposal?.length ? proposal[0]?.id : undefined,
        displayName: displayName || '',
      },
    ];
  }, []);

type GraphQLUserRequiredFlatDataProperties =
  | 'email'
  | 'firstName'
  | 'institution'
  | 'jobTitle'
  | 'lastModifiedDate'
  | 'lastName';
type GraphQLUserFlatData = UsersContentFragment['flatData'];
type GraphQLUserRequiredFlatData = Pick<
  GraphQLUserFlatData,
  GraphQLUserRequiredFlatDataProperties
>;
type GraphQLUserOptionalFlatData = Partial<
  Omit<GraphQLUserFlatData, GraphQLUserRequiredFlatDataProperties>
>;
type GraphQLUser = Omit<UsersContentFragment, 'flatData'> & {
  flatData: GraphQLUserRequiredFlatData & GraphQLUserOptionalFlatData;
};

export const parseGraphQLUser = (user: GraphQLUser): UserResponse => {
  const userDataObject = parseGraphQLUserToDataObject(user);

  return parseUserToResponse(userDataObject);
};

const getOrcidWorkPublicationDate = (
  input: NonNullable<
    GraphQLUser['flatData']['orcidWorks']
  >[number]['publicationDate'],
): OrcidWork['publicationDate'] => {
  const date: OrcidWork['publicationDate'] = {};

  if (typeof input.day === 'string') {
    date.day = input.day;
  }

  if (typeof input.month === 'string') {
    date.month = input.month;
  }

  if (typeof input.year === 'string') {
    date.year = input.year;
  }

  return date;
};

export const parseUserToDataObject = (user: RestUser): UserDataObject => {
  const teams: UserTeam[] =
    user.data.teams?.iv?.reduce((acc: UserTeam[], team) => {
      const { id, ...t } = team;
      if (!id[0]) {
        logger.warn(`Team id is undefined on user: ${user.id}`);
        return acc;
      }
      return [
        ...acc,
        {
          id: id[0],
          displayName: 'Unknown',
          ...t,
        },
      ];
    }, []) || [];

  const orcid = user.data.orcid?.iv;
  const social = {
    ...((user.data.social?.iv && user.data.social?.iv[0]) || {}),
    orcid,
  };

  return {
    id: user.id,
    onboarded: user.data.onboarded.iv,
    createdDate: parseDate(user.created).toISOString(),
    lastModifiedDate: user.data.lastModifiedDate?.iv ?? user.created,
    email: user.data.email.iv,
    contactEmail: user.data?.contactEmail?.iv,
    degree: user.data.degree?.iv,
    firstName: user.data.firstName?.iv,
    lastName: user.data.lastName?.iv,
    biography: user.data.biography?.iv,
    jobTitle: user.data.jobTitle?.iv,
    institution: user.data.institution?.iv,
    teams,
    social,
    orcid: user.data.orcid?.iv,
    orcidLastModifiedDate: user.data.orcidLastModifiedDate?.iv,
    orcidWorks: user.data.orcidWorks?.iv,
    expertiseAndResourceTags: user.data.expertiseAndResourceTags?.iv || [],
    expertiseAndResourceDescription:
      user.data.expertiseAndResourceDescription?.iv,
    questions: user.data.questions?.iv?.map(({ question }) => question) || [],
    avatarUrl:
      (user.data.avatar?.iv && createURL(user.data.avatar.iv)[0]) ?? undefined,
    role: user.data.role.iv === 'Hidden' ? 'Guest' : user.data.role.iv,
    responsibilities: user.data.responsibilities?.iv,
    researchInterests: user.data.researchInterests?.iv ?? undefined,
    reachOut: user.data.reachOut?.iv,
    labs: (user.data.labs?.iv || []).map((lab) => ({
      id: lab.id,
      name: lab.flatData?.name ?? '',
    })),
    connections: user.data.connections?.iv ?? undefined,
  };
};
const isUserRole = (data: string): data is Role =>
  (userRole as ReadonlyArray<string>).includes(data);

const isUserDegree = (data: string): data is UserDegree =>
  (userDegree as ReadonlyArray<string>).includes(data);

const isOrcidWorkType = (data: string): data is OrcidWorkType =>
  (orcidWorkType as ReadonlyArray<string>).includes(data);

export const parseUserToResponse = (user: UserDataObject): UserResponse => {
  const displayName = `${user.firstName} ${user.lastName}`;
  const onboarded = typeof user.onboarded === 'boolean' ? user.onboarded : true;
  const response = {
    ...user,
    displayName,
    onboarded,
  };
  delete response.connections;
  return response;
};

export const parseGraphQLUserToDataObject = (
  item: GraphQLUser,
): UserDataObject => {
  const flatTeams = item.flatData.teams || [];
  const flatAvatar = item.flatData.avatar || [];
  const flatQuestions = item.flatData.questions || [];
  const flatExpertiseAndResourceTags =
    item.flatData.expertiseAndResourceTags || [];
  const createdDate = parseDate(item.created).toISOString();

  const role =
    item.flatData.role && isUserRole(item.flatData.role)
      ? item.flatData.role
      : 'Guest';
  const teams = parseGraphQLUserTeamConnections(flatTeams || []);

  const orcid = item.flatData.orcid || undefined;
  // merge both and remove null values
  const social = Object.entries({
    ...((item.flatData.social && item.flatData.social[0]) || {}),
    orcid,
  }).reduce((acc, [k, v]) => {
    if (!v) {
      return acc;
    }
    return { ...acc, [k]: v };
  }, {} as { [key: string]: string });

  const flatLabs =
    item.flatData.labs?.reduce<LabResponse[]>((labs, lab) => {
      // skip Labs without names
      if (!lab.flatData.name) {
        return labs;
      }
      return [
        ...labs,
        {
          name: lab.flatData.name || '',
          id: lab.id,
        },
      ];
    }, []) || [];

  return {
    id: item.id,
    onboarded:
      item.flatData && typeof item.flatData.onboarded === 'boolean'
        ? item.flatData.onboarded
        : undefined,
    createdDate,
    orcid,
    firstName: item.flatData.firstName || '',
    lastName: item.flatData.lastName || '',
    biography: item.flatData.biography || undefined,
    degree:
      item.flatData.degree && isUserDegree(item.flatData.degree)
        ? item.flatData.degree
        : undefined,
    email: item.flatData.email || '',
    contactEmail: item.flatData.contactEmail || undefined,
    institution: item.flatData.institution || undefined,
    jobTitle: item.flatData.jobTitle || undefined,
    country: item.flatData.country || undefined,
    city: item.flatData.city || undefined,
    orcidWorks:
      item.flatData.orcidWorks
        ?.reduce<OrcidWork[]>((orcidWorks, orcidWork) => {
          if (orcidWork.id === null || orcidWork.lastModifiedDate === null) {
            return orcidWorks;
          }

          return [
            ...orcidWorks,
            {
              id: orcidWork.id,
              doi: orcidWork.doi || undefined,
              title: orcidWork.title || undefined,
              type:
                orcidWork.type && isOrcidWorkType(orcidWork.type)
                  ? orcidWork.type
                  : 'UNDEFINED',
              publicationDate: getOrcidWorkPublicationDate(
                orcidWork.publicationDate,
              ),
              lastModifiedDate: orcidWork.lastModifiedDate,
            },
          ];
        }, [])
        .slice(0, 5) || [],
    questions:
      flatQuestions
        .map((q) => q.question)
        .filter<string>((q): q is string => typeof q === 'string') || [],
    expertiseAndResourceTags: flatExpertiseAndResourceTags,
    expertiseAndResourceDescription:
      item.flatData.expertiseAndResourceDescription ?? undefined,
    lastModifiedDate: item.flatData.lastModifiedDate || createdDate,
    teams,
    social,
    avatarUrl: flatAvatar?.length
      ? createURL(flatAvatar.map((a) => a.id))[0]
      : undefined,
    role,
    responsibilities: item.flatData.responsibilities || undefined,
    researchInterests: item.flatData.researchInterests ?? undefined,
    reachOut: item.flatData.reachOut || undefined,
    labs: flatLabs || [],
  };
};
