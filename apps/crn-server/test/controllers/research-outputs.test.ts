import { GenericError, NotFoundError } from '@asap-hub/errors';
import { ResearchOutputResponse } from '@asap-hub/model';
import { config, SquidexGraphqlError } from '@asap-hub/squidex';
import { DocumentNode, print } from 'graphql';
import nock from 'nock';
import {
  FetchResearchOutputQuery,
  FetchResearchOutputsQuery,
} from '../../src/autogenerated-gql/graphql';
import ResearchOutputs from '../../src/controllers/research-outputs';
import {
  FETCH_RESEARCH_OUTPUT,
  FETCH_RESEARCH_OUTPUTS,
} from '../../src/queries/research-outputs.queries';
import { FETCH_RESEARCH_TAGS } from '../../src/queries/research-tags.queries';
import {
  getListResearchOutputResponse,
  getResearchOutputCreateData,
  getResearchOutputResponse,
  getResearchOutputUpdateData,
  getRestResearchOutputCreateData,
  getRestResearchOutputUpdateData,
  getSquidexResearchOutputGraphqlResponse,
  getSquidexResearchOutputsGraphqlResponse,
} from '../fixtures/research-output.fixtures';
import { getSquidexResearchTagsGraphqlResponse } from '../fixtures/research-tag.fixtures';
import { getSquidexGraphqlTeam } from '../fixtures/teams.fixtures';
import {
  getGraphqlResponseFetchUsers,
  getGraphQLUser,
} from '../fixtures/users.fixtures';
import { identity } from '../helpers/squidex';
import { getSquidexGraphqlClientMockServer } from '../mocks/squidex-graphql-client-with-server.mock';
import { getSquidexGraphqlClientMock } from '../mocks/squidex-graphql-client.mock';

describe('ResearchOutputs controller', () => {
  const squidexGraphqlClientMock = getSquidexGraphqlClientMock();
  const researchOutputs = new ResearchOutputs(squidexGraphqlClientMock);

  const squidexGraphqlClientMockServer = getSquidexGraphqlClientMockServer();
  const researchOutputsMockGraphql = new ResearchOutputs(
    squidexGraphqlClientMockServer,
  );

  beforeAll(() => {
    identity();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('Fetch by ID method', () => {
    const researchOutputId = 'some-uuid';

    test('Should fetch the research output from squidex graphql', async () => {
      const result = await researchOutputsMockGraphql.fetchById(
        researchOutputId,
      );

      expect(result).toMatchObject(getResearchOutputResponse());
    });

    test('should return the research output', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);
      const expectedResult = getResearchOutputResponse();

      expect(result).toEqual(expectedResult);
    });

    test('Should throw a Not Found error when the research output is not found', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce({
        findResearchOutputsContent: null,
      });

      await expect(researchOutputs.fetchById(researchOutputId)).rejects.toThrow(
        'Not Found',
      );
    });

    test('Should throw an error with a specific error message when the graphql client throws one', async () => {
      squidexGraphqlClientMock.request.mockRejectedValueOnce(
        new SquidexGraphqlError(
          {
            status: 521,
            errors: [
              {
                message: 'some error message',
                path: ['asdasdas'],
                locations: [],
              },
            ],
          },
          { query: 'some query' },
        ),
      );

      await expect(researchOutputs.fetchById(researchOutputId)).rejects.toThrow(
        'some error message',
      );
    });

    test('Should default team displayName to an empty string when not present', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.referencingTeamsContents![0]!.flatData.displayName =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      result.teams
        .filter((team) => !team.displayName)
        .map(({ displayName }) => expect(displayName).toEqual(''));
    });

    test('Should default type to Grant Document and title to an empty string when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.documentType =
        null;
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.title = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      expect(result.title).toEqual('');
      expect(result.documentType).toEqual('Grant Document');
    });

    test('Should default sharingStatus to Network Only when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.sharingStatus =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      expect(result.sharingStatus).toEqual('Network Only');
    });

    test('Should default asapFunded to undefined when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.asapFunded =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      expect(result.asapFunded).not.toBeDefined();
    });

    test('Should default asapFunded "Not Sure" option to undefined', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData!.asapFunded =
        'Not Sure';
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      expect(result.asapFunded).not.toBeDefined();
    });

    test('Should default usedInPublication to undefined when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.usedInAPublication =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      expect(result.usedInPublication).not.toBeDefined();
    });

    test('Should default usedInPublication "Not Sure" option to undefined', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.usedInAPublication =
        'Not Sure';
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      expect(result.usedInPublication).not.toBeDefined();
    });

    test('Should default authors to an empty array when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.authors =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      expect(result.authors).toEqual([]);
    });

    test('Should default methods to an empty array when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.methods =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      expect(result.methods).toEqual([]);
    });

    test('Should default organisms to an empty array when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.organisms =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      expect(result.organisms).toEqual([]);
    });

    test('Should default environments to an empty array when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.environments =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      expect(result.environments).toEqual([]);
    });

    test('Should skip the lab when the name is empty', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.labs = [
        {
          id: 'lab-id-1',
          flatData: {
            name: null,
          },
        },
        {
          id: 'lab-id-2',
          flatData: {
            name: 'lab name',
          },
        },
      ];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      expect(result.labs).toEqual([
        {
          id: 'lab-id-2',
          name: 'lab name',
        },
      ]);
    });

    test('Should return the research output without the team', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.referencingTeamsContents =
        [];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      const expectedResult = getResearchOutputResponse();
      expectedResult.teams = [];
      expectedResult.contactEmails = []; // as there are no referencing teams, there won't be any PMs

      expect(result).toEqual(expectedResult);
    });

    test('Should return a mix of internal and external authors', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      const squidexUser1 = {
        ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
          .items![0],
        __typename: 'Users',
      } as InternalUser;
      const squidexUser2 = {
        ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
          .items![1],
        __typename: 'Users',
      } as InternalUser;
      const externalAuthor: ExternalUser = {
        __typename: 'ExternalAuthors',
        id: '3099015c-c9ed-40fd-830a-8fe1b6ec0482',
        created: '2021-06-04T09:37:54Z',
        lastModified: '2021-06-04T09:37:54Z',
        version: 42,
        flatData: {
          name: 'test external author',
          orcid: '23423423',
        },
      };
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.authors = [
        squidexUser1,
        externalAuthor,
        squidexUser2,
      ];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      const { authors } = getResearchOutputResponse();

      const expectedAuthorsResponse: ResearchOutputResponse['authors'] = [
        authors[0]!,
        {
          id: '3099015c-c9ed-40fd-830a-8fe1b6ec0482',
          displayName: externalAuthor.flatData!.name!,
          orcid: externalAuthor.flatData!.orcid!,
        },
        authors[1]!,
      ];

      expect(result.authors).toEqual(expectedAuthorsResponse);
    });

    test('Should not return the non-onboarded authors', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      const squidexUser1 = {
        ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
          .items![0],
        __typename: 'Users',
        flatData: {
          ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
            .items![0]!.flatData,
          onboarded: false,
        },
      } as InternalUser;
      const squidexUser2 = {
        ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
          .items![1],
        __typename: 'Users',
        flatData: {
          ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
            .items![1]!.flatData,
          onboarded: true,
        },
      } as InternalUser;

      squidexGraphqlResponse.findResearchOutputsContent!.flatData.authors = [
        squidexUser1,
        squidexUser2,
      ];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetchById(researchOutputId);

      const { authors } = getResearchOutputResponse();

      const expectedAuthorsResponse: ResearchOutputResponse['authors'] = [
        authors[1]!,
      ];

      expect(result.authors).toHaveLength(1);
      expect(result.authors).toEqual(expectedAuthorsResponse);
    });

    describe('PM emails', () => {
      test('Should return a list of PM emails', async () => {
        const squidexGraphqlResponse =
          getSquidexResearchOutputGraphqlResponse();

        // Two PMs on one team
        const pm1 = getGraphQLUser();
        pm1.flatData.email = 'pm1@example.com';
        pm1.flatData.teams![0]!.role = 'Project Manager';
        const pm2 = getGraphQLUser();
        pm2.flatData.email = 'pm2@example.com';
        pm2.flatData.teams![0]!.role = 'Project Manager';
        squidexGraphqlResponse.findResearchOutputsContent!.referencingTeamsContents![0]!.referencingUsersContents! =
          [pm1, pm2];

        // And one on another team
        const pm3 = getGraphQLUser();
        pm3.flatData.email = 'pm3@example.com';
        pm3.flatData.teams![0]!.role = 'Project Manager';
        const team = getSquidexGraphqlTeam({});
        team.referencingUsersContents = [pm3];
        squidexGraphqlResponse.findResearchOutputsContent!.referencingTeamsContents!.push(
          team,
        );

        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await researchOutputs.fetchById(researchOutputId);
        expect(result.contactEmails).toEqual([
          'pm1@example.com',
          'pm2@example.com',
          'pm3@example.com',
        ]);
      });

      test('PM emails should be deduplicated', async () => {
        const squidexGraphqlResponse =
          getSquidexResearchOutputGraphqlResponse();

        // Two PMs on one team
        const pm1 = getGraphQLUser();
        pm1.flatData.email = 'pm1@example.com';
        pm1.flatData.teams![0]!.role = 'Project Manager';
        const pm2 = getGraphQLUser();
        pm2.flatData.email = 'pm2@example.com';
        pm2.flatData.teams![0]!.role = 'Project Manager';
        squidexGraphqlResponse.findResearchOutputsContent!.referencingTeamsContents![0]!.referencingUsersContents! =
          [pm1, pm2];

        // Same one on another team
        const team = getSquidexGraphqlTeam({});
        team.referencingUsersContents = [pm1];
        squidexGraphqlResponse.findResearchOutputsContent!.referencingTeamsContents!.push(
          team,
        );

        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await researchOutputs.fetchById(researchOutputId);

        // Both these PMs are duplicated in the fixture
        expect(result.contactEmails).toEqual([
          'pm1@example.com',
          'pm2@example.com',
        ]);
      });
    });

    describe('Last Updated Partial field', () => {
      test('Should default to last-modified if the last-updated-partial is not present', async () => {
        const squidexGraphqlResponse =
          getSquidexResearchOutputGraphqlResponse();
        delete squidexGraphqlResponse.findResearchOutputsContent!.flatData
          .lastUpdatedPartial;
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await researchOutputs.fetchById(researchOutputId);

        expect(result.lastUpdatedPartial).toEqual(
          squidexGraphqlResponse.findResearchOutputsContent!.lastModified,
        );
      });

      test('Should default to created-date if the last-updated-partial and last-modified are not present', async () => {
        const squidexGraphqlResponse =
          getSquidexResearchOutputGraphqlResponse();
        delete squidexGraphqlResponse.findResearchOutputsContent!.flatData
          .lastUpdatedPartial;
        delete (squidexGraphqlResponse.findResearchOutputsContent as any)
          .lastModified;
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await researchOutputs.fetchById(researchOutputId);

        expect(result.lastUpdatedPartial).toEqual(
          squidexGraphqlResponse.findResearchOutputsContent!.created,
        );
      });
    });
  });

  describe('Fetch method', () => {
    test('Should fetch the research output from squidex graphql', async () => {
      const result = await researchOutputsMockGraphql.fetch({
        take: 8,
        skip: 0,
      });

      expect(result).toMatchObject(getListResearchOutputResponse());
    });

    test('Should return an empty result when the client returns an empty array of data', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputsGraphqlResponse();
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal!.total = 0;
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal!.items = [];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetch({ take: 10, skip: 5 });

      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result when the client returns a response with query property set to null', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputsGraphqlResponse();
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetch({ take: 10, skip: 5 });

      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result when the client returns a response with items property set to null', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputsGraphqlResponse();
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal!.items =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetch({ take: 10, skip: 5 });

      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return Grant Document on ResearchOutputs', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputsGraphqlResponse();
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal!.items![0]!.flatData.documentType =
        'Grant Document';
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputs.fetch({ take: 10, skip: 0 });

      expect(result.items[0]!.documentType).toEqual('Grant Document');
    });

    describe('Parameters', () => {
      const defaultParams = {
        take: 8,
        skip: 0,
      };
      const expectedDefaultParams = {
        top: 8,
        skip: 0,
        filter: '',
        withTeams: true,
      };

      beforeEach(() => {
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          getSquidexResearchOutputsGraphqlResponse(),
        );
      });

      test('Should pass the pagination parameters as expected', async () => {
        await researchOutputs.fetch({ take: 13, skip: 7 });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            top: 13,
            skip: 7,
          },
          expect.anything(),
        );
      });

      test('Should pass the displayDrafts parameter as expected', async () => {
        await researchOutputs.fetch({ take: 13, skip: 7, includeDrafts: true });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            top: 13,
            skip: 7,
          },
          {
            includeDrafts: true,
          },
        );
      });

      test('Should pass the search parameter as a squidex filter', async () => {
        await researchOutputs.fetch({ ...defaultParams, search: 'Title' });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter:
              "(contains(data/title/iv, 'Title') or contains(data/tags/iv, 'Title'))",
          },
          expect.anything(),
        );
      });

      test('Should pass the filter parameter as a squidex filter', async () => {
        await researchOutputs.fetch({
          ...defaultParams,
          filter: ['Grant Document', 'Presentation'],
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter:
              "(data/documentType/iv eq 'Grant Document' or data/documentType/iv eq 'Presentation')",
          },
          expect.anything(),
        );
      });

      test('Should pass the object filter parameter properties as a squidex filter', async () => {
        await researchOutputs.fetch({
          ...defaultParams,
          filter: {
            documentType: 'some-type',
            title: 'some-title',
          },
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter:
              "(data/documentType/iv eq 'some-type' and data/title/iv eq 'some-title')",
          },
          expect.anything(),
        );
      });

      test('Should pass the search and filter parameter as a squidex filter', async () => {
        await researchOutputs.fetch({
          ...defaultParams,
          search: 'Title',
          filter: ['Grant Document', 'Presentation'],
        });

        const expectedFilter =
          "(data/documentType/iv eq 'Grant Document' or data/documentType/iv eq 'Presentation') " +
          "and (contains(data/title/iv, 'Title') or contains(data/tags/iv, 'Title'))";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });

      test('Should pass the search and object filter parameter as a squidex filter', async () => {
        await researchOutputs.fetch({
          ...defaultParams,
          search: 'Title',
          filter: {
            documentType: 'some-type',
          },
        });

        const expectedFilter =
          "(data/documentType/iv eq 'some-type') " +
          "and (contains(data/title/iv, 'Title') or contains(data/tags/iv, 'Title'))";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });

      test('Should break up the search parameter into multiple words and send as a squidex filter', async () => {
        await researchOutputs.fetch({ ...defaultParams, search: 'some words' });

        const expectedFilter =
          "(contains(data/title/iv, 'some') or contains(data/tags/iv, 'some') or contains(data/title/iv, 'words') or contains(data/tags/iv, 'words'))";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });

      test('Should sanitise single quote in the search parameter by doubling it and encoding to hex for the squidex filter', async () => {
        await researchOutputs.fetch({ ...defaultParams, search: "'" });

        const expectedFilter =
          "(contains(data/title/iv, '%27%27') or contains(data/tags/iv, '%27%27'))";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });

      test('Should sanitise double quotation mark in the search parameter by doubling it and encoding to hex for the squidex filter', async () => {
        await researchOutputs.fetch({ ...defaultParams, search: '"' });

        const expectedFilter =
          "(contains(data/title/iv, '%22') or contains(data/tags/iv, '%22'))";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });
    });
  });

  describe('Create and update', () => {
    beforeEach(() => {
      jest.resetAllMocks();
    });

    afterEach(() => {
      expect(nock.isDone()).toBe(true);
    });

    afterEach(() => {
      nock.cleanAll();
    });

    beforeEach(() => {
      const squidexResearchOutputEmptyGraphqlResponse: FetchResearchOutputsQuery =
        {
          queryResearchOutputsContentsWithTotal: null,
        };
      const squidexResearchTagsGraphqlResponse =
        getSquidexResearchTagsGraphqlResponse();
      const mockResponse = async (query: DocumentNode | string) => {
        if (print(query as DocumentNode) === print(FETCH_RESEARCH_OUTPUTS)) {
          return squidexResearchOutputEmptyGraphqlResponse;
        }

        if (print(query as DocumentNode) === print(FETCH_RESEARCH_TAGS)) {
          return squidexResearchTagsGraphqlResponse;
        }

        if (print(query as DocumentNode) === print(FETCH_RESEARCH_OUTPUT)) {
          return getSquidexResearchOutputGraphqlResponse();
        }
        throw new Error('Unexpected query');
      };

      squidexGraphqlClientMock.request.mockImplementation(mockResponse);
    });

    describe('Create', () => {
      test('Creating the research output should return the newly created output from squidex', async () => {
        const researchOutputRequest = getResearchOutputCreateData();
        const teamId = researchOutputRequest.teams[0];
        const researchOutputId = 'created-output-id';

        nock(config.baseUrl)
          .post(
            `/api/content/${config.appName}/research-outputs?publish=true`,
            getRestResearchOutputCreateData(),
          )
          .reply(201, { id: researchOutputId })
          .get(`/api/content/${config.appName}/teams/${teamId}`)
          .matchHeader('X-Unpublished', `true`)
          .reply(200, { data: { id: teamId, outputs: { iv: ['output-1'] } } })
          .patch(`/api/content/${config.appName}/teams/${teamId}`, {
            outputs: { iv: ['output-1', researchOutputId] },
          })
          .reply(200);

        const result = await researchOutputs.create(researchOutputRequest);
        const expectedResult = getResearchOutputResponse();
        expect(result).toEqual(expectedResult);

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledTimes(4);
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          3,
          expect.anything(),
          expect.objectContaining({
            filter: `data/entities/iv eq 'Research Output'`,
          }),
        );
      });

      test('Should throw when cannot create an external author - 400', async () => {
        nock(config.baseUrl)
          .post(
            `/api/content/${config.appName}/external-authors?publish=true`,
            {
              name: { iv: 'Chris Blue' },
            },
          )
          .reply(400);

        await expect(
          researchOutputs.create({
            ...getResearchOutputCreateData(),
            authors: [{ externalAuthorName: 'Chris Blue' }],
          }),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw a validation error when a research output with the same type and title and link already exists', async () => {
        const squidexGraphqlResponse =
          getSquidexResearchOutputsGraphqlResponse();
        squidexGraphqlClientMock.request.mockResolvedValue(
          squidexGraphqlResponse,
        );

        const researchOutputRequest = getResearchOutputCreateData();

        await expect(
          researchOutputs.create(researchOutputRequest),
        ).rejects.toThrow(
          expect.objectContaining({
            data: [
              {
                instancePath: '/title',
                keyword: 'unique',
                message: 'must be unique',
                params: {
                  type: 'string',
                },
                schemaPath: '#/properties/title/unique',
              },
              {
                instancePath: '/link',
                keyword: 'unique',
                message: 'must be unique',
                params: {
                  type: 'string',
                },
                schemaPath: '#/properties/link/unique',
              },
            ],
          }),
        );

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          expect.objectContaining({
            filter: `(data/documentType/iv eq '${researchOutputRequest.documentType}' and data/title/iv eq '${researchOutputRequest.title}')`,
          }),
          {
            includeDrafts: true,
          },
        );
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          expect.objectContaining({
            filter: `(data/link/iv eq 'http:%2F%2Fa.link')`,
          }),
          {
            includeDrafts: true,
          },
        );
      });

      test('Should throw error when a research output with the same type and title already exists', async () => {
        const squidexGraphqlEmptyResponse = {
          queryResearchOutputsContentsWithTotal: null,
        };
        const squidexGraphqlResponse =
          getSquidexResearchOutputsGraphqlResponse();
        squidexGraphqlClientMock.request
          .mockResolvedValueOnce(squidexGraphqlResponse)
          .mockResolvedValueOnce(squidexGraphqlEmptyResponse);
        const researchOutputRequest = getResearchOutputCreateData();

        await expect(
          researchOutputs.create(researchOutputRequest),
        ).rejects.toThrow(
          expect.objectContaining({
            data: [
              {
                instancePath: '/title',
                keyword: 'unique',
                message: 'must be unique',
                params: {
                  type: 'string',
                },
                schemaPath: '#/properties/title/unique',
              },
            ],
          }),
        );
      });

      test('Should throw a validation error when the selected method does not exist', async () => {
        const researchOutputInputData = getResearchOutputCreateData();
        researchOutputInputData.methods = [
          'Activity Assay',
          'non-existent-method',
        ];

        await expect(
          researchOutputs.create(researchOutputInputData),
        ).rejects.toThrow('Validation error');
      });

      test('Should throw a validation error when the selected organism does not exist', async () => {
        const researchOutputInputData = getResearchOutputCreateData();
        researchOutputInputData.organisms = ['Rat', 'non-existent-organism'];

        await expect(
          researchOutputs.create(researchOutputInputData),
        ).rejects.toThrowError(
          expect.objectContaining({
            message: 'Validation error',
            data: [
              {
                instancePath: 'organisms',
                keyword: 'invalid',
                message: 'non-existent-organism does not exist',
                params: {
                  type: 'string',
                },
                schemaPath: `#/properties/organism/invalid`,
              },
            ],
          }),
        );
      });

      test('Should throw a validation error when the selected environment does not exist', async () => {
        const researchOutputInputData = getResearchOutputCreateData();
        researchOutputInputData.environments = [
          'In Vitro',
          'non-existent-environment',
        ];

        await expect(
          researchOutputs.create(researchOutputInputData),
        ).rejects.toThrowError(
          expect.objectContaining({
            message: 'Validation error',
            data: [
              {
                instancePath: 'environments',
                keyword: 'invalid',
                message: 'non-existent-environment does not exist',
                params: {
                  type: 'string',
                },
                schemaPath: `#/properties/environment/invalid`,
              },
            ],
          }),
        );
      });

      test('Should throw a validation error when the selected subtype does not exist', async () => {
        const researchOutputInputData = getResearchOutputCreateData();
        researchOutputInputData.subtype = 'non-existent-subtype';

        await expect(
          researchOutputs.create(researchOutputInputData),
        ).rejects.toThrowError(
          expect.objectContaining({
            message: 'Validation error',
            data: [
              {
                instancePath: 'subtype',
                keyword: 'invalid',
                message: 'non-existent-subtype does not exist',
                params: {
                  type: 'string',
                },
                schemaPath: `#/properties/subtype/invalid`,
              },
            ],
          }),
        );
      });

      test('Should throw when fails to create the research output - 400', async () => {
        const researchOutputRequest = getResearchOutputCreateData();

        nock(config.baseUrl)
          .post(`/api/content/${config.appName}/research-outputs?publish=true`)
          .reply(400);

        await expect(
          researchOutputs.create(researchOutputRequest),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw when fails to create the research output - 500', async () => {
        const researchOutputRequest = getResearchOutputCreateData();
        nock(config.baseUrl)
          .post(`/api/content/${config.appName}/research-outputs?publish=true`)
          .reply(500);

        await expect(
          researchOutputs.create(researchOutputRequest),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw when a team from the research output cannot be found', async () => {
        const researchOutputRequest = getResearchOutputCreateData();

        nock(config.baseUrl)
          .post(`/api/content/${config.appName}/research-outputs?publish=true`)
          .reply(201)
          .get(
            `/api/content/${config.appName}/teams/${researchOutputRequest.teams[0]}`,
          )
          .reply(404);

        await expect(
          researchOutputs.create(researchOutputRequest),
        ).rejects.toThrow(NotFoundError);
      });

      test('Should throw when research output association cannot be made', async () => {
        const researchOutputRequest = getResearchOutputCreateData();
        const teamId = researchOutputRequest.teams[0];

        nock(config.baseUrl)
          .post(`/api/content/${config.appName}/research-outputs?publish=true`)
          .reply(201)
          .get(`/api/content/${config.appName}/teams/${teamId}`)
          .reply(200, { data: { id: teamId, outputs: { iv: ['output-1'] } } })
          .patch(`/api/content/${config.appName}/teams/${teamId}`)
          .reply(500);

        await expect(
          researchOutputs.create(researchOutputRequest),
        ).rejects.toThrow(GenericError);
      });

      test('Should associate external authors (new and existent)', async () => {
        const researchOutputRequest = {
          ...getResearchOutputCreateData(),
          authors: [
            {
              userId: 'user-1',
            },
            {
              externalAuthorId: 'author-1',
            },
            {
              externalAuthorName: 'Chris Blue',
            },
          ],
        };
        const teamId = researchOutputRequest.teams[0];
        const researchOutputId = 'created-output-id';

        nock(config.baseUrl)
          .post(
            `/api/content/${config.appName}/external-authors?publish=true`,
            {
              name: { iv: 'Chris Blue' },
            },
          )
          .reply(200, { id: 'author-2' })
          .get(`/api/content/${config.appName}/teams/${teamId}`)
          .reply(200, { data: { id: teamId } })
          .patch(`/api/content/${config.appName}/teams/${teamId}`)
          .reply(200)
          .post(
            `/api/content/${config.appName}/research-outputs?publish=true`,
            {
              ...getRestResearchOutputCreateData(),
              authors: { iv: ['user-1', 'author-1', 'author-2'] },
            },
          )
          .reply(201, { id: researchOutputId });

        const result = await researchOutputs.create(researchOutputRequest);
        const expectedResult = getResearchOutputResponse();
        expect(result).toEqual(expectedResult);
      });

      test('Should throw when cannot create an external author - 500', async () => {
        const researchOutputRequest = {
          ...getResearchOutputCreateData(),
          authors: [
            {
              userId: 'user-1',
            },
            {
              externalAuthorId: 'author-1',
            },
            {
              externalAuthorName: 'Chris Blue',
            },
          ],
        };

        nock(config.baseUrl)
          .post(`/api/content/${config.appName}/external-authors?publish=true`)
          .reply(500);

        await expect(
          researchOutputs.create(researchOutputRequest),
        ).rejects.toThrow(GenericError);

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          expect.objectContaining({
            filter: `(data/documentType/iv eq '${researchOutputRequest.documentType}' and data/title/iv eq '${researchOutputRequest.title}')`,
          }),
          {
            includeDrafts: true,
          },
        );
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          expect.objectContaining({
            filter: `(data/link/iv eq 'http:%2F%2Fa.link')`,
          }),
          {
            includeDrafts: true,
          },
        );
      });
    });

    describe('Update', () => {
      const researchOutputId = 'created-output-id';

      test('Updating the research output should return the updated output from squidex', async () => {
        const researchOutputUpdateData = getResearchOutputUpdateData();
        const teamId = researchOutputUpdateData.teams[0];

        nock(config.baseUrl)
          .patch(
            `/api/content/${config.appName}/research-outputs/${researchOutputId}`,
            {
              ...getRestResearchOutputUpdateData(),
              updatedBy: { iv: [researchOutputUpdateData.updatedBy] },
            },
          )
          .reply(201, { id: researchOutputId })
          .get(`/api/content/${config.appName}/teams/${teamId}`)
          .matchHeader('X-Unpublished', `true`)
          .reply(200, { data: { id: teamId, outputs: { iv: ['output-1'] } } })
          .patch(`/api/content/${config.appName}/teams/${teamId}`, {
            outputs: { iv: ['output-1', researchOutputId] },
          })
          .reply(200);

        const result = await researchOutputs.update(
          researchOutputId,
          researchOutputUpdateData,
        );

        const expectedResult = getResearchOutputResponse();
        expect(result).toEqual(expectedResult);
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledTimes(4);
      });

      test('Should throw when cannot create an external author - 400', async () => {
        nock(config.baseUrl)
          .post(
            `/api/content/${config.appName}/external-authors?publish=true`,
            {
              name: { iv: 'Chris Blue' },
            },
          )
          .reply(400);

        await expect(
          researchOutputs.update(researchOutputId, {
            ...getResearchOutputUpdateData(),
            authors: [{ externalAuthorName: 'Chris Blue' }],
          }),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw a validation error when a research output with the same type and title and link already exists', async () => {
        const squidexGraphqlResponse =
          getSquidexResearchOutputsGraphqlResponse();
        squidexGraphqlClientMock.request.mockResolvedValue(
          squidexGraphqlResponse,
        );

        const researchOutputRequest = getResearchOutputUpdateData();

        await expect(
          researchOutputs.update(researchOutputId, researchOutputRequest),
        ).rejects.toThrow(
          expect.objectContaining({
            data: [
              {
                instancePath: '/title',
                keyword: 'unique',
                message: 'must be unique',
                params: {
                  type: 'string',
                },
                schemaPath: '#/properties/title/unique',
              },
              {
                instancePath: '/link',
                keyword: 'unique',
                message: 'must be unique',
                params: {
                  type: 'string',
                },
                schemaPath: '#/properties/link/unique',
              },
            ],
          }),
        );

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          expect.objectContaining({
            filter: `(data/documentType/iv eq '${researchOutputRequest.documentType}' and data/title/iv eq '${researchOutputRequest.title}')`,
          }),
          {
            includeDrafts: true,
          },
        );
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          expect.objectContaining({
            filter: `(data/link/iv eq 'http:%2F%2Fa.link')`,
          }),
          {
            includeDrafts: true,
          },
        );
      });

      test('Should throw a validation error when the selected method does not exist', async () => {
        const researchOutputInputData = getResearchOutputUpdateData();
        researchOutputInputData.methods = [
          'Activity Assay',
          'non-existent-method',
        ];

        await expect(
          researchOutputs.update(researchOutputId, researchOutputInputData),
        ).rejects.toThrow('Validation error');
      });

      test('Should throw when fails to update the research output - 400', async () => {
        const researchOutputRequest = getResearchOutputUpdateData();

        nock(config.baseUrl)
          .patch(
            `/api/content/${config.appName}/research-outputs/${researchOutputId}`,
          )
          .reply(400);

        await expect(
          researchOutputs.update(researchOutputId, researchOutputRequest),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw when fails to update the research output - 500', async () => {
        const researchOutputRequest = getResearchOutputUpdateData();
        nock(config.baseUrl)
          .patch(
            `/api/content/${config.appName}/research-outputs/${researchOutputId}`,
          )
          .reply(500);

        await expect(
          researchOutputs.update(researchOutputId, researchOutputRequest),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw when the research output cannot be found', async () => {
        const researchOutputRequest = getResearchOutputUpdateData();

        nock(config.baseUrl)
          .patch(
            `/api/content/${config.appName}/research-outputs/${researchOutputId}`,
          )
          .reply(404);

        await expect(
          researchOutputs.update(researchOutputId, researchOutputRequest),
        ).rejects.toThrow(NotFoundError);
      });

      test('Should throw when a team from the research output cannot be found', async () => {
        const researchOutputRequest = getResearchOutputUpdateData();

        nock(config.baseUrl)
          .patch(
            `/api/content/${config.appName}/research-outputs/${researchOutputId}`,
          )
          .reply(201)
          .get(
            `/api/content/${config.appName}/teams/${researchOutputRequest.teams[0]}`,
          )
          .reply(404);

        await expect(
          researchOutputs.update(researchOutputId, researchOutputRequest),
        ).rejects.toThrow(NotFoundError);
      });

      test('Should throw when research output to team association cannot be made', async () => {
        const researchOutputRequest = getResearchOutputUpdateData();
        const teamId = researchOutputRequest.teams[0];

        nock(config.baseUrl)
          .patch(
            `/api/content/${config.appName}/research-outputs/${researchOutputId}`,
          )
          .reply(201)
          .get(`/api/content/${config.appName}/teams/${teamId}`)
          .reply(200, { data: { id: teamId, outputs: { iv: ['output-1'] } } })
          .patch(`/api/content/${config.appName}/teams/${teamId}`)
          .reply(500);

        await expect(
          researchOutputs.update(researchOutputId, researchOutputRequest),
        ).rejects.toThrow(GenericError);
      });

      test('Should associate external authors (new and existent)', async () => {
        const researchOutputRequest = {
          ...getResearchOutputUpdateData(),
          authors: [
            {
              userId: 'user-1',
            },
            {
              externalAuthorId: 'author-1',
            },
            {
              externalAuthorName: 'Chris Blue',
            },
          ],
        };
        const teamId = researchOutputRequest.teams[0];
        const researchOutputId = 'created-output-id';

        nock(config.baseUrl)
          .post(
            `/api/content/${config.appName}/external-authors?publish=true`,
            {
              name: { iv: 'Chris Blue' },
            },
          )
          .reply(200, { id: 'author-2' })
          .get(`/api/content/${config.appName}/teams/${teamId}`)
          .reply(200, { data: { id: teamId } })
          .patch(`/api/content/${config.appName}/teams/${teamId}`)
          .reply(200)
          .patch(
            `/api/content/${config.appName}/research-outputs/${researchOutputId}`,
            {
              ...getRestResearchOutputUpdateData(),
              authors: { iv: ['user-1', 'author-1', 'author-2'] },
            },
          )
          .reply(201, { id: researchOutputId });

        const result = await researchOutputs.update(
          researchOutputId,
          researchOutputRequest,
        );

        const expectedResult = getResearchOutputResponse();
        expect(result).toEqual(expectedResult);
      });

      test('Should throw when cannot create an external author - 500', async () => {
        const researchOutputRequest = {
          ...getResearchOutputUpdateData(),
          authors: [
            {
              userId: 'user-1',
            },
            {
              externalAuthorId: 'author-1',
            },
            {
              externalAuthorName: 'Chris Blue',
            },
          ],
        };

        nock(config.baseUrl)
          .post(`/api/content/${config.appName}/external-authors?publish=true`)
          .reply(500);

        await expect(
          researchOutputs.update(researchOutputId, researchOutputRequest),
        ).rejects.toThrow(GenericError);

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          expect.objectContaining({
            filter: `(data/documentType/iv eq '${researchOutputRequest.documentType}' and data/title/iv eq '${researchOutputRequest.title}')`,
          }),
          {
            includeDrafts: true,
          },
        );
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          expect.objectContaining({
            filter: `(data/link/iv eq 'http:%2F%2Fa.link')`,
          }),
          {
            includeDrafts: true,
          },
        );
      });

      test('Should throw error when a research output with the same type and title already exists', async () => {
        const squidexGraphqlEmptyResponse = {
          queryResearchOutputsContentsWithTotal: null,
        };
        const squidexGraphqlResponse =
          getSquidexResearchOutputsGraphqlResponse();
        squidexGraphqlClientMock.request
          .mockResolvedValueOnce(squidexGraphqlResponse)
          .mockResolvedValueOnce(squidexGraphqlEmptyResponse);
        const researchOutputRequest = getResearchOutputUpdateData();

        await expect(
          researchOutputs.update(researchOutputId, researchOutputRequest),
        ).rejects.toThrow(
          expect.objectContaining({
            data: [
              {
                instancePath: '/title',
                keyword: 'unique',
                message: 'must be unique',
                params: {
                  type: 'string',
                },
                schemaPath: '#/properties/title/unique',
              },
            ],
          }),
        );
      });
    });
  });
});

type Author = NonNullable<
  NonNullable<
    FetchResearchOutputQuery['findResearchOutputsContent']
  >['flatData']['authors']
>[number];
type InternalUser = Extract<Author, { __typename: 'Users' }>;
type ExternalUser = Extract<Author, { __typename: 'ExternalAuthors' }>;
