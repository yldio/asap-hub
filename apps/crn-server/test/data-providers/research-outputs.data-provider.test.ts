import { GenericError, NotFoundError } from '@asap-hub/errors';
import { ResearchOutputDataObject } from '@asap-hub/model';
import {
  RestResearchOutput,
  SquidexGraphqlError,
  SquidexRest,
} from '@asap-hub/squidex';
import matches from 'lodash.matches';
import nock from 'nock';
import { FetchResearchOutputQuery } from '../../src/autogenerated-gql/graphql';
import { appName, baseUrl } from '../../src/config';
import {
  makeDraftFilter,
  makeODataFilter,
  ResearchOutputSquidexDataProvider,
} from '../../src/data-providers/research-outputs.data-provider';
import { getAuthToken } from '../../src/utils/auth';
import {
  getListResearchOutputDataObject,
  getResearchOutputCreateDataObject,
  getResearchOutputDataObject,
  getResearchOutputUpdateDataObject,
  getRestResearchOutputCreateData,
  getRestResearchOutputUpdateData,
  getSquidexResearchOutputGraphqlResponse,
  getSquidexResearchOutputsGraphqlResponse,
} from '../fixtures/research-output.fixtures';
import { getSquidexGraphqlTeam } from '../fixtures/teams.fixtures';
import {
  getGraphqlResponseFetchUsers,
  getGraphQLUser,
} from '../fixtures/users.fixtures';
import { identity } from '../helpers/squidex';
import { getSquidexGraphqlClientMockServer } from '../mocks/squidex-graphql-client-with-server.mock';
import { getSquidexGraphqlClientMock } from '../mocks/squidex-graphql-client.mock';

describe('ResearchOutputs data provider', () => {
  const squidexGraphqlClientMock = getSquidexGraphqlClientMock();

  const researchOutputRestClient = new SquidexRest<RestResearchOutput>(
    getAuthToken,
    'research-outputs',
    { appName, baseUrl },
  );
  const researchOutputDataProvider = new ResearchOutputSquidexDataProvider(
    squidexGraphqlClientMock,
    researchOutputRestClient,
  );

  const squidexGraphqlClientMockServer = getSquidexGraphqlClientMockServer();
  const researchOutputDataProviderMockGraphql =
    new ResearchOutputSquidexDataProvider(
      squidexGraphqlClientMockServer,
      researchOutputRestClient,
    );

  beforeAll(() => {
    identity();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('Fetch by ID method', () => {
    const researchOutputId = 'some-uuid';

    test('Should fetch the research output from squidex graphql', async () => {
      const result = await researchOutputDataProviderMockGraphql.fetchById(
        researchOutputId,
      );

      expect(result).toMatchObject(getResearchOutputDataObject());
    });

    test('should return the research output', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );
      const expectedResult = getResearchOutputDataObject();

      expect(result).toEqual(expectedResult);
    });

    test('Should throw a Not Found error when the research output is not found', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce({
        findResearchOutputsContent: null,
      });

      await expect(
        researchOutputDataProvider.fetchById(researchOutputId),
      ).rejects.toThrow('Not Found');
    });

    test('Should throw an error with a specific error message when the graphql client throws one', async () => {
      squidexGraphqlClientMock.request.mockRejectedValueOnce(
        new SquidexGraphqlError(
          {
            status: 521,
            errors: [
              {
                message: 'some error message',
                path: ['asdasdas'],
                locations: [],
              },
            ],
          },
          { query: 'some query' },
        ),
      );

      await expect(
        researchOutputDataProvider.fetchById(researchOutputId),
      ).rejects.toThrow('some error message');
    });

    test('Should default missing team reference to an empty array of teams', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.teams =
        undefined;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.teams).toEqual([]);
    });

    test('Should default team displayName to an empty string when not present', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.teams![0]!.flatData.displayName =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      result!.teams
        .filter((team) => !team.displayName)
        .map(({ displayName }) => expect(displayName).toEqual(''));
    });

    test('Should default type to Grant Document and title to an empty string when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.documentType =
        null;
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.title = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.title).toEqual('');
      expect(result!.documentType).toEqual('Grant Document');
    });

    test('Should default sharingStatus to Network Only when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.sharingStatus =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.sharingStatus).toEqual('Network Only');
    });

    test('Should default asapFunded to undefined when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.asapFunded =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.asapFunded).not.toBeDefined();
    });

    test('Should default asapFunded "Not Sure" option to undefined', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData!.asapFunded =
        'Not Sure';
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.asapFunded).not.toBeDefined();
    });

    test('Should default usedInPublication to undefined when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.usedInAPublication =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.usedInPublication).not.toBeDefined();
    });

    test('Should default usedInPublication "Not Sure" option to undefined', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.usedInAPublication =
        'Not Sure';
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.usedInPublication).not.toBeDefined();
    });

    test('Should default authors to an empty array when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.authors =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.authors).toEqual([]);
    });

    test('Should default related research to an empty array when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.relatedResearch =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.relatedResearch).toEqual([]);
    });

    test('Should default methods to an empty array when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.methods =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.methods).toEqual([]);
    });

    test('Should default organisms to an empty array when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.organisms =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.organisms).toEqual([]);
    });

    test('Should default environments to an empty array when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.environments =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.environments).toEqual([]);
    });

    test('Should skip the lab when the name is empty', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.labs = [
        {
          id: 'lab-id-1',
          flatData: {
            name: null,
          },
        },
        {
          id: 'lab-id-2',
          flatData: {
            name: 'lab name',
          },
        },
      ];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.labs).toEqual([
        {
          id: 'lab-id-2',
          name: 'lab name',
        },
      ]);
    });

    test('Should return the research output without the team', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.teams = [];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      const expectedResult = getResearchOutputDataObject();
      expectedResult.teams = [];
      expectedResult.contactEmails = []; // as there are no referencing teams, there won't be any PMs

      expect(result).toEqual(expectedResult);
    });

    test('Should return a mix of internal and external authors', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      const squidexUser1 = {
        ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
          .items![0],
        __typename: 'Users',
      } as InternalUser;
      const squidexUser2 = {
        ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
          .items![1],
        __typename: 'Users',
      } as InternalUser;
      const externalAuthor: ExternalUser = {
        __typename: 'ExternalAuthors',
        id: '3099015c-c9ed-40fd-830a-8fe1b6ec0482',
        created: '2021-06-04T09:37:54Z',
        lastModified: '2021-06-04T09:37:54Z',
        version: 42,
        flatData: {
          name: 'test external author',
          orcid: '23423423',
        },
      };
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.authors = [
        squidexUser1,
        externalAuthor,
        squidexUser2,
      ];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      const { authors } = getResearchOutputDataObject();

      const expectedAuthorsResponse: ResearchOutputDataObject['authors'] = [
        authors[0]!,
        {
          id: '3099015c-c9ed-40fd-830a-8fe1b6ec0482',
          displayName: externalAuthor.flatData!.name!,
          orcid: externalAuthor.flatData!.orcid!,
        },
        authors[1]!,
      ];

      expect(result!.authors).toEqual(expectedAuthorsResponse);
    });

    test('Should not return the non-onboarded authors', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      const squidexUser1 = {
        ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
          .items![0],
        __typename: 'Users',
        flatData: {
          ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
            .items![0]!.flatData,
          onboarded: false,
        },
      } as InternalUser;
      const squidexUser2 = {
        ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
          .items![1],
        __typename: 'Users',
        flatData: {
          ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
            .items![1]!.flatData,
          onboarded: true,
        },
      } as InternalUser;

      squidexGraphqlResponse.findResearchOutputsContent!.flatData.authors = [
        squidexUser1,
        squidexUser2,
      ];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      const { authors } = getResearchOutputDataObject();

      const expectedAuthorsResponse: ResearchOutputDataObject['authors'] = [
        authors[1]!,
      ];

      expect(result!.authors).toHaveLength(1);
      expect(result!.authors).toEqual(expectedAuthorsResponse);
    });

    describe('PM emails', () => {
      test('Should return a list of PM emails', async () => {
        const squidexGraphqlResponse =
          getSquidexResearchOutputGraphqlResponse();

        // Two PMs on one team
        const pm1 = getGraphQLUser();
        pm1.flatData.email = 'pm1@example.com';
        pm1.flatData.teams![0]!.role = 'Project Manager';
        const pm2 = getGraphQLUser();
        pm2.flatData.email = 'pm2@example.com';
        pm2.flatData.teams![0]!.role = 'Project Manager';
        squidexGraphqlResponse.findResearchOutputsContent!.flatData.teams![0]!.referencingUsersContents! =
          [pm1, pm2];

        // And one on another team
        const pm3 = getGraphQLUser();
        pm3.flatData.email = 'pm3@example.com';
        pm3.flatData.teams![0]!.role = 'Project Manager';
        const team = getSquidexGraphqlTeam({});
        team.referencingUsersContents = [pm3];
        squidexGraphqlResponse.findResearchOutputsContent!.flatData.teams!.push(
          team,
        );

        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await researchOutputDataProvider.fetchById(
          researchOutputId,
        );
        expect(result!.contactEmails).toEqual([
          'pm1@example.com',
          'pm2@example.com',
          'pm3@example.com',
        ]);
      });

      test('PM emails should be deduplicated', async () => {
        const squidexGraphqlResponse =
          getSquidexResearchOutputGraphqlResponse();

        // Two PMs on one team
        const pm1 = getGraphQLUser();
        pm1.flatData.email = 'pm1@example.com';
        pm1.flatData.teams![0]!.role = 'Project Manager';
        const pm2 = getGraphQLUser();
        pm2.flatData.email = 'pm2@example.com';
        pm2.flatData.teams![0]!.role = 'Project Manager';
        squidexGraphqlResponse.findResearchOutputsContent!.flatData.teams![0]!.referencingUsersContents! =
          [pm1, pm2];

        // Same one on another team
        const team = getSquidexGraphqlTeam({});
        team.referencingUsersContents = [pm1];
        squidexGraphqlResponse.findResearchOutputsContent!.flatData.teams!.push(
          team,
        );

        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await researchOutputDataProvider.fetchById(
          researchOutputId,
        );

        // Both these PMs are duplicated in the fixture
        expect(result!.contactEmails).toEqual([
          'pm1@example.com',
          'pm2@example.com',
        ]);
      });
    });

    describe('Last Updated Partial field', () => {
      test('Should default to last-modified if the last-updated-partial is not present', async () => {
        const squidexGraphqlResponse =
          getSquidexResearchOutputGraphqlResponse();
        delete squidexGraphqlResponse.findResearchOutputsContent!.flatData
          .lastUpdatedPartial;
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await researchOutputDataProvider.fetchById(
          researchOutputId,
        );

        expect(result!.lastUpdatedPartial).toEqual(
          squidexGraphqlResponse.findResearchOutputsContent!.lastModified,
        );
      });

      test('Should default to created-date if the last-updated-partial and last-modified are not present', async () => {
        const squidexGraphqlResponse =
          getSquidexResearchOutputGraphqlResponse();
        delete squidexGraphqlResponse.findResearchOutputsContent!.flatData
          .lastUpdatedPartial;
        delete (squidexGraphqlResponse.findResearchOutputsContent as any)
          .lastModified;
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await researchOutputDataProvider.fetchById(
          researchOutputId,
        );

        expect(result!.lastUpdatedPartial).toEqual(
          squidexGraphqlResponse.findResearchOutputsContent!.created,
        );
      });
    });
  });

  describe('Fetch method', () => {
    test('Should fetch the research output from squidex graphql', async () => {
      const result = await researchOutputDataProviderMockGraphql.fetch({
        take: 8,
        skip: 0,
      });

      expect(result).toMatchObject(getListResearchOutputDataObject());
    });

    test('Should return an empty result when the client returns an empty array of data', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputsGraphqlResponse();
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal!.total = 0;
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal!.items = [];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetch({
        take: 10,
        skip: 5,
      });

      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result when the client returns a response with query property set to null', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputsGraphqlResponse();
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetch({
        take: 10,
        skip: 5,
      });

      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result when the client returns a response with items property set to null', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputsGraphqlResponse();
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal!.items =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetch({
        take: 10,
        skip: 5,
      });

      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return Grant Document on ResearchOutputs', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputsGraphqlResponse();
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal!.items![0]!.flatData.documentType =
        'Grant Document';
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetch({
        take: 10,
        skip: 0,
      });

      expect(result.items[0]!.documentType).toEqual('Grant Document');
    });

    describe('Parameters', () => {
      const defaultParams = {
        take: 8,
        skip: 0,
      };
      const expectedDefaultParams = {
        top: 8,
        skip: 0,
        filter: '',
        withTeams: true,
      };

      beforeEach(() => {
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          getSquidexResearchOutputsGraphqlResponse(),
        );
      });

      test('Should pass the pagination parameters as expected', async () => {
        await researchOutputDataProvider.fetch({ take: 13, skip: 7 });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            top: 13,
            skip: 7,
          },
          expect.anything(),
        );
      });

      test('Should pass the displayDrafts parameter as expected', async () => {
        await researchOutputDataProvider.fetch({
          take: 13,
          skip: 7,
          includeDrafts: true,
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            top: 13,
            skip: 7,
          },
          {
            includeDrafts: true,
          },
        );
      });

      test('Should pass the search parameter as a squidex filter', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          search: 'Title',
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter:
              "((contains(data/title/iv,'Title')) or (contains(data/tags/iv,'Title')))",
          },
          expect.anything(),
        );
      });

      test('Should pass the object filter parameter properties as a squidex filter', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          filter: {
            documentType: 'some-type',
            title: 'some-title',
          },
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter:
              "data/documentType/iv eq 'some-type' and data/title/iv eq 'some-title'",
          },
          expect.anything(),
        );
      });

      test('Should pass the object filter parameter properties with an array as a squidex filter', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          filter: {
            documentType: ['some-type-1', 'some-type-2'],
            title: 'some-title',
          },
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter:
              "((data/documentType/iv eq 'some-type-1') or (data/documentType/iv eq 'some-type-2')) and data/title/iv eq 'some-title'",
          },
          expect.anything(),
        );
      });

      test('Should pass the object filter parameter properties with `status:draft` as a squidex filter', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          filter: {
            status: 'draft',
            teamId: 'team-id-0',
            workingGroupId: 'workingGroup-id-0',
          },
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter:
              "status eq 'Draft' and data/teams/iv in ['team-id-0'] and data/workingGroups/iv in ['workingGroup-id-0']",
          },
          expect.anything(),
        );
      });

      test('Should pass the search and filter parameter as a squidex filter', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          search: 'Title',
          filter: {
            documentType: ['Grant Document', 'Presentation'],
          },
        });

        const expectedFilter =
          "((data/documentType/iv eq 'Grant Document') or (data/documentType/iv eq 'Presentation')) " +
          "and ((contains(data/title/iv,'Title')) or (contains(data/tags/iv,'Title')))";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });

      test('Should break up the search parameter into multiple words and send as a squidex filter', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          search: 'some words',
        });

        const expectedFilter =
          "((contains(data/title/iv,'some')) or (contains(data/tags/iv,'some')) or (contains(data/title/iv,'words')) or (contains(data/tags/iv,'words')))";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });

      test('Should sanitise single quote in the search parameter by doubling it for the squidex filter', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          search: "'",
        });

        const expectedFilter =
          "((contains(data/title/iv,'''')) or (contains(data/tags/iv,'''')))";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });

      test('Should sanitise double quotation mark in the search parameter by escaping it', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          search: '"',
        });

        const expectedFilter =
          "((contains(data/title/iv,'\"')) or (contains(data/tags/iv,'\"')))";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });
    });
  });

  describe('Create and update', () => {
    afterEach(() => {
      expect(nock.isDone()).toBe(true);
    });

    afterEach(() => {
      nock.cleanAll();
    });

    describe('Create', () => {
      test('Should send the correct requests to Squidex and return its ID', async () => {
        const researchOutputRequest = getResearchOutputCreateDataObject();
        const researchOutputId = 'created-output-id';

        nock(baseUrl)
          // Create the ResearchOutput
          .post(
            `/api/content/${appName}/research-outputs?publish=true`,
            getRestResearchOutputCreateData(),
          )
          .reply(201, { id: researchOutputId });

        const result = await researchOutputDataProvider.create(
          researchOutputRequest,
        );
        expect(result).toEqual(researchOutputId);
      });

      test('Should default the missing subtype to an empty array', async () => {
        const researchOutputRequest = getResearchOutputCreateDataObject();
        researchOutputRequest.subtypeId = undefined;
        const researchOutputId = 'created-output-id';

        nock(baseUrl)
          .post(
            `/api/content/${appName}/research-outputs?publish=true`,
            matches({
              subtype: { iv: [] },
            }),
          )
          .reply(201, { id: researchOutputId });

        await researchOutputDataProvider.create(researchOutputRequest);
      });

      test('Should use the correct IDs for authors', async () => {
        const researchOutputRequest = getResearchOutputCreateDataObject();
        researchOutputRequest.authors = [
          {
            externalAuthorId: 'some-external-user-id',
          },
          { userId: 'some-user-id' },
        ];
        const researchOutputId = 'created-output-id';

        nock(baseUrl)
          .post(
            `/api/content/${appName}/research-outputs?publish=true`,
            matches({
              authors: { iv: ['some-external-user-id', 'some-user-id'] },
            }),
          )
          .reply(201, { id: researchOutputId });

        await researchOutputDataProvider.create(researchOutputRequest);
      });

      test('Should throw when fails to create the research output - 400', async () => {
        const researchOutputRequest = getResearchOutputCreateDataObject();

        nock(baseUrl)
          .post(`/api/content/${appName}/research-outputs?publish=true`)
          .reply(400);

        await expect(
          researchOutputDataProvider.create(researchOutputRequest),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw when fails to create the research output - 500', async () => {
        const researchOutputRequest = getResearchOutputCreateDataObject();
        nock(baseUrl)
          .post(`/api/content/${appName}/research-outputs?publish=true`)
          .reply(500);

        await expect(
          researchOutputDataProvider.create(researchOutputRequest),
        ).rejects.toThrow(GenericError);
      });
    });

    describe('Update', () => {
      const researchOutputId = 'updated-output-id';

      test('Should update the existing research-output and return its ID', async () => {
        const researchOutputUpdateData = getResearchOutputUpdateDataObject();

        const restResearchOutputUpdateData = getRestResearchOutputUpdateData();
        nock(baseUrl)
          .patch(
            `/api/content/${appName}/research-outputs/${researchOutputId}`,
            {
              ...restResearchOutputUpdateData,
              updatedBy: { iv: [researchOutputUpdateData.updatedBy] },
            },
          )
          .reply(201, { id: researchOutputId });

        const result = await researchOutputDataProvider.update(
          researchOutputId,
          researchOutputUpdateData,
          { publish: false },
        );
        expect(result).toEqual(researchOutputId);
      });

      test('Should default to not publish the existing research-output and return its ID', async () => {
        const researchOutputUpdateData = getResearchOutputUpdateDataObject();

        const restResearchOutputUpdateData = getRestResearchOutputUpdateData();
        nock(baseUrl)
          .patch(
            `/api/content/${appName}/research-outputs/${researchOutputId}`,
            {
              ...restResearchOutputUpdateData,
              updatedBy: { iv: [researchOutputUpdateData.updatedBy] },
            },
          )
          .reply(201, { id: researchOutputId });

        const result = await researchOutputDataProvider.update(
          researchOutputId,
          researchOutputUpdateData,
        );
        expect(result).toEqual(researchOutputId);
      });

      test('Should publish a draft research-output and return its ID', async () => {
        const researchOutputUpdateData = getResearchOutputUpdateDataObject();

        const restResearchOutputUpdateData = getRestResearchOutputUpdateData();

        nock(baseUrl)
          .put(
            `/api/content/${appName}/research-outputs/${researchOutputId}/status`,
            {
              status: 'Published',
            },
          )
          .reply(200, { id: researchOutputId });

        nock(baseUrl)
          .patch(
            `/api/content/${appName}/research-outputs/${researchOutputId}`,
            {
              ...restResearchOutputUpdateData,
              updatedBy: { iv: [researchOutputUpdateData.updatedBy] },
            },
          )
          .reply(201, { id: researchOutputId });

        const result = await researchOutputDataProvider.update(
          researchOutputId,
          researchOutputUpdateData,
          { publish: true },
        );

        expect(result).toEqual(researchOutputId);
      });

      test('Should throw when fails to update the research output - 400', async () => {
        const researchOutputRequest = getResearchOutputUpdateDataObject();

        nock(baseUrl)
          .patch(`/api/content/${appName}/research-outputs/${researchOutputId}`)
          .reply(400);

        await expect(
          researchOutputDataProvider.update(
            researchOutputId,
            researchOutputRequest,
            { publish: false },
          ),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw when fails to update the research output - 500', async () => {
        const researchOutputRequest = getResearchOutputUpdateDataObject();
        nock(baseUrl)
          .patch(`/api/content/${appName}/research-outputs/${researchOutputId}`)
          .reply(500);

        await expect(
          researchOutputDataProvider.update(
            researchOutputId,
            researchOutputRequest,
            { publish: false },
          ),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw when the research output cannot be found', async () => {
        const researchOutputRequest = getResearchOutputUpdateDataObject();

        nock(baseUrl)
          .patch(`/api/content/${appName}/research-outputs/${researchOutputId}`)
          .reply(404);

        await expect(
          researchOutputDataProvider.update(
            researchOutputId,
            researchOutputRequest,
            { publish: false },
          ),
        ).rejects.toThrow(NotFoundError);
      });
    });
  });
});

describe('makeODataFilter', () => {
  test('converts the object to a format accepted by OData', () => {
    expect(
      makeODataFilter({
        title: 'some title',
        link: 'https://somelink.com',
        documentType: ['a', 'b', 'c'],
      }),
    ).toStrictEqual([
      { 'data/title/iv': 'some title' },
      { 'data/link/iv': 'https://somelink.com' },
      {
        or: [
          { 'data/documentType/iv': 'a' },
          { 'data/documentType/iv': 'b' },
          { 'data/documentType/iv': 'c' },
        ],
      },
    ]);
  });

  test('when the filter is not defined returns null', () => {
    expect(makeODataFilter()).toBeNull();
    expect(makeODataFilter(undefined)).toBeNull();
  });
});

describe('makeDraftFilter', () => {
  test('returns draft query', () => {
    expect(makeDraftFilter({ status: 'draft' })).toBe("status eq 'Draft'");
  });

  test('returns draft for team query', () => {
    expect(makeDraftFilter({ status: 'draft', teamId: 'team-id-0' })).toBe(
      "status eq 'Draft' and data/teams/iv in ['team-id-0']",
    );
  });

  test('returns draft for working group query', () => {
    expect(
      makeDraftFilter({ status: 'draft', workingGroupId: 'workingGroup-id-0' }),
    ).toBe(
      "status eq 'Draft' and data/workingGroups/iv in ['workingGroup-id-0']",
    );
  });

  test('returns draft for team and working group query', () => {
    expect(
      makeDraftFilter({
        status: 'draft',
        teamId: 'team-id-0',
        workingGroupId: 'workingGroup-id-0',
      }),
    ).toBe(
      "status eq 'Draft' and data/teams/iv in ['team-id-0'] and data/workingGroups/iv in ['workingGroup-id-0']",
    );
  });
});

type Author = NonNullable<
  NonNullable<
    FetchResearchOutputQuery['findResearchOutputsContent']
  >['flatData']['authors']
>[number];
type InternalUser = Extract<Author, { __typename: 'Users' }>;
type ExternalUser = Extract<Author, { __typename: 'ExternalAuthors' }>;
