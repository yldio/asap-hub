import nock from 'nock';
import matches from 'lodash.matches';
import { ResearchOutputDataObject } from '@asap-hub/model';
import {
  RestResearchOutput,
  RestTeam,
  SquidexGraphqlError,
  SquidexRest,
} from '@asap-hub/squidex';
import { FetchResearchOutputQuery } from '../../src/autogenerated-gql/graphql';
import { appName, baseUrl } from '../../src/config';
import { ResearchOutputSquidexDataProvider } from '../../src/data-providers/research-outputs.data-provider';
import { getAuthToken } from '../../src/utils/auth';
import {
  getListResearchOutputDataObject,
  getResearchOutputCreateDataObject,
  getResearchOutputDataObject,
  getResearchOutputUpdateDataObject,
  getRestResearchOutputCreateData,
  getRestResearchOutputUpdateData,
  getSquidexResearchOutputGraphqlResponse,
  getSquidexResearchOutputsGraphqlResponse,
} from '../fixtures/research-output.fixtures';
import { getSquidexGraphqlTeam } from '../fixtures/teams.fixtures';
import {
  getGraphqlResponseFetchUsers,
  getGraphQLUser,
} from '../fixtures/users.fixtures';
import { identity } from '../helpers/squidex';
import { getSquidexGraphqlClientMockServer } from '../mocks/squidex-graphql-client-with-server.mock';
import { getSquidexGraphqlClientMock } from '../mocks/squidex-graphql-client.mock';
import { GenericError, NotFoundError } from '@asap-hub/errors';

describe('ResearchOutputs data provider', () => {
  const squidexGraphqlClientMock = getSquidexGraphqlClientMock();

  const researchOutputRestClient = new SquidexRest<RestResearchOutput>(
    getAuthToken,
    'research-outputs',
    { appName, baseUrl },
  );
  const teamRestclient = new SquidexRest<RestTeam>(getAuthToken, 'teams', {
    appName,
    baseUrl,
  });
  const researchOutputDataProvider = new ResearchOutputSquidexDataProvider(
    squidexGraphqlClientMock,
    researchOutputRestClient,
    teamRestclient,
  );

  const squidexGraphqlClientMockServer = getSquidexGraphqlClientMockServer();
  const researchOutputDataProviderMockGraphql =
    new ResearchOutputSquidexDataProvider(
      squidexGraphqlClientMockServer,
      researchOutputRestClient,
      teamRestclient,
    );

  beforeAll(() => {
    identity();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('Fetch by ID method', () => {
    const researchOutputId = 'some-uuid';

    test('Should fetch the research output from squidex graphql', async () => {
      const result = await researchOutputDataProviderMockGraphql.fetchById(
        researchOutputId,
      );

      expect(result).toMatchObject(getResearchOutputDataObject());
    });

    test('should return the research output', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );
      const expectedResult = getResearchOutputDataObject();

      expect(result).toEqual(expectedResult);
    });

    test('Should throw a Not Found error when the research output is not found', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce({
        findResearchOutputsContent: null,
      });

      await expect(
        researchOutputDataProvider.fetchById(researchOutputId),
      ).rejects.toThrow('Not Found');
    });

    test('Should throw an error with a specific error message when the graphql client throws one', async () => {
      squidexGraphqlClientMock.request.mockRejectedValueOnce(
        new SquidexGraphqlError(
          {
            status: 521,
            errors: [
              {
                message: 'some error message',
                path: ['asdasdas'],
                locations: [],
              },
            ],
          },
          { query: 'some query' },
        ),
      );

      await expect(
        researchOutputDataProvider.fetchById(researchOutputId),
      ).rejects.toThrow('some error message');
    });

    test('Should default missing team reference to an empty array of teams', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.referencingTeamsContents =
        undefined;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.teams).toEqual([]);
    });

    test('Should default team displayName to an empty string when not present', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.referencingTeamsContents![0]!.flatData.displayName =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      result!.teams
        .filter((team) => !team.displayName)
        .map(({ displayName }) => expect(displayName).toEqual(''));
    });

    test('Should default type to Grant Document and title to an empty string when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.documentType =
        null;
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.title = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.title).toEqual('');
      expect(result!.documentType).toEqual('Grant Document');
    });

    test('Should default sharingStatus to Network Only when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.sharingStatus =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.sharingStatus).toEqual('Network Only');
    });

    test('Should default asapFunded to undefined when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.asapFunded =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.asapFunded).not.toBeDefined();
    });

    test('Should default asapFunded "Not Sure" option to undefined', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData!.asapFunded =
        'Not Sure';
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.asapFunded).not.toBeDefined();
    });

    test('Should default usedInPublication to undefined when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.usedInAPublication =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.usedInPublication).not.toBeDefined();
    });

    test('Should default usedInPublication "Not Sure" option to undefined', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.usedInAPublication =
        'Not Sure';
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.usedInPublication).not.toBeDefined();
    });

    test('Should default authors to an empty array when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.authors =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.authors).toEqual([]);
    });

    test('Should default methods to an empty array when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.methods =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.methods).toEqual([]);
    });

    test('Should default organisms to an empty array when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.organisms =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.organisms).toEqual([]);
    });

    test('Should default environments to an empty array when missing', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.environments =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.environments).toEqual([]);
    });

    test('Should skip the lab when the name is empty', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.labs = [
        {
          id: 'lab-id-1',
          flatData: {
            name: null,
          },
        },
        {
          id: 'lab-id-2',
          flatData: {
            name: 'lab name',
          },
        },
      ];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      expect(result!.labs).toEqual([
        {
          id: 'lab-id-2',
          name: 'lab name',
        },
      ]);
    });

    test('Should return the research output without the team', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      squidexGraphqlResponse.findResearchOutputsContent!.referencingTeamsContents =
        [];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      const expectedResult = getResearchOutputDataObject();
      expectedResult.teams = [];
      expectedResult.contactEmails = []; // as there are no referencing teams, there won't be any PMs

      expect(result).toEqual(expectedResult);
    });

    test('Should return a mix of internal and external authors', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      const squidexUser1 = {
        ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
          .items![0],
        __typename: 'Users',
      } as InternalUser;
      const squidexUser2 = {
        ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
          .items![1],
        __typename: 'Users',
      } as InternalUser;
      const externalAuthor: ExternalUser = {
        __typename: 'ExternalAuthors',
        id: '3099015c-c9ed-40fd-830a-8fe1b6ec0482',
        created: '2021-06-04T09:37:54Z',
        lastModified: '2021-06-04T09:37:54Z',
        version: 42,
        flatData: {
          name: 'test external author',
          orcid: '23423423',
        },
      };
      squidexGraphqlResponse.findResearchOutputsContent!.flatData.authors = [
        squidexUser1,
        externalAuthor,
        squidexUser2,
      ];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      const { authors } = getResearchOutputDataObject();

      const expectedAuthorsResponse: ResearchOutputDataObject['authors'] = [
        authors[0]!,
        {
          id: '3099015c-c9ed-40fd-830a-8fe1b6ec0482',
          displayName: externalAuthor.flatData!.name!,
          orcid: externalAuthor.flatData!.orcid!,
        },
        authors[1]!,
      ];

      expect(result!.authors).toEqual(expectedAuthorsResponse);
    });

    test('Should not return the non-onboarded authors', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputGraphqlResponse();
      const squidexUser1 = {
        ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
          .items![0],
        __typename: 'Users',
        flatData: {
          ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
            .items![0]!.flatData,
          onboarded: false,
        },
      } as InternalUser;
      const squidexUser2 = {
        ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
          .items![1],
        __typename: 'Users',
        flatData: {
          ...getGraphqlResponseFetchUsers().queryUsersContentsWithTotal!
            .items![1]!.flatData,
          onboarded: true,
        },
      } as InternalUser;

      squidexGraphqlResponse.findResearchOutputsContent!.flatData.authors = [
        squidexUser1,
        squidexUser2,
      ];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetchById(
        researchOutputId,
      );

      const { authors } = getResearchOutputDataObject();

      const expectedAuthorsResponse: ResearchOutputDataObject['authors'] = [
        authors[1]!,
      ];

      expect(result!.authors).toHaveLength(1);
      expect(result!.authors).toEqual(expectedAuthorsResponse);
    });

    describe('PM emails', () => {
      test('Should return a list of PM emails', async () => {
        const squidexGraphqlResponse =
          getSquidexResearchOutputGraphqlResponse();

        // Two PMs on one team
        const pm1 = getGraphQLUser();
        pm1.flatData.email = 'pm1@example.com';
        pm1.flatData.teams![0]!.role = 'Project Manager';
        const pm2 = getGraphQLUser();
        pm2.flatData.email = 'pm2@example.com';
        pm2.flatData.teams![0]!.role = 'Project Manager';
        squidexGraphqlResponse.findResearchOutputsContent!.referencingTeamsContents![0]!.referencingUsersContents! =
          [pm1, pm2];

        // And one on another team
        const pm3 = getGraphQLUser();
        pm3.flatData.email = 'pm3@example.com';
        pm3.flatData.teams![0]!.role = 'Project Manager';
        const team = getSquidexGraphqlTeam({});
        team.referencingUsersContents = [pm3];
        squidexGraphqlResponse.findResearchOutputsContent!.referencingTeamsContents!.push(
          team,
        );

        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await researchOutputDataProvider.fetchById(
          researchOutputId,
        );
        expect(result!.contactEmails).toEqual([
          'pm1@example.com',
          'pm2@example.com',
          'pm3@example.com',
        ]);
      });

      test('PM emails should be deduplicated', async () => {
        const squidexGraphqlResponse =
          getSquidexResearchOutputGraphqlResponse();

        // Two PMs on one team
        const pm1 = getGraphQLUser();
        pm1.flatData.email = 'pm1@example.com';
        pm1.flatData.teams![0]!.role = 'Project Manager';
        const pm2 = getGraphQLUser();
        pm2.flatData.email = 'pm2@example.com';
        pm2.flatData.teams![0]!.role = 'Project Manager';
        squidexGraphqlResponse.findResearchOutputsContent!.referencingTeamsContents![0]!.referencingUsersContents! =
          [pm1, pm2];

        // Same one on another team
        const team = getSquidexGraphqlTeam({});
        team.referencingUsersContents = [pm1];
        squidexGraphqlResponse.findResearchOutputsContent!.referencingTeamsContents!.push(
          team,
        );

        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await researchOutputDataProvider.fetchById(
          researchOutputId,
        );

        // Both these PMs are duplicated in the fixture
        expect(result!.contactEmails).toEqual([
          'pm1@example.com',
          'pm2@example.com',
        ]);
      });
    });

    describe('Last Updated Partial field', () => {
      test('Should default to last-modified if the last-updated-partial is not present', async () => {
        const squidexGraphqlResponse =
          getSquidexResearchOutputGraphqlResponse();
        delete squidexGraphqlResponse.findResearchOutputsContent!.flatData
          .lastUpdatedPartial;
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await researchOutputDataProvider.fetchById(
          researchOutputId,
        );

        expect(result!.lastUpdatedPartial).toEqual(
          squidexGraphqlResponse.findResearchOutputsContent!.lastModified,
        );
      });

      test('Should default to created-date if the last-updated-partial and last-modified are not present', async () => {
        const squidexGraphqlResponse =
          getSquidexResearchOutputGraphqlResponse();
        delete squidexGraphqlResponse.findResearchOutputsContent!.flatData
          .lastUpdatedPartial;
        delete (squidexGraphqlResponse.findResearchOutputsContent as any)
          .lastModified;
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await researchOutputDataProvider.fetchById(
          researchOutputId,
        );

        expect(result!.lastUpdatedPartial).toEqual(
          squidexGraphqlResponse.findResearchOutputsContent!.created,
        );
      });
    });
  });

  describe('Fetch method', () => {
    test('Should fetch the research output from squidex graphql', async () => {
      const result = await researchOutputDataProviderMockGraphql.fetch({
        take: 8,
        skip: 0,
      });

      expect(result).toMatchObject(getListResearchOutputDataObject());
    });

    test('Should return an empty result when the client returns an empty array of data', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputsGraphqlResponse();
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal!.total = 0;
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal!.items = [];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetch({
        take: 10,
        skip: 5,
      });

      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result when the client returns a response with query property set to null', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputsGraphqlResponse();
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetch({
        take: 10,
        skip: 5,
      });

      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result when the client returns a response with items property set to null', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputsGraphqlResponse();
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal!.items =
        null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetch({
        take: 10,
        skip: 5,
      });

      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return Grant Document on ResearchOutputs', async () => {
      const squidexGraphqlResponse = getSquidexResearchOutputsGraphqlResponse();
      squidexGraphqlResponse.queryResearchOutputsContentsWithTotal!.items![0]!.flatData.documentType =
        'Grant Document';
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await researchOutputDataProvider.fetch({
        take: 10,
        skip: 0,
      });

      expect(result.items[0]!.documentType).toEqual('Grant Document');
    });

    describe('Parameters', () => {
      const defaultParams = {
        take: 8,
        skip: 0,
      };
      const expectedDefaultParams = {
        top: 8,
        skip: 0,
        filter: '',
        withTeams: true,
      };

      beforeEach(() => {
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          getSquidexResearchOutputsGraphqlResponse(),
        );
      });

      test('Should pass the pagination parameters as expected', async () => {
        await researchOutputDataProvider.fetch({ take: 13, skip: 7 });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            top: 13,
            skip: 7,
          },
          expect.anything(),
        );
      });

      test('Should pass the displayDrafts parameter as expected', async () => {
        await researchOutputDataProvider.fetch({
          take: 13,
          skip: 7,
          includeDrafts: true,
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            top: 13,
            skip: 7,
          },
          {
            includeDrafts: true,
          },
        );
      });

      test('Should pass the search parameter as a squidex filter', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          search: 'Title',
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter:
              "(contains(data/title/iv, 'Title') or contains(data/tags/iv, 'Title'))",
          },
          expect.anything(),
        );
      });

      test('Should pass the object filter parameter properties as a squidex filter', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          filter: {
            documentType: 'some-type',
            title: 'some-title',
          },
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter:
              "(data/documentType/iv eq 'some-type' and data/title/iv eq 'some-title')",
          },
          expect.anything(),
        );
      });

      test('Should pass the object filter parameter properties with an array as a squidex filter', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          filter: {
            documentType: ['some-type-1', 'some-type-2'],
            title: 'some-title',
          },
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter:
              "((data/documentType/iv eq 'some-type-1' or data/documentType/iv eq 'some-type-2') and data/title/iv eq 'some-title')",
          },
          expect.anything(),
        );
      });

      test('Should pass the search and filter parameter as a squidex filter', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          search: 'Title',
          filter: {
            documentType: ['Grant Document', 'Presentation'],
          },
        });

        const expectedFilter =
          "((data/documentType/iv eq 'Grant Document' or data/documentType/iv eq 'Presentation')) " +
          "and (contains(data/title/iv, 'Title') or contains(data/tags/iv, 'Title'))";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });

      test('Should break up the search parameter into multiple words and send as a squidex filter', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          search: 'some words',
        });

        const expectedFilter =
          "(contains(data/title/iv, 'some') or contains(data/tags/iv, 'some') or contains(data/title/iv, 'words') or contains(data/tags/iv, 'words'))";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });

      test('Should sanitise single quote in the search parameter by doubling it and encoding to hex for the squidex filter', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          search: "'",
        });

        const expectedFilter =
          "(contains(data/title/iv, '%27%27') or contains(data/tags/iv, '%27%27'))";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });

      test('Should sanitise double quotation mark in the search parameter by doubling it and encoding to hex for the squidex filter', async () => {
        await researchOutputDataProvider.fetch({
          ...defaultParams,
          search: '"',
        });

        const expectedFilter =
          "(contains(data/title/iv, '%22') or contains(data/tags/iv, '%22'))";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });
    });
  });

  describe('Create and update', () => {
    afterEach(() => {
      expect(nock.isDone()).toBe(true);
    });

    afterEach(() => {
      nock.cleanAll();
    });

    describe('Create', () => {
      test('Should send the correct requests to Squidex and return its ID', async () => {
        const researchOutputRequest = getResearchOutputCreateDataObject();
        const teamId = researchOutputRequest.teamIds[0];
        const researchOutputId = 'created-output-id';

        nock(baseUrl)
          // Create the ResearchOutput
          .post(
            `/api/content/${appName}/research-outputs?publish=true`,
            getRestResearchOutputCreateData(),
          )
          .reply(201, { id: researchOutputId })
          .get(`/api/content/${appName}/teams/${teamId}`)
          .matchHeader('X-Unpublished', `true`)
          .reply(200, { data: { id: teamId, outputs: { iv: ['output-1'] } } })
          // Add the ResearchOutput to the team
          .patch(`/api/content/${appName}/teams/${teamId}`, {
            outputs: { iv: ['output-1', researchOutputId] },
          })
          .reply(200);

        const result = await researchOutputDataProvider.create(
          researchOutputRequest,
        );
        expect(result).toEqual(researchOutputId);
      });

      test('Should default the missing subtype to an empty array', async () => {
        const researchOutputRequest = getResearchOutputCreateDataObject();
        researchOutputRequest.subtypeId = undefined;
        const teamId = researchOutputRequest.teamIds[0];
        const researchOutputId = 'created-output-id';

        nock(baseUrl)
          .post(
            `/api/content/${appName}/research-outputs?publish=true`,
            matches({
              subtype: { iv: [] },
            }),
          )
          .reply(201, { id: researchOutputId })
          .get(`/api/content/${appName}/teams/${teamId}`)
          .reply(200, { data: { id: teamId, outputs: { iv: ['output-1'] } } })
          .patch(`/api/content/${appName}/teams/${teamId}`, {
            outputs: { iv: ['output-1', researchOutputId] },
          })
          .reply(200);

        await researchOutputDataProvider.create(researchOutputRequest);
      });

      test('Should use the correct IDs for authors', async () => {
        const researchOutputRequest = getResearchOutputCreateDataObject();
        researchOutputRequest.authors = [
          {
            externalAuthorId: 'some-external-user-id',
          },
          { userId: 'some-user-id' },
        ];
        const teamId = researchOutputRequest.teamIds[0];
        const researchOutputId = 'created-output-id';

        nock(baseUrl)
          .post(
            `/api/content/${appName}/research-outputs?publish=true`,
            matches({
              authors: { iv: ['some-external-user-id', 'some-user-id'] },
            }),
          )
          .reply(201, { id: researchOutputId })
          .get(`/api/content/${appName}/teams/${teamId}`)
          .reply(200, { data: { id: teamId, outputs: { iv: ['output-1'] } } })
          .patch(`/api/content/${appName}/teams/${teamId}`, {
            outputs: { iv: ['output-1', researchOutputId] },
          })
          .reply(200);

        await researchOutputDataProvider.create(researchOutputRequest);
      });

      test('Should throw when fails to create the research output - 400', async () => {
        const researchOutputRequest = getResearchOutputCreateDataObject();

        nock(baseUrl)
          .post(`/api/content/${appName}/research-outputs?publish=true`)
          .reply(400);

        await expect(
          researchOutputDataProvider.create(researchOutputRequest),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw when fails to create the research output - 500', async () => {
        const researchOutputRequest = getResearchOutputCreateDataObject();
        nock(baseUrl)
          .post(`/api/content/${appName}/research-outputs?publish=true`)
          .reply(500);

        await expect(
          researchOutputDataProvider.create(researchOutputRequest),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw when a team from the research output cannot be found', async () => {
        const researchOutputRequest = getResearchOutputCreateDataObject();

        nock(baseUrl)
          .post(`/api/content/${appName}/research-outputs?publish=true`)
          .reply(201)
          .get(
            `/api/content/${appName}/teams/${researchOutputRequest.teamIds[0]}`,
          )
          .reply(404);

        await expect(
          researchOutputDataProvider.create(researchOutputRequest),
        ).rejects.toThrow(NotFoundError);
      });

      test('Should throw when research output association cannot be made', async () => {
        const researchOutputRequest = getResearchOutputCreateDataObject();
        const teamId = researchOutputRequest.teamIds[0];

        nock(baseUrl)
          .post(`/api/content/${appName}/research-outputs?publish=true`)
          .reply(201)
          .get(`/api/content/${appName}/teams/${teamId}`)
          .reply(200, { data: { id: teamId, outputs: { iv: ['output-1'] } } })
          .patch(`/api/content/${appName}/teams/${teamId}`)
          .reply(500);

        await expect(
          researchOutputDataProvider.create(researchOutputRequest),
        ).rejects.toThrow(GenericError);
      });
    });

    describe('Update', () => {
      const researchOutputId = 'updated-output-id';

      test('Should update the existing research-output and return its ID', async () => {
        const researchOutputUpdateData = getResearchOutputUpdateDataObject();

        nock(baseUrl)
          .patch(
            `/api/content/${appName}/research-outputs/${researchOutputId}`,
            {
              ...getRestResearchOutputUpdateData(),
              updatedBy: { iv: [researchOutputUpdateData.updatedBy] },
            },
          )
          .reply(201, { id: researchOutputId });

        const result = await researchOutputDataProvider.update(
          researchOutputId,
          researchOutputUpdateData,
        );
        expect(result).toEqual(researchOutputId);
      });

      test('Should throw when fails to update the research output - 400', async () => {
        const researchOutputRequest = getResearchOutputUpdateDataObject();

        nock(baseUrl)
          .patch(`/api/content/${appName}/research-outputs/${researchOutputId}`)
          .reply(400);

        await expect(
          researchOutputDataProvider.update(
            researchOutputId,
            researchOutputRequest,
          ),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw when fails to update the research output - 500', async () => {
        const researchOutputRequest = getResearchOutputUpdateDataObject();
        nock(baseUrl)
          .patch(`/api/content/${appName}/research-outputs/${researchOutputId}`)
          .reply(500);

        await expect(
          researchOutputDataProvider.update(
            researchOutputId,
            researchOutputRequest,
          ),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw when the research output cannot be found', async () => {
        const researchOutputRequest = getResearchOutputUpdateDataObject();

        nock(baseUrl)
          .patch(`/api/content/${appName}/research-outputs/${researchOutputId}`)
          .reply(404);

        await expect(
          researchOutputDataProvider.update(
            researchOutputId,
            researchOutputRequest,
          ),
        ).rejects.toThrow(NotFoundError);
      });
    });
  });
});

type Author = NonNullable<
  NonNullable<
    FetchResearchOutputQuery['findResearchOutputsContent']
  >['flatData']['authors']
>[number];
type InternalUser = Extract<Author, { __typename: 'Users' }>;
type ExternalUser = Extract<Author, { __typename: 'ExternalAuthors' }>;
