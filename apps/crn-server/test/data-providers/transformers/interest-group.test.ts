import { parseGraphQLInterestGroup } from '../../../src/data-providers/transformers/interest-group';
import { FetchGroupQuery } from '../../../src/autogenerated-gql/graphql';
import { getSquidexGraphqlInterestGroup } from '../../fixtures/interest-groups.fixtures';

describe('parseGraphQLInterestGroup', () => {
  const group = getSquidexGraphqlInterestGroup() as NonNullable<
    FetchGroupQuery['findGroupsContent']
  >;
  test('should throw when Leaders group roles are invalid', () => {
    const invalidLeaders = [
      { ...group.flatData.leaders![0]!, role: 'invalid role' },
    ];
    const groupWithInvalidLeaders = {
      ...group,
      flatData: { ...group.flatData, leaders: invalidLeaders },
    };

    expect(() => parseGraphQLInterestGroup(groupWithInvalidLeaders)).toThrow(
      'Invalid group role on leaders : invalid role',
    );
  });
  test('contactEmails should be generated from proper leaders', () => {
    const baseLeader = {
      ...group.flatData.leaders![0]!,
      role: 'Project Manager',
      inactiveSinceDate: null,
      user: [
        {
          ...group.flatData.leaders![0]!.user![0]!,
          flatData: {
            ...group.flatData.leaders![0]!.user![0]!.flatData,
            alumniSinceDate: null,
            email: 'leader1@test.com',
          },
        },
      ],
    };
    const baseUser = {
      ...baseLeader.user[0]!,
    };
    const leaders = [
      {
        ...baseLeader,
        user: [
          {
            ...baseUser,
            flatData: {
              ...baseUser.flatData,
              email: 'leader1@test.com',
            },
          },
        ],
      },
      {
        ...baseLeader,
        inactiveSinceDate: new Date().toISOString(),
        user: [
          {
            ...baseUser,
            flatData: {
              ...baseUser.flatData,
              email: 'leader2@test.com',
            },
          },
        ],
      },
      {
        ...baseLeader,
        user: [
          {
            ...baseUser,
            flatData: {
              ...baseUser.flatData,
              email: 'leader3@test.com',
            },
          },
        ],
      },
    ];
    const groupWithLeaders = {
      ...group,
      flatData: { ...group.flatData, leaders: leaders },
    };
    expect(
      parseGraphQLInterestGroup(groupWithLeaders).contactEmails,
    ).toStrictEqual(['leader1@test.com', 'leader3@test.com']);
  });
});
