import { EventContentFragment } from '../../src/autogenerated-gql/graphql';
import {
  EventSpeakerUser,
  getMeetingMaterial,
  parseEventSpeaker,
  parseGraphQLEvent,
  parseGraphQLSpeakers,
} from '../../src/entities/event';
import {
  getEventSpeaker,
  getSquidexGraphqlEvent,
  getSquidexGraphqlEventSpeaker,
} from '../fixtures/events.fixtures';

describe('events entity', () => {
  const graphqlEvent = getSquidexGraphqlEvent();
  describe('parseGraphQLEvent', () => {
    test(`throws when provided event doesn't have a calendar`, () => {
      const event = {
        ...graphqlEvent,
        id: 'example',
        flatData: {
          ...graphqlEvent.flatData,
          calendar: [],
        },
      };
      expect(() => parseGraphQLEvent(event)).toThrowError(
        `Event (example) doesn't have a calendar`,
      );
    });
    test(`throws when no team in speaker list is provided`, () => {
      const event = {
        ...graphqlEvent,
        flatData: {
          ...graphqlEvent.flatData,
          speakers: [
            {} as NonNullable<
              EventContentFragment['flatData']['speakers']
            >[number],
          ],
        },
      };
      expect(() => parseGraphQLEvent(event)).toThrowError(
        'Team is required in event speaker',
      );
    });
    test('throws when provided an invalid event status', () => {
      const event = {
        ...graphqlEvent,
        id: 'example',
        flatData: {
          ...graphqlEvent.flatData,
          status: 'invalid',
        },
      };
      expect(() => parseGraphQLEvent(event)).toThrowErrorMatchingInlineSnapshot(
        `"Invalid event (example) status \\"invalid\\""`,
      );
    });
  });
  describe('getMeetingMaterial', () => {
    test.each([null, undefined, [], 'detail', ['item']])(
      'always returns null when meeting material "%s" specified unavailable',
      (material) => {
        expect(getMeetingMaterial(material, true, false, [])).toBeNull();
        expect(getMeetingMaterial(material, true, true, [])).toBeNull();
      },
    );

    test.each([null, undefined, []])(
      'returns null when stale and meeting material is missing "%s"',
      (material) =>
        expect(getMeetingMaterial(material, false, true, [])).toBeNull(),
    );

    test.each`
      material     | empty
      ${null}      | ${undefined}
      ${undefined} | ${null}
      ${[]}        | ${undefined}
    `(
      'returns empty value "$empty" when fresh and missing material is "$material"',
      ({ material, empty }) =>
        expect(getMeetingMaterial(material, false, false, empty)).toEqual(
          empty,
        ),
    );
    test.each(['string', ['a']])(
      'always returns material "%s" when not permanently unavailable',
      (material) => {
        expect(getMeetingMaterial(material, false, false, undefined)).toEqual(
          material,
        );
        expect(getMeetingMaterial(material, false, true, undefined)).toEqual(
          material,
        );
      },
    );
  });

  test('Should return only team when there is no user in squidex response', () => {
    const squidexSpeaker = getSquidexGraphqlEventSpeaker();
    squidexSpeaker.user = [];

    expect(parseGraphQLSpeakers([squidexSpeaker])).toEqual([
      {
        ...getEventSpeaker(),
        role: undefined,
        user: undefined,
      },
    ]);
  });

  test('Should not return role when user teams does not include the team', () => {
    const squidexSpeaker = getSquidexGraphqlEventSpeaker();
    squidexSpeaker.team![0]!.id = 'the-team-id';
    (
      squidexSpeaker.user![0]!.flatData as EventSpeakerUser['flatData']
    ).teams![0]!.id![0]!.id = 'the-other-team-id';

    const eventSpeaker = getEventSpeaker();
    eventSpeaker.team.id = 'the-team-id';

    expect(parseGraphQLSpeakers([squidexSpeaker])).toEqual([
      {
        ...eventSpeaker,
        role: undefined,
      },
    ]);
  });

  test('Should return assigned role when user teams includes the team', () => {
    expect(parseGraphQLSpeakers([getSquidexGraphqlEventSpeaker()])).toEqual([
      getEventSpeaker(),
    ]);
  });

  test('parse event speaker properly maps speaker', () => {
    const eventSpeaker = parseEventSpeaker({
      __typename: 'Users',
      id: 'user-id-3',
      flatData: {
        avatar: [
          {
            id: 'avatar-id',
          },
        ],
        firstName: 'Adam',
        lastName: 'Brown',
        teams: [
          {
            id: [
              {
                id: 'team-id-3',
              },
            ],
            role: 'Lead PI (Core Leadership)',
          },
        ],
      },
    });

    expect(eventSpeaker?.displayName).toEqual('Adam Brown');
    expect(eventSpeaker?.avatarUrl).toContain('/avatar-id');
  });
});
