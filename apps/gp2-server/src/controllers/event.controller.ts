import { FetchOptions, gp2 } from '@asap-hub/model';
import { AllOrNone } from '@asap-hub/server-common';
import {
  Event,
  RestEvent,
  sanitiseForSquidex,
  SquidexGraphqlClient,
  SquidexRestClient,
} from '@asap-hub/squidex';
import Boom from '@hapi/boom';
import Intercept from 'apr-intercept';
import {
  FetchEventQuery,
  FetchEventQueryVariables,
  FetchEventsQuery,
  FetchEventsQueryVariables,
} from '../autogenerated-gql/graphql';
import { parseGraphQLEvent } from '../entities/event.entity';
import { FETCH_EVENT, FETCH_EVENTS } from '../queries/events.queries';
import logger from '../utils/logger';

export interface EventController {
  fetch: (options: FetchEventsOptions) => Promise<gp2.ListEventResponse>;
  fetchById: (eventId: string) => Promise<gp2.EventResponse>;
  create: (event: Event) => Promise<RestEvent>;
  fetchByGoogleId: (googleId: string) => Promise<RestEvent | null>;
  update: (eventId: string, data: Partial<Event>) => Promise<RestEvent>;
}

export default class Events implements EventController {
  squidexGraphqlClient: SquidexGraphqlClient;
  eventSquidexRestClient: SquidexRestClient<RestEvent>;

  constructor(
    squidexGraphqlClient: SquidexGraphqlClient,
    eventSquidexRestClient: SquidexRestClient<RestEvent>,
  ) {
    this.squidexGraphqlClient = squidexGraphqlClient;
    this.eventSquidexRestClient = eventSquidexRestClient;
  }

  async fetch(options: FetchEventsOptions): Promise<gp2.ListEventResponse> {
    const {
      take = 10,
      skip = 0,
      before,
      after,
      search,
      sortBy,
      sortOrder,
      filter,
    } = options;

    const filters = (search || '')
      .split(' ')
      .filter(Boolean)
      .map(sanitiseForSquidex)
      .reduce(
        (acc: string[], word: string) =>
          acc.concat(
            `(${[
              [`contains(data/title/iv, '${word}')`],
              [`contains(data/tags/iv, '${word}')`],
            ].join(' or ')})`,
          ),
        [],
      );

    filters.push('data/hidden/iv ne true');

    if (after) {
      filters.push(`data/endDate/iv gt ${after}`);
    }

    if (before) {
      filters.push(`data/endDate/iv lt ${before}`);
    }

    let orderby = '';

    if (sortBy && sortOrder) {
      orderby = `data/${sortBy}/iv ${sortOrder}`;
    }

    if (filter?.userId) {
      filters.push(`data/speakers/iv/user eq '${filter.userId}'`);
    }

    const { queryEventsContentsWithTotal } =
      await this.squidexGraphqlClient.request<
        FetchEventsQuery,
        FetchEventsQueryVariables
      >(FETCH_EVENTS, {
        filter: filters.join(' and '),
        top: take,
        skip,
        order: orderby,
      });

    if (
      !queryEventsContentsWithTotal?.total ||
      !queryEventsContentsWithTotal?.items
    ) {
      logger.warn('queryEventsContentsWithTotal returned null');
      return {
        total: 0,
        items: [],
      };
    }

    return {
      total: queryEventsContentsWithTotal.total,
      items: queryEventsContentsWithTotal.items.map((item) =>
        parseGraphQLEvent(item),
      ),
    };
  }

  async fetchById(eventId: string): Promise<gp2.EventResponse> {
    const { findEventsContent: event } =
      await this.squidexGraphqlClient.request<
        FetchEventQuery,
        FetchEventQueryVariables
      >(FETCH_EVENT, { id: eventId });

    if (!event) {
      throw Boom.notFound();
    }

    return parseGraphQLEvent(event);
  }

  // This functions are used by the sync google events script
  // and return RestEvents for the sake of simplicity
  async create(event: Event): Promise<RestEvent> {
    return this.eventSquidexRestClient.create(toEventData(event));
  }

  async update(eventId: string, event: Partial<Event>): Promise<RestEvent> {
    return this.eventSquidexRestClient.patch(eventId, toEventData(event));
  }

  async fetchByGoogleId(googleId: string): Promise<RestEvent | null> {
    const [err, res] = await Intercept(
      this.eventSquidexRestClient.client
        .get('events', {
          searchParams: {
            $top: 1,
            $filter: `data/googleId/iv eq '${googleId}'`,
          },
        })
        .json() as Promise<{ items: RestEvent[] }>,
    );

    if (err) {
      throw err;
    }

    const [event] = res.items;
    return event || null;
  }
}

const toEventData = (data: Partial<Event>): RestEvent['data'] =>
  Object.entries(data).reduce((acc, [key, value]) => {
    acc[key] = { iv: value };
    return acc;
  }, {} as { [key: string]: { iv: unknown } }) as RestEvent['data'];

export type FetchEventsOptions = (
  | {
      before: string;
      after?: string;
    }
  | {
      after: string;
      before?: string;
    }
  | {
      after?: never;
      before?: never;
    }
) &
  SortOptions &
  FetchOptions<FilterOptions>;

type SortOptions = AllOrNone<{
  sortBy: 'startDate' | 'endDate';
  sortOrder: 'asc' | 'desc';
}>;

type FilterOptions = {
  groupId?: string;
  userId?: string;
  externalAuthorId?: string;
  teamId?: string;
};
