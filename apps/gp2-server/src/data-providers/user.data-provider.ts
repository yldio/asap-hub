import { gp2 } from '@asap-hub/model';
import {
  parseDate,
  RestUser,
  sanitiseForSquidex,
  SquidexGraphqlClient,
  SquidexRestClient,
} from '@asap-hub/squidex';
import {
  FetchUserQuery,
  FetchUserQueryVariables,
  FetchUsersQuery,
  FetchUsersQueryVariables,
  UsersDataDegreeEnum,
  UsersDataRegionEnum,
  UsersDataRoleEnum,
} from '../autogenerated-gql/graphql';
import { FetchUsersOptions } from '../controllers/user.controller';
import { FETCH_USER, FETCH_USERS } from '../queries/users.queries';

export interface UserDataProvider {
  fetchById(id: string): Promise<gp2.UserDataObject | null>;
  update(id: string, update: gp2.UserUpdateDataObject): Promise<void>;
  fetch(options: FetchUsersOptions): Promise<gp2.ListUserDataObject>;
}
const regionMap = {
  [UsersDataRegionEnum.Africa]: 'Africa',
  [UsersDataRegionEnum.Asia]: 'Asia',
  [UsersDataRegionEnum.AustraliaAustraliasia]: 'Australia/Australiasia',
  [UsersDataRegionEnum.Europe]: 'Europe',
  [UsersDataRegionEnum.NorthAmerica]: 'North America',
  [UsersDataRegionEnum.SouthAmerica]: 'South America',
  [UsersDataRegionEnum.LatinAmerica]: 'Latin America',
} as const;
const roleMap = {
  [UsersDataRoleEnum.WorkingGroupParticipant]: 'Working Group Participant',
  [UsersDataRoleEnum.NetworkInvestigator]: 'Network Investigator',
  [UsersDataRoleEnum.NetworkCollaborator]: 'Network Collaborator',
  [UsersDataRoleEnum.Administrator]: 'Administrator',
  [UsersDataRoleEnum.Trainee]: 'Trainee',
} as const;

export class UserSquidexDataProvider implements UserDataProvider {
  squidexGraphlClient: SquidexGraphqlClient;
  userSquidexRestClient: SquidexRestClient<RestUser>;

  constructor(
    squidexGraphlClient: SquidexGraphqlClient,
    userSquidexRestClient: SquidexRestClient<RestUser>,
  ) {
    this.squidexGraphlClient = squidexGraphlClient;
    this.userSquidexRestClient = userSquidexRestClient;
  }
  async fetchById(id: string): Promise<gp2.UserDataObject | null> {
    const { findUsersContent } = await this.queryFetchByIdData(id);
    if (!findUsersContent) {
      return null;
    }
    return parseGraphQLUserToDataObject(findUsersContent);
  }

  async update(
    id: string,
    userToUpdate: gp2.UserUpdateDataObject,
  ): Promise<void> {
    const isFullUpdate = shouldDoFullUpdate(userToUpdate);

    const fieldMappedUser = mapUserFields(userToUpdate);
    const cleanedUser = cleanUser(fieldMappedUser);

    if (isFullUpdate) {
      const existingUser = await this.userSquidexRestClient.fetchById(id);

      await this.userSquidexRestClient.put(id, {
        ...existingUser.data,
        ...cleanedUser,
      });
    } else {
      await this.userSquidexRestClient.patch(id, cleanedUser);
    }
  }
  async fetch(options: FetchUsersOptions): Promise<gp2.ListUserDataObject> {
    const queryFilter = generateFetchQueryFilter(options);
    const { take = 8, skip = 0 } = options;
    return this.queryForUsers(queryFilter, take, skip);
  }

  private async queryForUsers(filter: string, top: number, skip: number) {
    const { queryUsersContentsWithTotal } = await this.queryFetchData(
      filter,
      top,
      skip,
    );

    const { total = 0, items = [] } = queryUsersContentsWithTotal || {};

    return {
      total: items ? total : 0,
      items: (items || []).map(parseGraphQLUserToDataObject),
    };
  }
  private async queryFetchData(filter: string, top: number, skip: number) {
    return this.squidexGraphlClient.request<
      FetchUsersQuery,
      FetchUsersQueryVariables
    >(FETCH_USERS, { filter, top, skip });
  }
  private async queryFetchByIdData(id: string) {
    return this.squidexGraphlClient.request<
      FetchUserQuery,
      FetchUserQueryVariables
    >(FETCH_USER, { id });
  }
}

const shouldDoFullUpdate = (userToUpdate: gp2.UserUpdateDataObject) =>
  Object.values(userToUpdate).some(
    (value) => typeof value === 'string' && value.trim() === '',
  );

const mapUserFields = ({
  role,
  region,
  degrees,
  ...user
}: gp2.UserUpdateDataObject) => {
  const reverseRegionMap: { [key: string]: UsersDataRegionEnum } =
    Object.entries(regionMap).reduce(
      (acc, [key, value]) => ({ ...acc, [value]: key }),
      {},
    );
  const reverseRoleMap: { [key: string]: UsersDataRoleEnum } = Object.entries(
    roleMap,
  ).reduce((acc, [key, value]) => ({ ...acc, [value]: key }), {});

  const mappedDegrees = degrees?.map((degree) => {
    if (degree === 'MD, PhD') {
      return UsersDataDegreeEnum.MdPhD;
    }

    return degree;
  });
  return {
    ...user,
    ...(region && { region: reverseRegionMap[region] }),
    ...(role && { role: reverseRoleMap[role] }),
    ...(degrees && { degree: mappedDegrees }),
  };
};

const cleanUser = (
  userToUpdate: Omit<
    gp2.UserUpdateDataObject,
    'region' | 'role' | 'degrees'
  > & {
    region?: UsersDataRegionEnum;
    role?: UsersDataRoleEnum;
    degrees?: UsersDataDegreeEnum;
  },
) =>
  Object.entries(userToUpdate).reduce((acc, [key, value]) => {
    const setValue = (item: unknown) => ({ ...acc, [key]: { iv: item } });
    if (typeof value === 'string' && value.trim() === '') {
      return setValue(null);
    }

    // we get an object but squidex expects an array of objects
    if (key === 'avatar') {
      return setValue([value]);
    }
    return setValue(value);
  }, {} as { [key: string]: { iv: unknown } });

const generateFetchQueryFilter = ({ search, filter }: FetchUsersOptions) => {
  const searchFilter = [
    ...(search || '')
      .split(' ')
      .filter(Boolean) // removes whitespaces
      .map(sanitiseForSquidex)
      .reduce(
        (acc: string[], word: string) =>
          acc.concat(
            `(${[
              [`contains(data/firstName/iv, '${word}')`],
              [`contains(data/lastName/iv, '${word}')`],
            ].join(' or ')})`,
          ),
        [],
      ),
  ].join(' and ');
  const { code } = filter || {};
  const filterCode = code && `data/connections/iv/code eq '${code}'`;

  const queryFilter = [filterCode, searchFilter && `(${searchFilter})`]
    .filter(Boolean)
    .join(' and ')
    .trim();
  return queryFilter;
};

export const parseGraphQLUserToDataObject = ({
  id,
  created,
  flatData: item,
}: NonNullable<FetchUserQuery['findUsersContent']>): gp2.UserDataObject => {
  if (!item.region) {
    throw new Error(`Region not defined: ${item.region}`);
  }
  if (!item.role) {
    throw new Error(`Role not defined: ${item.role}`);
  }
  const createdDate = parseDate(created).toISOString();

  const degrees: gp2.UserDegree[] | undefined =
    item.degree?.map<gp2.UserDegree>((degree) => {
      if (degree === 'MD_PhD') {
        return 'MD, PhD';
      }

      return degree;
    });

  return {
    id,
    createdDate,
    firstName: item.firstName || '',
    lastName: item.lastName || '',
    degrees,
    email: item.email || '',
    region: regionMap[item.region],
    role: roleMap[item.role],
  };
};
