import {
  ListUserDataObject,
  OrcidWork,
  OrcidWorkType,
  orcidWorkType,
  Role,
  UserDataObject,
  UserDegree,
  userDegree,
  UserResponse,
  userRole,
  UserTeam,
  UserUpdateDataObject,
} from '@asap-hub/model';
import {
  parseDate,
  RestUser,
  sanitiseForSquidex,
  SquidexGraphqlClient,
  SquidexRestClient,
} from '@asap-hub/squidex';
import {
  FetchUserQuery,
  FetchUserQueryVariables,
  FetchUsersQuery,
  FetchUsersQueryVariables,
  UsersContentFragment,
} from '../autogenerated-gql/graphql';
import { FetchUsersOptions } from '../controllers/user.controller';
import { FETCH_USER, FETCH_USERS } from '../queries/users.queries';
import logger from '../utils/logger';
import { createUrl } from '../utils/urls';

export type CMSOrcidWork = OrcidWork;

export interface UserDataProvider {
  fetchById(id: string): Promise<UserDataObject | null>;
  update(id: string, update: UserUpdateDataObject): Promise<void>;
  fetch(options: FetchUsersOptions): Promise<ListUserDataObject>;
}
export class UserSquidexDataProvider implements UserDataProvider {
  squidexGraphlClient: SquidexGraphqlClient;
  userSquidexRestClient: SquidexRestClient<RestUser>;

  constructor(
    squidexGraphlClient: SquidexGraphqlClient,
    userSquidexRestClient: SquidexRestClient<RestUser>,
  ) {
    this.squidexGraphlClient = squidexGraphlClient;
    this.userSquidexRestClient = userSquidexRestClient;
  }
  async fetchById(id: string): Promise<UserDataObject | null> {
    const { findUsersContent } = await this.queryFetchByIdData(id);
    if (!findUsersContent) {
      return null;
    }
    return parseGraphQLUserToDataObject(findUsersContent);
  }

  async update(id: string, userToUpdate: UserUpdateDataObject): Promise<void> {
    const isFullUpdate = shouldDoFullUpdate(userToUpdate);

    const cleanedUser = cleanUser(userToUpdate);

    if (isFullUpdate) {
      const existingUser = await this.userSquidexRestClient.fetchById(id);

      await this.userSquidexRestClient.put(id, {
        ...existingUser.data,
        ...cleanedUser,
      });
    } else {
      await this.userSquidexRestClient.patch(id, cleanedUser);
    }
  }
  async fetch(options: FetchUsersOptions): Promise<ListUserDataObject> {
    const queryFilter = generateFetchQueryFilter(options);
    const { take = 8, skip = 0 } = options;
    return this.queryForUsers(queryFilter, take, skip);
  }

  private async queryForUsers(filter: string, top: number, skip: number) {
    const { queryUsersContentsWithTotal } = await this.queryFetchData(
      filter,
      top,
      skip,
    );

    const { total = 0, items = [] } = queryUsersContentsWithTotal || {};

    return {
      total: items ? total : 0,
      items: (items || []).map(parseGraphQLUserToDataObject),
    };
  }
  private async queryFetchData(filter: string, top: number, skip: number) {
    return this.squidexGraphlClient.request<
      FetchUsersQuery,
      FetchUsersQueryVariables
    >(FETCH_USERS, { filter, top, skip });
  }
  private async queryFetchByIdData(id: string) {
    return this.squidexGraphlClient.request<
      FetchUserQuery,
      FetchUserQueryVariables
    >(FETCH_USER, { id });
  }
}

const shouldDoFullUpdate = (userToUpdate: UserUpdateDataObject) =>
  userToUpdate.teams?.length ||
  Object.values(userToUpdate).some(
    (value) => typeof value === 'string' && value.trim() === '',
  );

const cleanUser = (userToUpdate: UserUpdateDataObject) =>
  Object.entries(userToUpdate).reduce((acc, [key, value]) => {
    const setValue = (item: unknown) => ({ ...acc, [key]: { iv: item } });
    if (typeof value === 'string' && value.trim() === '') {
      return setValue(null);
    }

    // map flat questions to squidex format
    if (key === 'questions' && Array.isArray(value) && value.length) {
      return setValue(
        (value as string[]).map((question: string) => ({ question })),
      );
    }

    // we get an object but squidex expects an array of objects
    if (key === 'social' || key === 'avatar') {
      return setValue([value]);
    }
    return setValue(value);
  }, {} as { [key: string]: { iv: unknown } });

const generateFetchQueryFilter = ({ search, filter }: FetchUsersOptions) => {
  const searchFilter = [
    ...(search || '')
      .split(' ')
      .filter(Boolean) // removes whitespaces
      .map(sanitiseForSquidex)
      .reduce(
        (acc: string[], word: string) =>
          acc.concat(
            `(${[
              [`contains(data/firstName/iv, '${word}')`],
              [`contains(data/lastName/iv, '${word}')`],
              [`contains(data/institution/iv, '${word}')`],
              [`contains(data/expertiseAndResourceTags/iv, '${word}')`],
            ].join(' or ')})`,
          ),
        [],
      ),
  ].join(' and ');
  const { code, onboarded = true, hidden = true, orcid } = filter || {};
  const filterCode = code && `data/connections/iv/code eq '${code}'`;

  const filterHidden = hidden && "data/role/iv ne 'Hidden'";
  const filterNonOnboarded = onboarded && 'data/onboarded/iv eq true';
  const filterOrcid = orcid && `contains(data/order/iv, '${orcid}')`;

  const queryFilter = [
    filterCode,
    filterNonOnboarded,
    filterHidden,
    filterOrcid,
    searchFilter && `(${searchFilter})`,
  ]
    .filter(Boolean)
    .join(' and ')
    .trim();
  return queryFilter;
};

type GraphQLUserRequiredFlatDataProperties =
  | 'email'
  | 'firstName'
  | 'institution'
  | 'jobTitle'
  | 'lastModifiedDate'
  | 'lastName';
type GraphQLUserFlatData = UsersContentFragment['flatData'];
type GraphQLUserRequiredFlatData = Pick<
  GraphQLUserFlatData,
  GraphQLUserRequiredFlatDataProperties
>;
type GraphQLUserOptionalFlatData = Partial<
  Omit<GraphQLUserFlatData, GraphQLUserRequiredFlatDataProperties>
>;
type GraphQLUser = Omit<UsersContentFragment, 'flatData'> & {
  flatData: GraphQLUserRequiredFlatData & GraphQLUserOptionalFlatData;
};

export const parseGraphQLUser = (user: GraphQLUser): UserResponse => {
  const userDataObject = parseGraphQLUserToDataObject(user);

  return parseUserToResponse(userDataObject);
};

const getOrcidWorkPublicationDate = (
  input: NonNullable<
    GraphQLUser['flatData']['orcidWorks']
  >[number]['publicationDate'],
): OrcidWork['publicationDate'] => {
  const date: OrcidWork['publicationDate'] = {};

  if (typeof input.day === 'string') {
    date.day = input.day;
  }

  if (typeof input.month === 'string') {
    date.month = input.month;
  }

  if (typeof input.year === 'string') {
    date.year = input.year;
  }

  return date;
};

export const parseUserToDataObject = (user: RestUser): UserDataObject => {
  const teams: UserTeam[] =
    user.data.teams?.iv?.reduce((acc: UserTeam[], team) => {
      const { id, ...t } = team;
      if (!id[0]) {
        logger.warn(`Team id is undefined on user: ${user.id}`);
        return acc;
      }
      return [
        ...acc,
        {
          id: id[0],
          displayName: 'Unknown',
          ...t,
        },
      ];
    }, []) || [];

  const orcid = user.data.orcid?.iv;
  const social = {
    ...((user.data.social?.iv && user.data.social?.iv[0]) || {}),
    orcid,
  };

  return {
    id: user.id,
    onboarded: user.data.onboarded.iv,
    dismissedGettingStarted: user.data.dismissedGettingStarted.iv,
    createdDate: parseDate(user.created).toISOString(),
    lastModifiedDate: user.data.lastModifiedDate?.iv ?? user.created,
    email: user.data.email.iv,
    contactEmail: user.data?.contactEmail?.iv,
    degree: user.data.degree?.iv,
    firstName: user.data.firstName?.iv,
    lastName: user.data.lastName?.iv,
    biography: user.data.biography?.iv,
    jobTitle: user.data.jobTitle?.iv,
    institution: user.data.institution?.iv,
    teams,
    social,
    orcid: user.data.orcid?.iv,
    orcidLastModifiedDate: user.data.orcidLastModifiedDate?.iv,
    orcidLastSyncDate: user.data.orcidLastSyncDate?.iv,
    orcidWorks: user.data.orcidWorks?.iv,
    expertiseAndResourceTags: user.data.expertiseAndResourceTags?.iv || [],
    expertiseAndResourceDescription:
      user.data.expertiseAndResourceDescription?.iv,
    questions: user.data.questions?.iv?.map(({ question }) => question) || [],
    avatarUrl:
      (user.data.avatar?.iv && createUrl(user.data.avatar.iv)[0]) ?? undefined,
    role: user.data.role.iv === 'Hidden' ? 'Guest' : user.data.role.iv,
    responsibilities: user.data.responsibilities?.iv,
    researchInterests: user.data.researchInterests?.iv ?? undefined,
    reachOut: user.data.reachOut?.iv,
    labs: (user.data.labs?.iv || []).map((lab) => ({
      id: lab.id,
      name: lab.flatData?.name ?? '',
    })),
    connections: user.data.connections?.iv ?? undefined,
  };
};
const isUserRole = (data: string): data is Role =>
  (userRole as ReadonlyArray<string>).includes(data);

const isUserDegree = (data: string): data is UserDegree =>
  (userDegree as ReadonlyArray<string>).includes(data);

const isOrcidWorkType = (data: string): data is OrcidWorkType =>
  (orcidWorkType as ReadonlyArray<string>).includes(data);

export const parseUserToResponse = ({
  connections: _,
  ...user
}: UserDataObject): UserResponse => {
  const displayName = `${user.firstName} ${user.lastName}`;
  const onboarded = typeof user.onboarded === 'boolean' ? user.onboarded : true;
  const response = {
    ...user,
    displayName,
    onboarded,
  };
  return response;
};

export const parseGraphQLUserToDataObject = (
  item: GraphQLUser,
): UserDataObject => {
  const flatAvatar = item.flatData.avatar || [];
  const flatQuestions = item.flatData.questions || [];
  const flatExpertiseAndResourceTags =
    item.flatData.expertiseAndResourceTags || [];
  const createdDate = parseDate(item.created).toISOString();

  const role =
    item.flatData.role && isUserRole(item.flatData.role)
      ? item.flatData.role
      : 'Guest';

  const orcid = item.flatData.orcid || undefined;
  // merge both and remove null values
  const social = Object.entries({
    ...((item.flatData.social && item.flatData.social[0]) || {}),
    orcid,
  }).reduce((acc, [k, v]) => {
    if (!v) {
      return acc;
    }
    return { ...acc, [k]: v };
  }, {} as { [key: string]: string });

  const orcidWorks =
    (item.flatData.orcidWorks &&
      item.flatData.orcidWorks
        .reduce<OrcidWork[]>((orcidWorksAccumulator, orcidWork) => {
          if (orcidWork.id === null || orcidWork.lastModifiedDate === null) {
            return orcidWorksAccumulator;
          }

          return [
            ...orcidWorksAccumulator,
            {
              id: orcidWork.id,
              doi: orcidWork.doi || undefined,
              title: orcidWork.title || undefined,
              type:
                orcidWork.type && isOrcidWorkType(orcidWork.type)
                  ? orcidWork.type
                  : 'UNDEFINED',
              publicationDate: getOrcidWorkPublicationDate(
                orcidWork.publicationDate,
              ),
              lastModifiedDate: orcidWork.lastModifiedDate,
            },
          ];
        }, [])
        .slice(0, 5)) ||
    [];
  /* istanbul ignore next */
  return {
    id: item.id,
    onboarded:
      item.flatData && typeof item.flatData.onboarded === 'boolean'
        ? item.flatData.onboarded
        : undefined,
    dismissedGettingStarted:
      item.flatData &&
      typeof item.flatData.dismissedGettingStarted === 'boolean'
        ? item.flatData.dismissedGettingStarted
        : false,
    createdDate,
    orcid,
    firstName: item.flatData.firstName || '',
    lastName: item.flatData.lastName || '',
    biography: item.flatData.biography || undefined,
    teams: [],
    labs: [],
    degree:
      item.flatData.degree && isUserDegree(item.flatData.degree)
        ? item.flatData.degree
        : undefined,
    email: item.flatData.email || '',
    contactEmail: item.flatData.contactEmail || undefined,
    institution: item.flatData.institution || undefined,
    jobTitle: item.flatData.jobTitle || undefined,
    country: item.flatData.country || undefined,
    city: item.flatData.city || undefined,
    orcidWorks,
    questions:
      flatQuestions
        .map((q) => q.question)
        .filter<string>((q): q is string => typeof q === 'string') || [],
    expertiseAndResourceTags: flatExpertiseAndResourceTags,
    expertiseAndResourceDescription:
      item.flatData.expertiseAndResourceDescription ?? undefined,
    lastModifiedDate: item.flatData.lastModifiedDate || createdDate,
    social,
    avatarUrl: flatAvatar?.length
      ? createUrl(flatAvatar.map((a) => a.id))[0]
      : undefined,
    role,
    responsibilities: item.flatData.responsibilities || undefined,
    researchInterests: item.flatData.researchInterests ?? undefined,
    reachOut: item.flatData.reachOut || undefined,
    orcidLastSyncDate: item.flatData.orcidLastSyncDate || undefined,
  };
};
