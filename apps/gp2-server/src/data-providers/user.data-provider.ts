import { gp2 as gp2Model } from '@asap-hub/model';
import {
  gp2 as gp2Squidex,
  parseDate,
  parseToSquidex,
  sanitiseForSquidex,
  SquidexGraphqlClient,
  SquidexRestClient,
} from '@asap-hub/squidex';
import {
  FetchProjectsMembersQuery,
  FetchProjectsMembersQueryVariables,
  FetchUserQuery,
  FetchUserQueryVariables,
  FetchUsersQuery,
  FetchUsersQueryVariables,
  FetchWorkingGroupsMembersQuery,
  FetchWorkingGroupsMembersQueryVariables,
  UsersDataDegreeEnum,
  UsersDataRegionEnum,
  UsersDataRoleEnum,
} from '../autogenerated-gql/graphql';

import {
  FETCH_PROJECTS_MEMBERS,
  FETCH_USER,
  FETCH_USERS,
  FETCH_WORKINGGROUPS_MEMBERS,
} from '../queries/users.queries';
import { reverseMap } from '../utils/reverse-map';
import { createUrl } from '../utils/urls';
import { roleMap as projectRoleMap } from './project.data-provider';
import { roleMap as workingGroupRoleMap } from './working-group.data-provider';

export interface UserDataProvider {
  fetchById(id: string): Promise<gp2Model.UserDataObject | null>;
  update(id: string, user: gp2Model.UserUpdateDataObject): Promise<void>;
  create(user: gp2Model.UserCreateDataObject): Promise<string>;
  fetch(
    options: gp2Model.FetchUsersOptions,
  ): Promise<gp2Model.ListUserDataObject>;
}

export class UserSquidexDataProvider implements UserDataProvider {
  constructor(
    private squidexGraphqlClient: SquidexGraphqlClient,
    private userSquidexRestClient: SquidexRestClient<
      gp2Squidex.RestUser,
      gp2Squidex.InputUser
    >,
  ) {}

  async fetchById(id: string): Promise<gp2Model.UserDataObject | null> {
    const { findUsersContent } = await this.queryFetchByIdData(id);
    return findUsersContent
      ? parseGraphQLUserToDataObject(findUsersContent)
      : null;
  }

  async update(id: string, user: gp2Model.UserUpdateDataObject): Promise<void> {
    const cleanedUser = getUserSquidexData(user);
    await this.userSquidexRestClient.patch(id, cleanedUser);
  }

  async create(user: gp2Model.UserCreateDataObject): Promise<string> {
    const cleanedUser = getUserSquidexData(user);

    const { id } = await this.userSquidexRestClient.create({
      ...cleanedUser,
      avatar: { iv: [] },
      connections: { iv: [] },
    });

    return id;
  }

  async fetch({
    take = 8,
    skip = 0,
    filter,
    search,
  }: gp2Model.FetchUsersOptions): Promise<gp2Model.ListUserDataObject> {
    const { projects, workingGroups } = filter || {};
    const userIdFilter = await this.getUserIdFilter(filter);
    if (userIdFilter === '' && (projects?.length || workingGroups?.length)) {
      return { total: 0, items: [] };
    }
    const searchFilter = getSearchFilter(search);
    const queryFilter = generateFetchQueryFilter(
      filter,
      userIdFilter,
      searchFilter,
    );
    return this.queryForUsers(queryFilter, take, skip);
  }

  private async queryForUsers(filter: string, top: number, skip: number) {
    const { queryUsersContentsWithTotal } = await this.queryFetchData(
      filter,
      top,
      skip,
    );

    const { total = 0, items = [] } = queryUsersContentsWithTotal || {};

    return {
      total: items ? total : 0,
      items: (items || []).map(parseGraphQLUserToDataObject),
    };
  }
  private async queryFetchProjectData(filter: string) {
    const { queryProjectsContents } = await this.squidexGraphqlClient.request<
      FetchProjectsMembersQuery,
      FetchProjectsMembersQueryVariables
    >(FETCH_PROJECTS_MEMBERS, { filter });
    return queryProjectsContents;
  }
  private async queryFetchWorkingGroupData(filter: string) {
    const { queryWorkingGroupsContents } =
      await this.squidexGraphqlClient.request<
        FetchWorkingGroupsMembersQuery,
        FetchWorkingGroupsMembersQueryVariables
      >(FETCH_WORKINGGROUPS_MEMBERS, { filter });
    return queryWorkingGroupsContents;
  }
  private async queryFetchData(filter: string, top: number, skip: number) {
    return this.squidexGraphqlClient.request<
      FetchUsersQuery,
      FetchUsersQueryVariables
    >(FETCH_USERS, { filter, top, skip });
  }
  private async queryFetchByIdData(id: string) {
    return this.squidexGraphqlClient.request<
      FetchUserQuery,
      FetchUserQueryVariables
    >(FETCH_USER, { id });
  }

  private getUserIdFilter = async ({
    projects,
    workingGroups,
  }: gp2Model.FetchUsersOptions['filter'] = {}) => {
    const members = await Promise.all([
      getEntityMembers(projects, this.queryFetchProjectData.bind(this)),
      getEntityMembers(
        workingGroups,
        this.queryFetchWorkingGroupData.bind(this),
      ),
    ]);

    return members
      .flat()
      .filter(Boolean)
      .filter((id, index, arr) => arr.indexOf(id) === index)
      .map((id) => `id eq '${id}'`)
      .join(' or ');
  };
}

type UserCreateDataObjectEnumFields = Pick<
  gp2Model.UserCreateDataObject,
  'degrees' | 'region' | 'role'
>;
type UserCreateInputEnumFields = {
  degree?: `${UsersDataDegreeEnum}`[];
  region: UsersDataRegionEnum;
  role: UsersDataRoleEnum;
};
type UserUpdateDataObjectEnumFields = Pick<
  gp2Model.UserUpdateDataObject,
  'degrees' | 'region' | 'role'
>;
type UserUpdateInputEnumFields = Partial<UserCreateInputEnumFields>;
const mapUserFields = (
  input: UserCreateDataObjectEnumFields | UserUpdateDataObjectEnumFields,
): UserCreateInputEnumFields | UserUpdateInputEnumFields => {
  const mappedDegrees = input.degrees?.map((degree) =>
    degree === 'MD, PhD' ? UsersDataDegreeEnum.MdPhD : degree,
  );

  return {
    ...(input.region && { region: reverseRegionMap[input.region] }),
    ...(input.role && { role: reverseRoleMap[input.role] }),
    ...(input.degrees && { degree: mappedDegrees }),
  };
};

type UserUpdateTelephone = gp2Model.UserUpdateDataObject['telephone'];
type UserCreateTelephone = gp2Model.UserCreateDataObject['telephone'];
type MappedTelephone = {
  telephoneCountryCode?: string;
  telephoneNumber?: string;
};
const mapTelephone = (
  telephone?: UserCreateTelephone | UserUpdateTelephone,
): MappedTelephone => ({
  telephoneCountryCode: telephone?.countryCode,
  telephoneNumber: telephone?.number,
});

type UserUpdateCohorts = gp2Model.UserUpdateDataObject['contributingCohorts'];
type UserCreateCohorts = gp2Model.UserCreateDataObject['contributingCohorts'];
const mapContributingCohorts = (
  cohorts: UserUpdateCohorts | UserCreateCohorts,
) =>
  cohorts?.map(({ contributingCohortId, name, role, studyUrl }) => ({
    id: [contributingCohortId],
    name,
    role,
    study: studyUrl || '',
  }));

function getUserSquidexData(
  input: gp2Model.UserCreateDataObject,
): Omit<gp2Squidex.InputUser['data'], 'connections'>;
function getUserSquidexData(
  input: gp2Model.UserUpdateDataObject,
): Partial<Omit<gp2Squidex.InputUser['data'], 'connections'>>;
function getUserSquidexData(
  input: gp2Model.UserUpdateDataObject | gp2Model.UserCreateDataObject,
):
  | Omit<gp2Squidex.InputUser['data'], 'connections'>
  | Partial<Omit<gp2Squidex.InputUser['data'], 'connections'>> {
  const {
    region,
    role,
    degrees,
    telephone,
    questions,
    contributingCohorts,
    avatarUrl,
    ...userInput
  } = input;
  const fieldMappedUser = mapUserFields({ region, role, degrees });
  const mappedTelephone = mapTelephone(telephone);
  const mappedQuestions = questions?.map((question) => ({ question }));
  const mappedCohorts = mapContributingCohorts(contributingCohorts);

  return parseToSquidex({
    ...userInput,
    ...fieldMappedUser,
    ...mappedTelephone,
    questions: mappedQuestions,
    contributingCohorts: mappedCohorts,
    avatar: avatarUrl ? [avatarUrl] : undefined,
  });
}

const generateFetchQueryFilter = (
  {
    regions,
    keywords,
    code,
    onlyOnboarded,
    hidden = true,
  }: gp2Model.FetchUsersOptions['filter'] = {},
  userIdFilter: string,
  searchFilter: string,
) => {
  const filterOnboarded = onlyOnboarded && 'data/onboarded/iv eq true';
  const filterRegions = regions
    ?.map((r) => `data/region/iv eq '${reverseRegionMap[r]}'`)
    .join(' or ');
  const filterKeywords = keywords
    ?.map((r) => `data/keywords/iv eq '${r}'`)
    .join(' or ');

  const filterCode = code && `data/connections/iv/code eq '${code}'`;
  const filterHidden = hidden && "data/role/iv ne 'Hidden'";

  return [
    filterOnboarded,
    filterHidden,
    filterRegions,
    filterCode,
    filterKeywords,
    userIdFilter,
    searchFilter,
  ]
    .filter(Boolean)
    .map((group) => `(${group})`)
    .join(' and ')
    .trim();
};

export const parseGraphQLUserToDataObject = ({
  id,
  created,
  referencingProjectsContents: projectItems,
  referencingWorkingGroupsContents: workingGroupItems,
  flatData: user,
}: NonNullable<
  FetchUserQuery['findUsersContent']
>): gp2Model.UserDataObject => {
  if (!user.region) {
    throw new Error(`Region not defined: ${user.region}`);
  }
  if (!user.role) {
    throw new Error(`Role not defined: ${user.role}`);
  }

  const avatarUrl = user.avatar?.length
    ? createUrl(user.avatar.map((a) => a.id))[0]
    : undefined;
  const createdDate = parseDate(created).toISOString();
  const degrees = parseDegrees(user.degree);
  const positions = parsePositions(user.positions);
  const projects = parseProjects(projectItems);
  const workingGroups = parseWorkingGroups(workingGroupItems);
  const questions = parseQuestions(user.questions);
  const social = parseSocial(user.social);
  const telephone =
    user.telephoneNumber || user.telephoneCountryCode
      ? {
          countryCode: user.telephoneCountryCode || undefined,
          number: user.telephoneNumber || undefined,
        }
      : undefined;

  if (user.keywords && !user.keywords.every(gp2Model.isKeyword)) {
    throw new TypeError('Invalid keyword received from Squidex');
  }
  const contributingCohorts = parseContributingCohorts(
    user.contributingCohorts,
  );
  return {
    id,
    createdDate,
    avatarUrl,
    firstName: user.firstName || '',
    lastName: user.lastName || '',
    degrees,
    email: user.email || '',
    region: regionMap[user.region],
    role: roleMap[user.role],
    country: user.country || '',
    city: user.city || undefined,
    positions,
    onboarded: user.onboarded || false,
    projects,
    workingGroups,
    fundingStreams: user.fundingStreams || undefined,
    secondaryEmail: user.secondaryEmail || undefined,
    telephone,
    keywords: user.keywords || [],
    biography: user.biography || undefined,
    questions,
    contributingCohorts,
    social,
    activatedDate: user.activatedDate || undefined,
  };
};

const regionMap: Record<UsersDataRegionEnum, gp2Model.UserRegion> = {
  [UsersDataRegionEnum.Africa]: 'Africa',
  [UsersDataRegionEnum.Asia]: 'Asia',
  [UsersDataRegionEnum.AustraliaAustraliasia]: 'Australia/Australiasia',
  [UsersDataRegionEnum.Europe]: 'Europe',
  [UsersDataRegionEnum.LatinAmerica]: 'Latin America',
  [UsersDataRegionEnum.NorthAmerica]: 'North America',
  [UsersDataRegionEnum.SouthAmerica]: 'South America',
};
const roleMap: Record<UsersDataRoleEnum, gp2Model.UserRole> = {
  [UsersDataRoleEnum.Administrator]: 'Administrator',
  [UsersDataRoleEnum.Hidden]: 'Hidden',
  [UsersDataRoleEnum.NetworkCollaborator]: 'Network Collaborator',
  [UsersDataRoleEnum.NetworkInvestigator]: 'Network Investigator',
  [UsersDataRoleEnum.Trainee]: 'Trainee',
  [UsersDataRoleEnum.WorkingGroupParticipant]: 'Working Group Participant',
};
const reverseRegionMap = reverseMap(regionMap);
const reverseRoleMap = reverseMap(roleMap);

const parseProjects = (
  projects: NonNullable<
    FetchUserQuery['findUsersContent']
  >['referencingProjectsContents'],
): gp2Model.UserDataObject['projects'] =>
  projects?.map(({ id: projectId, flatData: project }) => {
    if (!project.status) {
      throw new TypeError('Status not defined');
    }
    return {
      id: projectId,
      status: project.status,
      title: project.title || '',
      members:
        project.members?.map((member) => {
          const user = member.user && member.user[0];

          if (!(member.role && user)) {
            throw new Error('Invalid project members');
          }
          return { role: projectRoleMap[member.role], userId: user.id };
        }) || [],
    };
  }) || [];

const parseWorkingGroups = (
  workingGroupItems: NonNullable<
    FetchUserQuery['findUsersContent']
  >['referencingWorkingGroupsContents'],
): gp2Model.UserDataObject['workingGroups'] =>
  workingGroupItems?.map(({ id: workingGroupId, flatData: workingGroup }) => ({
    id: workingGroupId,
    title: workingGroup.title || '',
    members:
      workingGroup.members?.map((member) => {
        const user = member.user && member.user[0];

        if (!(member.role && user)) {
          throw new Error('Invalid working group members');
        }
        return { role: workingGroupRoleMap[member.role], userId: user.id };
      }) || [],
  })) || [];

const parseDegrees = (
  degrees: NonNullable<
    FetchUserQuery['findUsersContent']
  >['flatData']['degree'],
): gp2Model.UserDataObject['degrees'] =>
  degrees?.map<gp2Model.UserDegree>((degree) =>
    degree === UsersDataDegreeEnum.MdPhD ? 'MD, PhD' : degree,
  ) || [];

const parseQuestions = (
  questions: NonNullable<
    FetchUserQuery['findUsersContent']
  >['flatData']['questions'],
): gp2Model.UserDataObject['questions'] =>
  questions?.map(({ question }) => {
    if (!question) {
      throw new Error('Invalid question');
    }
    return question;
  }) || [];

const parseSocial = (
  social: NonNullable<FetchUserQuery['findUsersContent']>['flatData']['social'],
): gp2Model.UserDataObject['social'] =>
  social?.map((item) =>
    Object.entries(item).reduce(
      (acc, [key, value]) => ({
        ...acc,
        ...(value ? { [`${key}`]: value } : undefined),
      }),
      {},
    ),
  )[0];

const parsePositions = (
  positions: NonNullable<
    FetchUserQuery['findUsersContent']
  >['flatData']['positions'],
): gp2Model.UserDataObject['positions'] =>
  positions?.map(({ role, department, institution }) => {
    if (!(role && department && institution)) {
      throw new Error('Position not defined');
    }
    return {
      role,
      department,
      institution,
    };
  }) || [];

const parseContributingCohorts = (
  cohorts: NonNullable<
    FetchUserQuery['findUsersContent']
  >['flatData']['contributingCohorts'],
): gp2Model.UserDataObject['contributingCohorts'] =>
  cohorts?.map(({ id, role, study }) => {
    const cohort = id && id[0];

    if (!(cohort && cohort.flatData.name && role)) {
      throw new Error('Invalid Contributing Cohort');
    }
    return {
      contributingCohortId: cohort.id,
      name: cohort.flatData.name,
      role,
      ...(study && { studyUrl: study }),
    };
  }) || [];

const getEntityMembers = async (
  ids: string[] | undefined,
  queryFetchMemberData: (
    filter: string,
  ) => Promise<
    | FetchWorkingGroupsMembersQuery['queryWorkingGroupsContents']
    | FetchProjectsMembersQuery['queryProjectsContents']
  >,
) => {
  if (!ids) {
    return [];
  }
  const membersFilter = ids.map((id) => `id eq '${id}'`).join(' or ');
  const entities = await queryFetchMemberData(membersFilter);
  return entities?.flatMap(
    ({ flatData }) =>
      flatData.members?.map(({ user }) => user && user[0]?.id) || [],
  );
};

const getSearchFilter = (search?: string) =>
  [
    ...(search || '')
      .split(' ')
      .filter(Boolean) // removes whitespaces
      .map(sanitiseForSquidex)
      .reduce(
        (acc: string[], word: string) =>
          acc.concat(
            `(${[
              [`contains(data/firstName/iv, '${word}')`],
              [`contains(data/lastName/iv, '${word}')`],
            ].join(' or ')})`,
          ),
        [],
      ),
  ].join(' and ');
