/* eslint-disable @typescript-eslint/no-non-null-assertion */
import {
  parseRichText,
  RichTextFromQuery,
  gp2 as gp2Contentful,
} from '@asap-hub/contentful';
import { gp2, isEventStatus } from '@asap-hub/model';
import { EventDataObject } from '@asap-hub/model/src/gp2';
import { parseDate } from '@asap-hub/squidex';
import { DateTime } from 'luxon';

import { EventDataFragment } from '../autogenerated-gql/graphql';
import { createUrl } from '../utils/urls';
import { parseGraphqlCalendarToResponse } from './calendar.entity';

export const getMeetingMaterial = <T>(
  material: T,
  isPermanentlyUnavailable: boolean,
  isStale: boolean,
  emptyState: T,
): T | null => {
  const isEmpty = !(Array.isArray(material) ? material.length : material);
  if (isPermanentlyUnavailable || (isEmpty && isStale)) {
    return null;
  }
  return isEmpty ? emptyState : material;
};

export type MeetingMaterial = {
  title: string;
  url: string;
};

export const getContentfulEventMaterial = <ReturnType, EmptyStateType>(
  material: MeetingMaterial[] | RichTextFromQuery | null,
  isPermanentlyUnavailable: boolean,
  isStale: boolean,
  emptyState: EmptyStateType,
): ReturnType | EmptyStateType | null => {
  const isEmpty = !(Array.isArray(material) ? material.length : material);

  if (isPermanentlyUnavailable || (isEmpty && isStale)) {
    return null;
  }

  if (isEmpty) {
    return emptyState;
  }

  return Array.isArray(material)
    ? (material as ReturnType)
    : material && (parseRichText(material) as ReturnType);
};

export const parseContentfulWorkingGroupProject = (calendar?: {
  linkedFrom?: gp2Contentful.Maybe<{
    workingGroupsCollection?:
      | gp2Contentful.Maybe<{
          items: gp2Contentful.Maybe<
            Pick<gp2Contentful.WorkingGroups, 'title'> & {
              sys: Pick<gp2Contentful.Sys, 'id'>;
            }
          >[];
        }>
      | undefined;
    projectsCollection?:
      | gp2Contentful.Maybe<{
          items: gp2Contentful.Maybe<
            Pick<gp2Contentful.Projects, 'title'> & {
              sys: Pick<gp2Contentful.Sys, 'id'>;
            }
          >[];
        }>
      | undefined;
  }>;
}): Pick<EventDataObject, 'project' | 'workingGroup'> => {
  const project =
    calendar?.linkedFrom?.projectsCollection?.items.map((item) => ({
      id: item!.sys.id || '',
      title: item!.title || '',
    }))[0] || undefined;

  const workingGroup =
    calendar?.linkedFrom?.workingGroupsCollection?.items.map((item) => ({
      id: item!.sys.id || '',
      title: item!.title || '',
    }))[0] || undefined;

  return { project, workingGroup };
};

export type GraphqlEventSpeakerUser = Extract<
  NonNullable<
    NonNullable<EventDataFragment['flatData']['speakers']>[number]['user']
  >[number],
  { __typename: 'Users' }
>;

export type GraphqlEventSpeakerExternalUser = Extract<
  NonNullable<
    NonNullable<EventDataFragment['flatData']['speakers']>[number]['user']
  >[number],
  { __typename: 'ExternalUsers' }
>;

export const parseEventSpeakerUser = (
  user: GraphqlEventSpeakerUser,
): gp2.EventSpeakerUser => {
  const flatAvatar = user.flatData.avatar || [];

  return {
    id: user.id,
    firstName: user.flatData.firstName ?? undefined,
    lastName: user.flatData.lastName ?? undefined,
    displayName: `${user.flatData.firstName} ${user.flatData.lastName}`,
    avatarUrl: flatAvatar.length
      ? createUrl(flatAvatar.map((a) => a.id))[0]
      : undefined,
  };
};

export const parseEventSpeakerExternalUser = (
  user: GraphqlEventSpeakerExternalUser,
): gp2.EventSpeakerExternalUser => ({
  name: user.flatData.name || '',
  orcid: user.flatData.orcid || '',
});

export const parseGraphQLSpeakers = (
  speakers: NonNullable<EventDataFragment['flatData']['speakers']>,
): gp2.EventSpeaker[] =>
  speakers.reduce((speakerList: gp2.EventSpeaker[], speaker) => {
    const user = speaker?.user?.[0];
    const topic = speaker?.topic || undefined;

    if (user?.__typename === 'ExternalUsers') {
      speakerList.push({
        speaker: parseEventSpeakerExternalUser(user),
        topic,
      });
      return speakerList;
    }

    if (!user) {
      speakerList.push({
        speaker: undefined,
        topic,
      });
      return speakerList;
    }

    if (user?.flatData.onboarded !== true) {
      return speakerList;
    }

    speakerList.push({
      speaker: parseEventSpeakerUser(user),
      topic,
    });
    return speakerList;
  }, []);

export const parseGraphQLEvent = (
  item: EventDataFragment,
): gp2.EventDataObject => {
  if (!item.flatData.calendar?.[0]) {
    throw new Error(`Event (${item.id}) doesn't have a calendar"`);
  }

  const calendar = parseGraphqlCalendarToResponse(
    item.flatData.calendar[0].flatData,
  );

  const { workingGroup, project } = parseGraphQLWorkingGroupProjects(
    item.flatData.calendar[0],
  );
  const startDate = DateTime.fromISO(item.flatData.startDate!);

  const meetingLink = item.flatData.meetingLink || undefined;

  const thumbnail = item.flatData.thumbnail?.length
    ? createUrl(item.flatData.thumbnail.map((t) => t.id))[0]
    : undefined;

  const speakers = parseGraphQLSpeakers(item.flatData.speakers ?? []);

  const endDate = DateTime.fromISO(item.flatData.endDate);
  const isStale = endDate.diffNow('days').get('days') < -14; // 14 days have passed after the event

  const {
    notesPermanentlyUnavailable,
    videoRecordingPermanentlyUnavailable,
    presentationPermanentlyUnavailable,
    meetingMaterialsPermanentlyUnavailable,
    notes,
    videoRecording,
    presentation,
    meetingMaterials,
  } = item.flatData;

  if (!isEventStatus(item.flatData.status)) {
    throw new Error(
      `Invalid event (${item.id}) status "${item.flatData.status}"`,
    );
  }

  return {
    id: item.id,
    description: item.flatData.description || '',
    startDate: startDate.toUTC().toString(),
    startDateTimeZone: item.flatData.startDateTimeZone!,
    startDateTimestamp: startDate.toSeconds(),
    endDate: endDate.toUTC().toString(),
    endDateTimeZone: item.flatData.endDateTimeZone!,
    endDateTimestamp: endDate.toSeconds(),
    lastModifiedDate: parseDate(item.lastModified).toISOString(),
    title: item.flatData.title!,
    notes: getMeetingMaterial(
      notes,
      !!notesPermanentlyUnavailable,
      isStale,
      undefined,
    ),
    videoRecording: getMeetingMaterial(
      videoRecording,
      !!videoRecordingPermanentlyUnavailable,
      isStale,
      undefined,
    ),
    presentation: getMeetingMaterial(
      presentation,
      !!presentationPermanentlyUnavailable,
      isStale,
      undefined,
    ),
    meetingMaterials: getMeetingMaterial(
      (meetingMaterials ?? []).map(({ title, url }) => ({
        title: title ?? '',
        url: url ?? '',
      })),
      !!meetingMaterialsPermanentlyUnavailable,
      isStale,
      [],
    ),
    thumbnail,
    meetingLink,
    hideMeetingLink: item.flatData.hideMeetingLink || false,
    status: item.flatData.status,
    tags: item.flatData.tags ?? [],
    calendar,
    workingGroup,
    project,
    speakers,
  };
};
export type GraphqlEventCalendar = Pick<
  NonNullable<NonNullable<EventDataFragment['flatData']['calendar']>[number]>,
  'referencingProjectsContents' | 'referencingWorkingGroupsContents'
>;

export const parseGraphQLWorkingGroupProjects = (
  calendar: GraphqlEventCalendar,
) => {
  const workingGroup =
    calendar.referencingWorkingGroupsContents?.map((wg) => ({
      id: wg.id,
      title: wg.flatData.title || '',
    }))[0] || undefined;
  const project =
    calendar.referencingProjectsContents?.map((p) => ({
      id: p.id,
      title: p.flatData.title || '',
    }))[0] || undefined;
  return { workingGroup, project };
};
