import { GenericError, NotFoundError } from '@asap-hub/errors';
import { gp2 as gp2Model } from '@asap-hub/model';
import {
  gp2 as gp2Squidex,
  SquidexGraphqlError,
  SquidexRest,
} from '@asap-hub/squidex';
import matches from 'lodash.matches';
import nock from 'nock';
import {
  FetchOutputQuery,
  OutputsDataDocumentTypeEnum,
  OutputsDataSubtypeEnum,
  OutputsDataTypeEnum,
} from '../../src/autogenerated-gql/graphql';
import { appName, baseUrl } from '../../src/config';
import {
  makeODataFilter,
  OutputSquidexDataProvider,
} from '../../src/data-providers/output.data-provider';
import { getAuthToken } from '../../src/utils/auth';
import {
  getListOutputDataObject,
  getOutputCreateDataObject,
  getOutputDataObject,
  getOutputUpdateDataObject,
  getRestOutputCreateData,
  getRestOutputUpdateData,
  getSquidexOutputGraphqlResponse,
  getSquidexOutputsGraphqlResponse,
} from '../fixtures/output.fixtures';
import { identity } from '../helpers/squidex';
import { getSquidexGraphqlClientMockServer } from '../mocks/squidex-graphql-client-with-server.mock';
import { getSquidexGraphqlClientMock } from '../mocks/squidex-graphql-client.mock';

describe('Outputs data provider', () => {
  const squidexGraphqlClientMock = getSquidexGraphqlClientMock();

  const outputRestClient = new SquidexRest<gp2Squidex.RestOutput>(
    getAuthToken,
    'outputs',
    { appName, baseUrl },
  );
  const outputDataProvider = new OutputSquidexDataProvider(
    squidexGraphqlClientMock,
    outputRestClient,
  );

  const squidexGraphqlClientMockServer = getSquidexGraphqlClientMockServer();
  const outputDataProviderMockGraphql = new OutputSquidexDataProvider(
    squidexGraphqlClientMockServer,
    outputRestClient,
  );

  beforeAll(() => {
    identity();
  });

  afterEach(jest.resetAllMocks);

  describe('Fetch by ID method', () => {
    const outputId = 'some-uuid';

    test('Should fetch the output from squidex graphql', async () => {
      const result = await outputDataProviderMockGraphql.fetchById(outputId);

      expect(result).toMatchObject(getOutputDataObject());
    });

    test('should return the output', async () => {
      const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await outputDataProvider.fetchById(outputId);
      const expectedResult = getOutputDataObject();

      expect(result).toEqual(expectedResult);
    });

    describe('Document Types', () => {
      test('should throw when the document type is null', async () => {
        const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();
        squidexGraphqlResponse.findOutputsContent!.flatData.documentType = null;
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        await expect(outputDataProvider.fetchById(outputId)).rejects.toThrow(
          'document type not defined',
        );
      });
      test.each<[OutputsDataDocumentTypeEnum, gp2Model.OutputDocumentType]>([
        [OutputsDataDocumentTypeEnum.Article, 'Articles'],
        [OutputsDataDocumentTypeEnum.CodeSoftware, 'Code/Software'],
        [OutputsDataDocumentTypeEnum.DataRelease, 'Data Releases'],
        [OutputsDataDocumentTypeEnum.Form, 'Forms'],
        [OutputsDataDocumentTypeEnum.TrainingMaterial, 'Training Materials'],
        [OutputsDataDocumentTypeEnum.Update, 'Updates'],
      ])('parses the document type %s to %s', async (type, expected) => {
        const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();
        squidexGraphqlResponse.findOutputsContent!.flatData.documentType = type;
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );
        const result = await outputDataProvider.fetchById(outputId);
        expect(result?.documentType).toEqual(expected);
      });
    });
    describe('Types', () => {
      test('should throw when the type is null', async () => {
        const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();
        squidexGraphqlResponse.findOutputsContent!.flatData.documentType =
          OutputsDataDocumentTypeEnum.Article;
        squidexGraphqlResponse.findOutputsContent!.flatData.type = null;
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        await expect(outputDataProvider.fetchById(outputId)).rejects.toThrow(
          'type not defined',
        );
      });
      test.each<[OutputsDataTypeEnum, gp2Model.OutputType]>([
        [OutputsDataTypeEnum.Blog, 'Blog'],
        [OutputsDataTypeEnum.HotTopic, 'Hot Topic'],
        [OutputsDataTypeEnum.Letter, 'Letter'],
        [OutputsDataTypeEnum.Research, 'Research'],
        [OutputsDataTypeEnum.Review, 'Review'],
      ])('parses the  type %s to %s', async (type, expected) => {
        const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();
        squidexGraphqlResponse.findOutputsContent!.flatData.documentType =
          OutputsDataDocumentTypeEnum.Article;
        squidexGraphqlResponse.findOutputsContent!.flatData.type = type;
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );
        const result = await outputDataProvider.fetchById(outputId);
        expect(result?.type).toEqual(expected);
      });
      test.each(
        Object.values(OutputsDataDocumentTypeEnum).filter(
          (type) => type !== OutputsDataDocumentTypeEnum.Article,
        ),
      )(
        'parses the type to undefined for the document type %s',
        async (type) => {
          const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();
          squidexGraphqlResponse.findOutputsContent!.flatData.documentType =
            type;
          squidexGraphqlClientMock.request.mockResolvedValueOnce(
            squidexGraphqlResponse,
          );
          const result = await outputDataProvider.fetchById(outputId);
          expect(result?.type).toBeUndefined();
        },
      );
    });
    test.each(Object.values(OutputsDataSubtypeEnum))(
      'parses the sub types %s',
      async (type) => {
        const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();
        squidexGraphqlResponse.findOutputsContent!.flatData.documentType =
          OutputsDataDocumentTypeEnum.Article;
        squidexGraphqlResponse.findOutputsContent!.flatData.type =
          OutputsDataTypeEnum.Research;
        squidexGraphqlResponse.findOutputsContent!.flatData.subtype = type;
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );
        const result = await outputDataProvider.fetchById(outputId);
        expect(result?.subtype).toEqual(type);
      },
    );

    test('Should throw a Not Found error when the output is not found', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce({
        findOutputsContent: null,
      });

      await expect(outputDataProvider.fetchById(outputId)).rejects.toThrow(
        'Not Found',
      );
    });

    test('Should throw an error with a specific error message when the graphql client throws one', async () => {
      squidexGraphqlClientMock.request.mockRejectedValueOnce(
        new SquidexGraphqlError(
          {
            status: 521,
            errors: [
              {
                message: 'some error message',
                path: ['asdasdas'],
                locations: [],
              },
            ],
          },
          { query: 'some query' },
        ),
      );

      await expect(outputDataProvider.fetchById(outputId)).rejects.toThrow(
        'some error message',
      );
    });

    test('Should default authors to an empty array when missing', async () => {
      const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();
      squidexGraphqlResponse.findOutputsContent!.flatData.authors = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await outputDataProvider.fetchById(outputId);

      expect(result!.authors).toEqual([]);
    });

    describe('Authors', () => {
      const getInternalUsers = (): InternalUser[] => [
        {
          id: 'user-id-1',
          created: '2021-06-04T09:37:54Z',
          lastModified: '2021-06-04T09:37:54Z',
          version: 42,
          flatData: {
            firstName: 'Tony',
            lastName: 'Stark',
            onboarded: true,
            avatar: [],
          },
          __typename: 'Users',
        },
        {
          id: 'user-id-2',
          created: '2021-06-04T09:37:54Z',
          lastModified: '2021-06-04T09:37:54Z',
          version: 11,
          flatData: {
            firstName: 'Peter',
            lastName: 'Parker',
            onboarded: true,
            avatar: [],
          },
          __typename: 'Users',
        },
      ];
      test('Should return a mix of internal and external authors', async () => {
        const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();
        const [squidexUser1, squidexUser2] = getInternalUsers();
        const externalAuthor: ExternalUser = {
          __typename: 'ExternalAuthors',
          id: '3099015c-c9ed-40fd-830a-8fe1b6ec0482',
          created: '2021-06-04T09:37:54Z',
          lastModified: '2021-06-04T09:37:54Z',
          version: 42,
          flatData: {
            name: 'test external author',
            orcid: '23423423',
          },
        };
        squidexGraphqlResponse.findOutputsContent!.flatData.authors = [
          squidexUser1!,
          externalAuthor,
          squidexUser2!,
        ];
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await outputDataProvider.fetchById(outputId);

        const { authors } = getOutputDataObject();

        const expectedAuthorsResponse: gp2Model.OutputDataObject['authors'] = [
          authors[0]!,
          {
            id: '3099015c-c9ed-40fd-830a-8fe1b6ec0482',
            displayName: externalAuthor.flatData!.name!,
            orcid: externalAuthor.flatData!.orcid!,
          },
          authors[1]!,
        ];

        expect(result!.authors).toEqual(expectedAuthorsResponse);
      });

      test('Should not return the non-onboarded authors', async () => {
        const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();

        const [squidexUser1, squidexUser2] = getInternalUsers();
        squidexUser1!.flatData.onboarded = false;
        squidexUser2!.flatData.onboarded = true;
        squidexGraphqlResponse.findOutputsContent!.flatData.authors = [
          squidexUser1!,
          squidexUser2!,
        ];
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await outputDataProvider.fetchById(outputId);

        const { authors } = getOutputDataObject();

        const expectedAuthorsResponse: gp2Model.OutputDataObject['authors'] = [
          authors[1]!,
        ];

        expect(result!.authors).toHaveLength(1);
        expect(result!.authors).toEqual(expectedAuthorsResponse);
      });
      test('Should return internal user avatar', async () => {
        const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();

        const [squidexUser1] = getInternalUsers();
        squidexUser1!.flatData.avatar = [{ id: 'avatar-id' }];
        squidexGraphqlResponse.findOutputsContent!.flatData.authors = [
          squidexUser1!,
        ];
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await outputDataProvider.fetchById(outputId);

        const { authors } = getOutputDataObject();

        const expectedAuthorsResponse = {
          ...authors[0]!,
          avatarUrl: `${baseUrl}/api/assets/${appName}/avatar-id`,
        };
        expect(result!.authors[0]!).toEqual(expectedAuthorsResponse);
      });
    });

    describe('Last Updated Partial field', () => {
      test('Should default to last-modified if the last-updated-partial is not present', async () => {
        const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();
        delete squidexGraphqlResponse.findOutputsContent!.flatData
          .lastUpdatedPartial;
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await outputDataProvider.fetchById(outputId);

        expect(result!.lastUpdatedPartial).toEqual(
          squidexGraphqlResponse.findOutputsContent!.lastModified,
        );
      });

      test('Should default to created-date if the last-updated-partial and last-modified are not present', async () => {
        const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();
        delete squidexGraphqlResponse.findOutputsContent!.flatData
          .lastUpdatedPartial;
        delete (squidexGraphqlResponse.findOutputsContent as any).lastModified;
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );

        const result = await outputDataProvider.fetchById(outputId);

        expect(result!.lastUpdatedPartial).toEqual(
          squidexGraphqlResponse.findOutputsContent!.created,
        );
      });
    });
    describe('working groups', () => {
      it('should return undefined if theres no working group', async () => {
        const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();
        squidexGraphqlResponse.findOutputsContent!.flatData.workingGroups = [];
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );
        const result = await outputDataProvider.fetchById(outputId);

        expect(result!.workingGroups).toBeUndefined();
      });
    });
    describe('projects', () => {
      it('should return undefined if theres no project', async () => {
        const squidexGraphqlResponse = getSquidexOutputGraphqlResponse();
        squidexGraphqlResponse.findOutputsContent!.flatData.projects = [];
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          squidexGraphqlResponse,
        );
        const result = await outputDataProvider.fetchById(outputId);

        expect(result!.projects).toBeUndefined();
      });
    });
  });

  describe('Fetch method', () => {
    test('Should fetch the output from squidex graphql', async () => {
      const result = await outputDataProviderMockGraphql.fetch({});

      expect(result).toMatchObject(getListOutputDataObject());
    });

    test('Should return an empty result when the client returns an empty array of data', async () => {
      const squidexGraphqlResponse = getSquidexOutputsGraphqlResponse();
      squidexGraphqlResponse.queryOutputsContentsWithTotal!.total = 0;
      squidexGraphqlResponse.queryOutputsContentsWithTotal!.items = [];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await outputDataProvider.fetch({
        take: 10,
        skip: 5,
      });

      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result when the client returns a response with query property set to null', async () => {
      const squidexGraphqlResponse = getSquidexOutputsGraphqlResponse();
      squidexGraphqlResponse.queryOutputsContentsWithTotal = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await outputDataProvider.fetch({
        take: 10,
        skip: 5,
      });

      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result when the client returns a response with items property set to null', async () => {
      const squidexGraphqlResponse = getSquidexOutputsGraphqlResponse();
      squidexGraphqlResponse.queryOutputsContentsWithTotal!.items = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await outputDataProvider.fetch({
        take: 10,
        skip: 5,
      });

      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return the document type on Outputs', async () => {
      const squidexGraphqlResponse = getSquidexOutputsGraphqlResponse();
      squidexGraphqlResponse.queryOutputsContentsWithTotal!.items![0]!.flatData.documentType =
        OutputsDataDocumentTypeEnum.Form;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexGraphqlResponse,
      );

      const result = await outputDataProvider.fetch({
        take: 10,
        skip: 0,
      });

      expect(result.items[0]!.documentType).toEqual('Forms');
    });

    describe('Parameters', () => {
      const defaultParams = {
        take: 8,
        skip: 0,
      };
      const expectedDefaultParams = {
        top: 8,
        skip: 0,
        filter: '',
      };

      beforeEach(() => {
        squidexGraphqlClientMock.request.mockResolvedValueOnce(
          getSquidexOutputsGraphqlResponse(),
        );
      });

      test('Should pass the pagination parameters as expected', async () => {
        await outputDataProvider.fetch({ take: 13, skip: 7 });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            top: 13,
            skip: 7,
          },
          expect.anything(),
        );
      });

      test('Should pass the displayDrafts parameter as expected', async () => {
        await outputDataProvider.fetch({
          take: 13,
          skip: 7,
          includeDrafts: true,
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            top: 13,
            skip: 7,
          },
          {
            includeDrafts: true,
          },
        );
      });

      test('Should pass the search parameter as a squidex filter', async () => {
        await outputDataProvider.fetch({
          ...defaultParams,
          search: 'Title',
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: "contains(data/title/iv,'Title')",
          },
          expect.anything(),
        );
      });

      test('Should pass the object filter parameter properties as a squidex filter', async () => {
        await outputDataProvider.fetch({
          ...defaultParams,
          filter: {
            documentType: 'some-type',
            title: 'some-title',
          },
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter:
              "data/documentType/iv eq 'some-type' and data/title/iv eq 'some-title'",
          },
          expect.anything(),
        );
      });

      test('Should pass the object filter parameter properties with an array as a squidex filter', async () => {
        await outputDataProvider.fetch({
          ...defaultParams,
          filter: {
            documentType: ['some-type-1', 'some-type-2'],
            title: 'some-title',
          },
        });

        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter:
              "((data/documentType/iv eq 'some-type-1') or (data/documentType/iv eq 'some-type-2')) and data/title/iv eq 'some-title'",
          },
          expect.anything(),
        );
      });

      test('Should pass the search and filter parameter as a squidex filter', async () => {
        await outputDataProvider.fetch({
          ...defaultParams,
          search: 'Title',
          filter: {
            documentType: ['Grant Document', 'Presentation'],
          },
        });

        const expectedFilter =
          "((data/documentType/iv eq 'Grant Document') or (data/documentType/iv eq 'Presentation')) " +
          "and contains(data/title/iv,'Title')";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });

      test('Should break up the search parameter into multiple words and send as a squidex filter', async () => {
        await outputDataProvider.fetch({
          ...defaultParams,
          search: 'some words',
        });

        const expectedFilter =
          "((contains(data/title/iv,'some')) or (contains(data/title/iv,'words')))";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });

      test('Should sanitise single quote in the search parameter by doubling it for the squidex filter', async () => {
        await outputDataProvider.fetch({
          ...defaultParams,
          search: "'",
        });

        const expectedFilter = "contains(data/title/iv,'''')";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });

      test('Should sanitise double quotation mark in the search parameter by escaping it', async () => {
        await outputDataProvider.fetch({
          ...defaultParams,
          search: '"',
        });

        const expectedFilter = "contains(data/title/iv,'\"')";
        expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
          expect.anything(),
          {
            ...expectedDefaultParams,
            filter: expectedFilter,
          },
          expect.anything(),
        );
      });
    });
  });

  describe('Create and update', () => {
    afterEach(() => {
      expect(nock.isDone()).toBe(true);
    });

    afterEach(() => {
      nock.cleanAll();
    });

    describe('Create', () => {
      test('Should send the correct requests to Squidex and return its ID', async () => {
        const outputRequest = getOutputCreateDataObject();
        const outputId = 'created-output-id';

        nock(baseUrl)
          // Create the Output
          .post(
            `/api/content/${appName}/outputs?publish=true`,
            getRestOutputCreateData(),
          )
          .reply(201, { id: outputId });

        const result = await outputDataProvider.create(outputRequest);
        expect(result).toEqual(outputId);
      });

      test('Should use the correct IDs for authors', async () => {
        const OutputRequest = getOutputCreateDataObject();
        OutputRequest.authors = [
          {
            externalAuthorId: 'some-external-user-id',
          },
          { userId: 'some-user-id' },
        ];
        const OutputId = 'created-output-id';

        nock(baseUrl)
          .post(
            `/api/content/${appName}/outputs?publish=true`,
            matches({
              authors: { iv: ['some-external-user-id', 'some-user-id'] },
            }),
          )
          .reply(201, { id: OutputId });

        await outputDataProvider.create(OutputRequest);
      });

      test('Should throw when fails to create the output - 400', async () => {
        const OutputRequest = getOutputCreateDataObject();

        nock(baseUrl)
          .post(`/api/content/${appName}/outputs?publish=true`)
          .reply(400);

        await expect(outputDataProvider.create(OutputRequest)).rejects.toThrow(
          GenericError,
        );
      });

      test('Should throw when fails to create the output - 500', async () => {
        const OutputRequest = getOutputCreateDataObject();
        nock(baseUrl)
          .post(`/api/content/${appName}/outputs?publish=true`)
          .reply(500);

        await expect(outputDataProvider.create(OutputRequest)).rejects.toThrow(
          GenericError,
        );
      });
    });

    describe('Update', () => {
      const outputId = 'updated-output-id';

      test('Should update the existing output and return its ID', async () => {
        const outputUpdateData = getOutputUpdateDataObject();

        const restOutputUpdateData = getRestOutputUpdateData();
        nock(baseUrl)
          .patch(`/api/content/${appName}/outputs/${outputId}`, {
            ...restOutputUpdateData,
            updatedBy: { iv: [outputUpdateData.updatedBy] },
          })
          .reply(201, { id: outputId });

        const result = await outputDataProvider.update(
          outputId,
          outputUpdateData,
        );
        expect(result).toEqual(outputId);
      });

      test('Should throw when fails to update the output - 400', async () => {
        const OutputRequest = getOutputUpdateDataObject();

        nock(baseUrl)
          .patch(`/api/content/${appName}/outputs/${outputId}`)
          .reply(400);

        await expect(
          outputDataProvider.update(outputId, OutputRequest),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw when fails to update the output - 500', async () => {
        const OutputRequest = getOutputUpdateDataObject();
        nock(baseUrl)
          .patch(`/api/content/${appName}/outputs/${outputId}`)
          .reply(500);

        await expect(
          outputDataProvider.update(outputId, OutputRequest),
        ).rejects.toThrow(GenericError);
      });

      test('Should throw when the output cannot be found', async () => {
        const OutputRequest = getOutputUpdateDataObject();

        nock(baseUrl)
          .patch(`/api/content/${appName}/outputs/${outputId}`)
          .reply(404);

        await expect(
          outputDataProvider.update(outputId, OutputRequest),
        ).rejects.toThrow(NotFoundError);
      });
    });
  });
});

describe('makeODataFilter', () => {
  test('converts the object to a format accepted by OData', () => {
    expect(
      makeODataFilter({
        title: 'some title',
        link: 'https://somelink.com',
        documentType: ['a', 'b', 'c'],
      }),
    ).toStrictEqual([
      { 'data/title/iv': 'some title' },
      { 'data/link/iv': 'https://somelink.com' },
      {
        or: [
          { 'data/documentType/iv': 'a' },
          { 'data/documentType/iv': 'b' },
          { 'data/documentType/iv': 'c' },
        ],
      },
    ]);
  });

  test('when the filter is not defined returns null', () => {
    expect(makeODataFilter()).toBeNull();
    expect(makeODataFilter(undefined)).toBeNull();
  });
});

type Author = NonNullable<
  NonNullable<FetchOutputQuery['findOutputsContent']>['flatData']['authors']
>[number];
type InternalUser = Extract<Author, { __typename: 'Users' }>;
type ExternalUser = Extract<Author, { __typename: 'ExternalAuthors' }>;
