import { ProjectsDataMembersRoleEnum } from '../../src/autogenerated-gql/graphql';
import { appName, baseUrl } from '../../src/config';
import {
  parseProjectToDataObject,
  ProjectSquidexDataProvider,
} from '../../src/data-providers/project.data-provider';
import {
  getGraphQLProject,
  getGraphQLProjectMember,
  getGraphQLProjectMilestone,
  getListProjectDataObject,
  getProjectDataObject,
  getSquidexProjectGraphqlResponse,
  getSquidexProjectsGraphqlResponse,
} from '../fixtures/project.fixtures';
import { getSquidexGraphqlClientMockServer } from '../mocks/squidex-graphql-client-with-server.mock';
import { getSquidexGraphqlClientMock } from '../mocks/squidex-graphql-client.mock';

describe('Project Data Provider', () => {
  const squidexGraphqlClientMock = getSquidexGraphqlClientMock();
  const projectDataProvider = new ProjectSquidexDataProvider(
    squidexGraphqlClientMock,
  );

  const squidexGraphqlClientMockServer = getSquidexGraphqlClientMockServer();
  const projectDataProviderMockGraphqlServer = new ProjectSquidexDataProvider(
    squidexGraphqlClientMockServer,
  );

  beforeEach(() => {
    jest.resetAllMocks();
  });

  describe('Fetch', () => {
    test('Should fetch the project from squidex graphql', async () => {
      const result = await projectDataProviderMockGraphqlServer.fetch();

      expect(result).toMatchObject(getListProjectDataObject());
    });

    test('Should return an empty result', async () => {
      const mockResponse = getSquidexProjectsGraphqlResponse();
      mockResponse.queryProjectsContentsWithTotal!.items = [];
      mockResponse.queryProjectsContentsWithTotal!.total = 0;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await projectDataProvider.fetch();
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result if the client returns a response with a null items property', async () => {
      const mockResponse = getSquidexProjectsGraphqlResponse();
      mockResponse.queryProjectsContentsWithTotal = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await projectDataProvider.fetch();
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result if the client returns a response with a null query property', async () => {
      const mockResponse = getSquidexProjectsGraphqlResponse();
      mockResponse.queryProjectsContentsWithTotal!.items = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await projectDataProvider.fetch();
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should default null title, startDate to an empty string', async () => {
      const mockResponse = getSquidexProjectsGraphqlResponse();
      const project = getGraphQLProject();
      project.flatData.title = null;
      project.flatData.startDate = null;
      mockResponse.queryProjectsContentsWithTotal!.items = [project];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const { items } = await projectDataProvider.fetch();
      expect(items[0]).toMatchObject({
        title: '',
        startDate: '',
      });
    });
    describe('FetchById', () => {
      test('Should fetch the project from squidex graphql', async () => {
        const result = await projectDataProviderMockGraphqlServer.fetchById(
          'project-id',
        );

        expect(result).toMatchObject(getProjectDataObject());
      });
      test('Should return null when the project is not found', async () => {
        const mockResponse = getSquidexProjectGraphqlResponse();
        mockResponse.findProjectsContent = null;
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        expect(await projectDataProvider.fetchById('not-found')).toBeNull();
      });
    });

    describe('Parsing', () => {
      test('the project is parsed', () => {
        const project = getGraphQLProject();
        const projectDataObject = parseProjectToDataObject(project);
        const expected = getProjectDataObject();
        expect(projectDataObject).toEqual(expected);
      });
      test('with no status', () => {
        const project = getGraphQLProject();
        project.flatData.status = null;
        expect(() => parseProjectToDataObject(project)).toThrowError(
          new TypeError('status is unknown'),
        );
      });

      describe('members', () => {
        test('undefined members returns empty array', () => {
          const Project = getGraphQLProject();
          Project.flatData.members = null;
          const { members } = parseProjectToDataObject(Project);
          expect(members).toEqual([]);
        });
        test('avatar urls are added if available', () => {
          const Project = getGraphQLProject();
          const member = getGraphQLProjectMember();
          member!.user![0]!.flatData.avatar = [{ id: 'avatar-id' }];
          Project.flatData.members = [member];
          const { members } = parseProjectToDataObject(Project);
          expect(members[0]?.avatarUrl).toEqual(
            `${baseUrl}/api/assets/${appName}/avatar-id`,
          );
        });

        test('should skip the user from the result if the user property is undefined', () => {
          const Project = getGraphQLProject();
          const member = getGraphQLProjectMember();
          member!.user = null;
          Project.flatData.members = [member];
          const { members } = parseProjectToDataObject(Project);
          expect(members).toEqual([]);
        });

        test('should skip the user from the result if the role property is undefined', () => {
          const Project = getGraphQLProject();
          const member = getGraphQLProjectMember();
          member!.role = null;
          Project.flatData.members = [member];
          const { members } = parseProjectToDataObject(Project);
          expect(members).toEqual([]);
        });
        test.each`
          role                                          | expectedRole
          ${ProjectsDataMembersRoleEnum.ProjectManager} | ${'Project manager'}
          ${ProjectsDataMembersRoleEnum.ProjectLead}    | ${'Project lead'}
          ${ProjectsDataMembersRoleEnum.ProjectCoLead}  | ${'Project co-lead'}
          ${ProjectsDataMembersRoleEnum.Contributor}    | ${'Contributor'}
          ${ProjectsDataMembersRoleEnum.Investigator}   | ${'Investigator'}
        `('should parse the role', ({ role, expectedRole }) => {
          const Project = getGraphQLProject();
          const member = getGraphQLProjectMember();
          member!.role = role;
          Project.flatData.members = [member];
          const { members } = parseProjectToDataObject(Project);
          expect(members[0]?.role).toEqual(expectedRole);
        });
      });
      test('pm emails are added if available', () => {
        const email = 'tony@starkenterprises.com';
        const project = getGraphQLProject();
        project.flatData.pmEmail = email;
        const { pmEmail } = parseProjectToDataObject(project);
        expect(pmEmail).toEqual(email);
      });

      test('lead emails are added if available', () => {
        const email = 'tony@starkenterprises.com';
        const project = getGraphQLProject();
        project.flatData.leadEmail = email;
        const { leadEmail } = parseProjectToDataObject(project);
        expect(leadEmail).toEqual(email);
      });

      test('description is added if available', () => {
        const expectedDescription = 'this is a description';
        const project = getGraphQLProject();
        project.flatData.description = expectedDescription;
        const { description } = parseProjectToDataObject(project);
        expect(description).toEqual(expectedDescription);
      });
      test('keywords are added', () => {
        const expectedKeywords = ['Outreach'];
        const project = getGraphQLProject();
        project.flatData.keywords = expectedKeywords;
        const { keywords } = parseProjectToDataObject(project);
        expect(keywords).toEqual(expectedKeywords);
      });

      test('keywords are valid', () => {
        const expectedKeywords = ['invalid-keyword'];
        const project = getGraphQLProject();
        project.flatData.keywords = expectedKeywords;
        expect(() => parseProjectToDataObject(project)).toThrow();
      });
    });

    describe('milestones', () => {
      test('undefined milestones returns empty array', () => {
        const project = getGraphQLProject();
        project.flatData.milestones = null;
        const { milestones } = parseProjectToDataObject(project);
        expect(milestones).toEqual([]);
      });
      test('if present it parses the link', () => {
        const project = getGraphQLProject();
        const milestone = getGraphQLProjectMilestone();
        const link = 'it-is-a-link';
        milestone.link = link;
        project.flatData.milestones = [milestone];
        const { milestones } = parseProjectToDataObject(project);
        expect(milestones[0]?.link).toEqual(link);
      });
      test('if present it parses the description', () => {
        const project = getGraphQLProject();
        const milestone = getGraphQLProjectMilestone();
        const description = 'it-is-a-description';
        milestone.description = description;
        project.flatData.milestones = [milestone];
        const { milestones } = parseProjectToDataObject(project);
        expect(milestones[0]?.description).toEqual(description);
      });
    });
  });
});
