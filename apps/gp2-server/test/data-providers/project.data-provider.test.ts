import { GenericError, NotFoundError } from '@asap-hub/errors';
import { gp2 as gp2Model } from '@asap-hub/model';
import { gp2 as gp2Squidex, SquidexRest } from '@asap-hub/squidex';
import nock, { DataMatcherMap } from 'nock';
import {
  ProjectsDataMembersRoleEnum,
  ProjectsDataResourcesTypeEnum,
} from '../../src/autogenerated-gql/graphql';
import { appName, baseUrl } from '../../src/config';
import {
  parseProjectToDataObject,
  ProjectSquidexDataProvider,
} from '../../src/data-providers/project.data-provider';
import { getAuthToken } from '../../src/utils/auth';
import {
  getGraphQLProject,
  getGraphQLProjectMember,
  getGraphQLProjectMilestone,
  getGraphQLProjectResource,
  getProjectDataObject,
  getProjectUpdateDataObject,
  getRestProjectUpdateData,
  getSquidexProjectGraphqlResponse,
  getSquidexProjectsGraphqlResponse,
} from '../fixtures/project.fixtures';
import { identity } from '../helpers/squidex';
import { getSquidexGraphqlClientMockServer } from '../mocks/squidex-graphql-client-with-server.mock';
import { getSquidexGraphqlClientMock } from '../mocks/squidex-graphql-client.mock';

describe('Project Data Provider', () => {
  const projectRestClient = new SquidexRest<
    gp2Squidex.RestProject,
    gp2Squidex.InputProject
  >(getAuthToken, 'projects', {
    appName,
    baseUrl,
  });

  const squidexGraphqlClientMock = getSquidexGraphqlClientMock();
  const projectDataProvider = new ProjectSquidexDataProvider(
    squidexGraphqlClientMock,
    projectRestClient,
  );

  const squidexGraphqlClientMockServer = getSquidexGraphqlClientMockServer();
  const projectDataProviderMockGraphqlServer = new ProjectSquidexDataProvider(
    squidexGraphqlClientMockServer,
    projectRestClient,
  );

  beforeAll(identity);
  beforeEach(jest.resetAllMocks);

  describe('Fetch', () => {
    const options = {
      take: 10,
      skip: 0,
    };

    test('Should fetch the project from squidex graphql', async () => {
      const result = await projectDataProviderMockGraphqlServer.fetch(options);

      const projectDataObject = getProjectDataObject();
      expect(result).toMatchObject({
        total: 1,
        items: [
          {
            ...projectDataObject,
            resources: projectDataObject.resources?.map(
              ({ id: _, ...resource }) => resource,
            ),
          },
        ],
      });
    });

    test('Should return an empty result', async () => {
      const mockResponse = getSquidexProjectsGraphqlResponse();
      mockResponse.queryProjectsContentsWithTotal!.items = [];
      mockResponse.queryProjectsContentsWithTotal!.total = 0;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await projectDataProvider.fetch(options);
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result if the client returns a response with a null items property', async () => {
      const mockResponse = getSquidexProjectsGraphqlResponse();
      mockResponse.queryProjectsContentsWithTotal = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await projectDataProvider.fetch(options);
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result if the client returns a response with a null query property', async () => {
      const mockResponse = getSquidexProjectsGraphqlResponse();
      mockResponse.queryProjectsContentsWithTotal!.items = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await projectDataProvider.fetch(options);
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should default null title, startDate to an empty string', async () => {
      const mockResponse = getSquidexProjectsGraphqlResponse();
      const project = getGraphQLProject();
      project.flatData.title = null;
      project.flatData.startDate = null;
      mockResponse.queryProjectsContentsWithTotal!.items = [project];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const { items } = await projectDataProvider.fetch(options);
      expect(items[0]).toMatchObject({
        title: '',
        startDate: '',
      });
    });

    test('Should default null calendars to undefined', async () => {
      const mockResponse = getSquidexProjectsGraphqlResponse();
      const project = getGraphQLProject();
      project.flatData.calendars = null;
      mockResponse.queryProjectsContentsWithTotal!.items = [project];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const { items } = await projectDataProvider.fetch(options);
      expect(items[0]).toMatchObject({
        calendar: undefined,
      });
    });
  });

  describe('FetchById', () => {
    test('Should fetch the project from squidex graphql', async () => {
      const result = await projectDataProviderMockGraphqlServer.fetchById(
        'project-id',
      );

      const projectDataObject = getProjectDataObject();
      expect(result).toMatchObject({
        ...projectDataObject,
        resources: projectDataObject.resources!.map(
          ({ id: _, ...resource }) => resource,
        ),
      });
    });

    test('Should return null when the project is not found', async () => {
      const mockResponse = getSquidexProjectGraphqlResponse();
      mockResponse.findProjectsContent = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(await projectDataProvider.fetchById('not-found')).toBeNull();
    });
  });

  describe('Parsing', () => {
    test('the project is parsed', () => {
      const project = getGraphQLProject();
      const projectDataObject = parseProjectToDataObject(project);
      const expected = getProjectDataObject();
      expect(projectDataObject).toEqual({
        ...expected,
        resources: expected.resources!.map(
          ({ id: _, ...resource }) => resource,
        ),
      });
    });

    test('with no status', () => {
      const project = getGraphQLProject();
      project.flatData.status = null;
      expect(() => parseProjectToDataObject(project)).toThrowError(
        new TypeError('status is unknown'),
      );
    });

    describe('traineeProject', () => {
      test('if doesnt exist it returns as false', () => {
        const project = getGraphQLProject();
        project.flatData.traineeProject = null;
        const { traineeProject } = parseProjectToDataObject(project);
        expect(traineeProject).toEqual(false);
      });

      test('returns if available', () => {
        const project = getGraphQLProject();
        project.flatData.traineeProject = true;
        const { traineeProject } = parseProjectToDataObject(project);
        expect(traineeProject).toEqual(true);
      });
    });

    describe('opportunitiesLink', () => {
      test('if doesnt exist it returns as false', () => {
        const project = getGraphQLProject();
        project.flatData.opportunitiesLink = null;
        const { opportunitiesLink } = parseProjectToDataObject(project);
        expect(opportunitiesLink).toBeUndefined();
      });

      test('returns if available', () => {
        const project = getGraphQLProject();
        project.flatData.opportunitiesLink = 'https://link';
        const { opportunitiesLink } = parseProjectToDataObject(project);
        expect(opportunitiesLink).toEqual('https://link');
      });
    });

    describe('members', () => {
      test('undefined members returns empty array', () => {
        const project = getGraphQLProject();
        project.flatData.members = null;
        const { members } = parseProjectToDataObject(project);
        expect(members).toEqual([]);
      });

      test('avatar urls are added if available', () => {
        const project = getGraphQLProject();
        const member = getGraphQLProjectMember();
        member!.user![0]!.flatData.avatar = [{ id: 'avatar-id' }];
        project.flatData.members = [member];
        const { members } = parseProjectToDataObject(project);
        expect(members[0]?.avatarUrl).toEqual(
          `${baseUrl}/api/assets/${appName}/avatar-id`,
        );
      });

      test('should skip the user from the result if the user property is undefined', () => {
        const project = getGraphQLProject();
        const member = getGraphQLProjectMember();
        member!.user = null;
        project.flatData.members = [member];
        const { members } = parseProjectToDataObject(project);
        expect(members).toEqual([]);
      });

      test('should skip the user from the result if the role property is undefined', () => {
        const project = getGraphQLProject();
        const member = getGraphQLProjectMember();
        member!.role = null;
        project.flatData.members = [member];
        const { members } = parseProjectToDataObject(project);
        expect(members).toEqual([]);
      });

      test('should skip the user from the result if the user is not onboarded', () => {
        const project = getGraphQLProject();
        const member = getGraphQLProjectMember();
        member!.user![0]!.flatData.onboarded = false;
        project.flatData.members = [member];
        const { members } = parseProjectToDataObject(project);
        expect(members).toEqual([]);
      });

      test.each`
        role                                          | expectedRole
        ${ProjectsDataMembersRoleEnum.ProjectManager} | ${'Project manager'}
        ${ProjectsDataMembersRoleEnum.ProjectLead}    | ${'Project lead'}
        ${ProjectsDataMembersRoleEnum.ProjectCoLead}  | ${'Project co-lead'}
        ${ProjectsDataMembersRoleEnum.Contributor}    | ${'Contributor'}
        ${ProjectsDataMembersRoleEnum.Investigator}   | ${'Investigator'}
      `('should parse the role', ({ role, expectedRole }) => {
        const project = getGraphQLProject();
        const member = getGraphQLProjectMember();
        member!.role = role;
        project.flatData.members = [member];
        const { members } = parseProjectToDataObject(project);
        expect(members[0]?.role).toEqual(expectedRole);
      });
    });

    describe('resources', () => {
      test('should map a resource note', () => {
        const project = getGraphQLProject();
        const { resources } = parseProjectToDataObject(project);
        const { resources: expectedResources } = getProjectDataObject();
        expect(resources).toStrictEqual(
          expectedResources!.map(({ id: _, ...resource }) => resource),
        );
      });

      test('should ignore an external link for a resource note', () => {
        const project = getGraphQLProject();
        const resource = getGraphQLProjectResource();
        resource.type = ProjectsDataResourcesTypeEnum.Note;
        resource.externalLink = 'some external link';
        project.flatData.resources = [resource];
        const { resources } = parseProjectToDataObject(project);
        const { resources: expectedResources } = getProjectDataObject();
        expect(resources).toStrictEqual(
          expectedResources?.map(({ id: _, ...resource }) => resource),
        );
      });

      test('should map a resource link', () => {
        const project = getGraphQLProject();
        const externalLink = 'this is an external link';
        const resource = getGraphQLProjectResource();
        resource.type = ProjectsDataResourcesTypeEnum.Link;
        resource.externalLink = externalLink;
        project.flatData.resources = [resource];
        const { resources } = parseProjectToDataObject(project);
        const { resources: expectedResources } = getProjectDataObject();
        expect(resources).toEqual([
          {
            ...expectedResources!!.map(({ id: _, ...resource }) => resource)[0],
            type: 'Link',
            externalLink,
          },
        ]);
      });

      test('should ignore a resource if title is undefined.', () => {
        const project = getGraphQLProject();
        const resource = getGraphQLProjectResource();
        resource.title = null;
        project.flatData.resources = [resource];
        const { resources } = parseProjectToDataObject(project);
        expect(resources).toEqual([]);
      });

      test('should return a resource if description is undefined.', () => {
        const project = getGraphQLProject();
        const resource = getGraphQLProjectResource();
        resource.description = null;
        project.flatData.resources = [resource];
        const { resources } = parseProjectToDataObject(project);
        const description = resources![0]?.description;
        expect(description).toBeUndefined();
      });

      test('should ignore a resource if external Link is undefined for a Link.', () => {
        const project = getGraphQLProject();
        const externalLink = null;
        const resource = getGraphQLProjectResource();
        resource.type = ProjectsDataResourcesTypeEnum.Link;
        resource.externalLink = externalLink;
        project.flatData.resources = [resource];
        const { resources } = parseProjectToDataObject(project);
        expect(resources).toEqual([]);
      });

      test('undefined resources returns empty array', () => {
        const project = getGraphQLProject();
        project.flatData.resources = null;
        const { resources } = parseProjectToDataObject(project);
        expect(resources).toEqual([]);
      });
    });

    test('pm emails are added if available', () => {
      const email = 'tony@starkenterprises.com';
      const project = getGraphQLProject();
      project.flatData.pmEmail = email;
      const { pmEmail } = parseProjectToDataObject(project);
      expect(pmEmail).toEqual(email);
    });

    test('lead emails are added if available', () => {
      const email = 'tony@starkenterprises.com';
      const project = getGraphQLProject();
      project.flatData.leadEmail = email;
      const { leadEmail } = parseProjectToDataObject(project);
      expect(leadEmail).toEqual(email);
    });

    test('description is added if available', () => {
      const expectedDescription = 'this is a description';
      const project = getGraphQLProject();
      project.flatData.description = expectedDescription;
      const { description } = parseProjectToDataObject(project);
      expect(description).toEqual(expectedDescription);
    });

    test.each(gp2Model.keywords)('keywords are added - %s', (keyword) => {
      const expectedKeywords = [keyword];
      const project = getGraphQLProject();
      project.flatData.keywords = expectedKeywords;
      const { keywords } = parseProjectToDataObject(project);
      expect(keywords).toEqual(expectedKeywords);
    });

    test('keywords are valid', () => {
      const expectedKeywords = ['invalid-keyword'];
      const project = getGraphQLProject();
      project.flatData.keywords = expectedKeywords;
      expect(() => parseProjectToDataObject(project)).toThrow();
    });

    describe('milestones', () => {
      test('undefined milestones returns empty array', () => {
        const project = getGraphQLProject();
        project.flatData.milestones = null;
        const { milestones } = parseProjectToDataObject(project);
        expect(milestones).toEqual([]);
      });

      test('if present it parses the link', () => {
        const project = getGraphQLProject();
        const milestone = getGraphQLProjectMilestone();
        const link = 'it-is-a-link';
        milestone.link = link;
        project.flatData.milestones = [milestone];
        const { milestones } = parseProjectToDataObject(project);
        expect(milestones[0]?.link).toEqual(link);
      });

      test('if present it parses the description', () => {
        const project = getGraphQLProject();
        const milestone = getGraphQLProjectMilestone();
        const description = 'it-is-a-description';
        milestone.description = description;
        project.flatData.milestones = [milestone];
        const { milestones } = parseProjectToDataObject(project);
        expect(milestones[0]?.description).toEqual(description);
      });

      test('throws if status is not provided', () => {
        const workingGroup = getGraphQLProject();
        const milestone = getGraphQLProjectMilestone();
        milestone.status = null;
        workingGroup.flatData.milestones = [milestone];
        const callFunction = () => parseProjectToDataObject(workingGroup);
        expect(callFunction).toThrow(TypeError);
        expect(callFunction).toThrow('milestone status is unknown');
      });
    });
  });

  describe('Update', () => {
    afterEach(nock.cleanAll);
    const projectId = '11';

    test('Should update the existing project', async () => {
      const projectUpdateData = getProjectUpdateDataObject();

      const restProjectUpdateData = getRestProjectUpdateData();
      nock(baseUrl)
        .patch(
          `/api/content/${appName}/projects/${projectId}`,
          restProjectUpdateData as DataMatcherMap,
        )
        .reply(201, { id: projectId });

      await projectDataProvider.update(projectId, projectUpdateData);
      expect(nock.isDone()).toBe(true);
    });

    test.each([400, 500])(
      'Should throw when fails to update the project - %s',
      async (status) => {
        const projectUpdateData = getProjectUpdateDataObject();

        nock(baseUrl)
          .patch(`/api/content/${appName}/projects/${projectId}`)
          .reply(status);

        await expect(
          projectDataProvider.update(projectId, projectUpdateData),
        ).rejects.toThrow(GenericError);
      },
    );

    test('Should throw when the project cannot be found', async () => {
      const projectUpdateData = getProjectUpdateDataObject();

      nock(baseUrl)
        .patch(`/api/content/${appName}/projects/${projectId}`)
        .reply(404);

      await expect(
        projectDataProvider.update(projectId, projectUpdateData),
      ).rejects.toThrow(NotFoundError);
    });
  });
});
