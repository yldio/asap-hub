import { NotFoundError } from '@asap-hub/errors';
import { FetchUsersOptions } from '@asap-hub/model';
import { RestUser, SquidexRest } from '@asap-hub/squidex';
import nock from 'nock';
import { DegreeEnum } from '../../src/autogenerated-gql/graphql';
import { appName, baseUrl } from '../../src/config';
import { UserSquidexDataProvider } from '../../src/data-providers/user.data-provider';
import { getAuthToken } from '../../src/utils/auth';
import {
  fetchUserResponse,
  getGraphQLUser,
  getSquidexUserGraphqlResponse,
  getSquidexUsersGraphqlResponse,
  getUserDataObject,
} from '../fixtures/user.fixtures';
import { identity } from '../helpers/squidex';
import { getSquidexGraphqlClientMockServer } from '../mocks/squidex-graphql-client-with-server.mock';
import { getSquidexGraphqlClientMock } from '../mocks/squidex-graphql-client.mock';

describe('User data provider', () => {
  const userRestClient = new SquidexRest<RestUser>(getAuthToken, 'users', {
    appName,
    baseUrl,
  });
  const squidexGraphqlClientMock = getSquidexGraphqlClientMock();
  const userDataProvider = new UserSquidexDataProvider(
    squidexGraphqlClientMock,
    userRestClient,
  );

  const squidexGraphqlClientMockServer = getSquidexGraphqlClientMockServer();
  const usersMockGraphqlServer = new UserSquidexDataProvider(
    squidexGraphqlClientMockServer,
    userRestClient,
  );
  beforeAll(() => {
    identity();
  });
  beforeEach(() => {
    jest.resetAllMocks();
  });
  describe('FetchById', () => {
    test('Should fetch the users from squidex graphql', async () => {
      const result = await usersMockGraphqlServer.fetchById('user-id');

      expect(result).toMatchObject(getUserDataObject());
    });
    test('Should return null when the user is not found', async () => {
      const mockResponse = getSquidexUserGraphqlResponse();
      mockResponse.findUsersContent = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(await userDataProvider.fetchById('not-found')).toBeNull();
    });

    test('Should return the user when it finds it', async () => {
      const mockResponse = getSquidexUserGraphqlResponse();
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetchById('user-id');
      expect(result).toEqual(getUserDataObject());
    });
    test('Should throw when the user has an invalid role', async () => {
      const invalidRoleUser = getGraphQLUser();
      invalidRoleUser.flatData.role = 'invalid-role';
      const mockResponse = getSquidexUserGraphqlResponse(invalidRoleUser);
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(() =>
        userDataProvider.fetchById('user-id'),
      ).rejects.toThrowErrorMatchingInlineSnapshot('"Invalid user role"');
    });

    test('Should throw when the user has an invalid region', async () => {
      const invalidUser = getGraphQLUser();
      invalidUser.flatData.region = 'invalid-region';
      const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(() =>
        userDataProvider.fetchById('user-id'),
      ).rejects.toThrowErrorMatchingInlineSnapshot('"Invalid user region"');
    });
    test('Should correctly map MD, PhD Correctly', async () => {
      const degreeUser = getGraphQLUser();
      degreeUser.flatData.degree = ['MD_PhD'] as DegreeEnum[];
      const mockResponse = getSquidexUserGraphqlResponse(degreeUser);
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetchById('user-id');
      expect(result?.degrees).toEqual(['MD, PhD']);
    });
  });

  describe('update', () => {
    afterEach(() => {
      nock.cleanAll();
    });

    const userId = 'user-id';
    test('Should throw when sync asset fails', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          firstName: { iv: 'John' },
        })
        .reply(404);

      await expect(
        userDataProvider.update(userId, { firstName: 'John' }),
      ).rejects.toThrow(NotFoundError);
      expect(nock.isDone()).toBe(true);
    });
    test('Should update job title through a clean-update', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          firstName: { iv: 'John' },
        })
        .reply(200, fetchUserResponse());

      expect(
        await userDataProvider.update(userId, { firstName: 'John' }),
      ).not.toBeDefined();
      expect(nock.isDone()).toBe(true);
    });
    test('Should update the region and last name through a clean-update', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          region: { iv: 'Europe' },
          lastName: { iv: 'Smith' },
        })
        .reply(200, fetchUserResponse());
      expect(
        await userDataProvider.update(userId, {
          region: 'Europe',
          lastName: 'Smith',
        }),
      ).not.toBeDefined();
      expect(nock.isDone()).toBe(true);
    });
  });

  describe('Fetch', () => {
    beforeEach(() => {
      jest.clearAllMocks();
    });
    test('Should fetch the users from squidex graphql', async () => {
      const result = await usersMockGraphqlServer.fetch({});

      expect(result).toMatchObject({ total: 1, items: [getUserDataObject()] });
    });
    test('Should return an empty result', async () => {
      const mockResponse = getSquidexUsersGraphqlResponse();
      mockResponse.queryUsersContentsWithTotal!.items = [];
      mockResponse.queryUsersContentsWithTotal!.total = 0;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetch({});
      expect(result).toEqual({ total: 0, items: [] });
    });
    test('Should return an empty result when the client returns a response with query property set to null', async () => {
      const mockResponse = getSquidexUsersGraphqlResponse();
      mockResponse.queryUsersContentsWithTotal = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetch({});
      expect(result).toEqual({ total: 0, items: [] });
    });
    test('Should return an empty result when the client returns a response with items property set to null', async () => {
      const mockResponse = getSquidexUsersGraphqlResponse();
      mockResponse.queryUsersContentsWithTotal!.items = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetch({});
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should query with filters and return the users', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: FetchUsersOptions = {
        take: 12,
        skip: 2,
        search: 'first last',
        filter: {
          role: ['role', 'Staff'],
        },
      };
      const users = await userDataProvider.fetch(fetchOptions);

      const filterQuery =
        "((contains(data/firstName/iv, 'first')" +
        " or contains(data/lastName/iv, 'first'))" +
        ' and' +
        " (contains(data/firstName/iv, 'last')" +
        " or contains(data/lastName/iv, 'last')))";
      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 12,
          skip: 2,
          filter: filterQuery,
        },
      );
      expect(users).toMatchObject({ total: 1, items: [getUserDataObject()] });
    });
    test('Should sanitise single quotes by doubling them and encoding to hex', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: FetchUsersOptions = {
        take: 12,
        skip: 2,
        search: "'",
      };
      await userDataProvider.fetch(fetchOptions);

      const expectedFilter =
        "((contains(data/firstName/iv, '%27%27')" +
        " or contains(data/lastName/iv, '%27%27')))";

      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 12,
          skip: 2,
          filter: expectedFilter,
        },
      );
    });
    test('Should sanitise double quotation mark by encoding to hex', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: FetchUsersOptions = {
        take: 12,
        skip: 2,
        search: '"',
      };
      await userDataProvider.fetch(fetchOptions);

      const expectedFilter =
        "((contains(data/firstName/iv, '%22')" +
        " or contains(data/lastName/iv, '%22')))";

      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 12,
          skip: 2,
          filter: expectedFilter,
        },
      );
    });
    test('Should search with special characters', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: FetchUsersOptions = {
        take: 12,
        skip: 2,
        search: 'Solène',
      };
      await userDataProvider.fetch(fetchOptions);

      const expectedFilter =
        "((contains(data/firstName/iv, 'Solène')" +
        " or contains(data/lastName/iv, 'Solène')))";

      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 12,
          skip: 2,
          filter: expectedFilter,
        },
      );
    });
    test('Should query with code filters and return the users', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: FetchUsersOptions = {
        take: 1,
        skip: 0,
        filter: {
          onboarded: false,
          hidden: false,
          code: 'a-code',
        },
      };
      const users = await userDataProvider.fetch(fetchOptions);

      const filterQuery = "data/connections/iv/code eq 'a-code'";
      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 1,
          skip: 0,
          filter: filterQuery,
        },
      );
      expect(users).toMatchObject({ total: 1, items: [getUserDataObject()] });
    });
  });
});
