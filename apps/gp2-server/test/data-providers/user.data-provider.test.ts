import { NotFoundError } from '@asap-hub/errors';
import { FetchUsersOptions } from '@asap-hub/model';
import { RestUser, SquidexRest } from '@asap-hub/squidex';
import nock from 'nock';
import {
  UsersDataDegreeEnum,
  UsersDataRegionEnum,
  UsersDataRoleEnum,
} from '../../src/autogenerated-gql/graphql';
import { appName, baseUrl } from '../../src/config';
import { UserSquidexDataProvider } from '../../src/data-providers/user.data-provider';
import { getAuthToken } from '../../src/utils/auth';
import {
  fetchUserResponse,
  getGraphQLUser,
  getSquidexUserGraphqlResponse,
  getSquidexUsersGraphqlResponse,
  getUserDataObject,
} from '../fixtures/user.fixtures';
import { identity } from '../helpers/squidex';
import { getSquidexGraphqlClientMockServer } from '../mocks/squidex-graphql-client-with-server.mock';
import { getSquidexGraphqlClientMock } from '../mocks/squidex-graphql-client.mock';

describe('User data provider', () => {
  const userRestClient = new SquidexRest<RestUser>(getAuthToken, 'users', {
    appName,
    baseUrl,
  });
  const squidexGraphqlClientMock = getSquidexGraphqlClientMock();
  const userDataProvider = new UserSquidexDataProvider(
    squidexGraphqlClientMock,
    userRestClient,
  );

  const squidexGraphqlClientMockServer = getSquidexGraphqlClientMockServer();
  const usersMockGraphqlServer = new UserSquidexDataProvider(
    squidexGraphqlClientMockServer,
    userRestClient,
  );
  beforeAll(() => {
    identity();
  });
  beforeEach(() => {
    jest.resetAllMocks();
  });
  describe('FetchById', () => {
    test('Should fetch the users from squidex graphql', async () => {
      const result = await usersMockGraphqlServer.fetchById('user-id');

      expect(result).toMatchObject(getUserDataObject());
    });
    test('Should return null when the user is not found', async () => {
      const mockResponse = getSquidexUserGraphqlResponse();
      mockResponse.findUsersContent = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(await userDataProvider.fetchById('not-found')).toBeNull();
    });

    test('Should return the user when it finds it', async () => {
      const mockResponse = getSquidexUserGraphqlResponse();
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetchById('user-id');
      expect(result).toEqual(getUserDataObject());
    });
    test('Should throw when the user has role undefined', async () => {
      const invalidRoleUser = getGraphQLUser();
      invalidRoleUser.flatData.role = null;
      const mockResponse = getSquidexUserGraphqlResponse(invalidRoleUser);
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(() =>
        userDataProvider.fetchById('user-id'),
      ).rejects.toThrowErrorMatchingInlineSnapshot('"Role not defined: null"');
    });

    test('Should throw when the user has region undefined', async () => {
      const invalidUser = getGraphQLUser();
      invalidUser.flatData.region = null;
      const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(() =>
        userDataProvider.fetchById('user-id'),
      ).rejects.toThrowErrorMatchingInlineSnapshot(
        '"Region not defined: null"',
      );
    });
    test('Should correctly map MD, PhD Correctly', async () => {
      const degreeUser = getGraphQLUser();
      degreeUser.flatData.degree = [UsersDataDegreeEnum.MdPhD];
      const mockResponse = getSquidexUserGraphqlResponse(degreeUser);
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetchById('user-id');
      expect(result?.degrees).toEqual(['MD, PhD']);
    });

    test.each`
      region                                       | expected
      ${UsersDataRegionEnum.Africa}                | ${'Africa'}
      ${UsersDataRegionEnum.Asia}                  | ${'Asia'}
      ${UsersDataRegionEnum.AustraliaAustraliasia} | ${'Australia/Australiasia'}
      ${UsersDataRegionEnum.Europe}                | ${'Europe'}
      ${UsersDataRegionEnum.NorthAmerica}          | ${'North America'}
      ${UsersDataRegionEnum.SouthAmerica}          | ${'South America'}
      ${UsersDataRegionEnum.LatinAmerica}          | ${'Latin America'}
    `(
      'Should correctly map regions $region => $expected',
      async ({ region, expected }) => {
        const user = getGraphQLUser();
        user.flatData.region = region;
        const mockResponse = getSquidexUserGraphqlResponse(user);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.region).toEqual(expected);
      },
    );

    test.each`
      role                                         | expected
      ${UsersDataRoleEnum.WorkingGroupParticipant} | ${'Working Group Participant'}
      ${UsersDataRoleEnum.NetworkInvestigator}     | ${'Network Investigator'}
      ${UsersDataRoleEnum.NetworkCollaborator}     | ${'Network Collaborator'}
      ${UsersDataRoleEnum.Administrator}           | ${'Administrator'}
      ${UsersDataRoleEnum.Trainee}                 | ${'Trainee'}
    `(
      'Should correctly map regions $role => $expected',
      async ({ role, expected }) => {
        const user = getGraphQLUser();
        user.flatData.role = role;
        const mockResponse = getSquidexUserGraphqlResponse(user);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.role).toEqual(expected);
      },
    );
  });

  describe('update', () => {
    afterEach(() => {
      nock.cleanAll();
    });

    const userId = 'user-id';
    test('Should throw when sync asset fails', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          firstName: { iv: 'John' },
        })
        .reply(404);

      await expect(
        userDataProvider.update(userId, { firstName: 'John' }),
      ).rejects.toThrow(NotFoundError);
      expect(nock.isDone()).toBe(true);
    });
    test('Should update job title through a clean-update', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          firstName: { iv: 'John' },
        })
        .reply(200, fetchUserResponse());

      expect(
        await userDataProvider.update(userId, { firstName: 'John' }),
      ).not.toBeDefined();
      expect(nock.isDone()).toBe(true);
    });
    test.each`
      region                      | expected
      ${'Africa'}                 | ${UsersDataRegionEnum.Africa}
      ${'Asia'}                   | ${UsersDataRegionEnum.Asia}
      ${'Australia/Australiasia'} | ${UsersDataRegionEnum.AustraliaAustraliasia}
      ${'Europe'}                 | ${UsersDataRegionEnum.Europe}
      ${'North America'}          | ${UsersDataRegionEnum.NorthAmerica}
      ${'South America'}          | ${UsersDataRegionEnum.SouthAmerica}
      ${'Latin America'}          | ${UsersDataRegionEnum.LatinAmerica}
    `(
      'Should update the region and last name through a clean-update $region => $expected',
      async ({ region, expected }) => {
        nock(baseUrl)
          .patch(`/api/content/${appName}/users/${userId}`, {
            region: { iv: expected },
            lastName: { iv: 'Stark' },
          })
          .reply(200, fetchUserResponse());
        expect(
          await userDataProvider.update(userId, {
            region,
            lastName: 'Stark',
          }),
        ).not.toBeDefined();
        expect(nock.isDone()).toBe(true);
      },
    );
    test.each`
      role                           | expected
      ${'Working Group Participant'} | ${UsersDataRoleEnum.WorkingGroupParticipant}
      ${'Network Investigator'}      | ${UsersDataRoleEnum.NetworkInvestigator}
      ${'Network Collaborator'}      | ${UsersDataRoleEnum.NetworkCollaborator}
      ${'Administrator'}             | ${UsersDataRoleEnum.Administrator}
      ${'Trainee'}                   | ${UsersDataRoleEnum.Trainee}
    `(
      'Should update the role and last name through a clean-update $role => $expected',
      async ({ role, expected }) => {
        nock(baseUrl)
          .patch(`/api/content/${appName}/users/${userId}`, {
            role: { iv: expected },
            lastName: { iv: 'Stark' },
          })
          .reply(200, fetchUserResponse());
        expect(
          await userDataProvider.update(userId, {
            role,
            lastName: 'Stark',
          }),
        ).not.toBeDefined();
        expect(nock.isDone()).toBe(true);
      },
    );
    test('Should update the degree MD, PhD => MD_PhD', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          degree: { iv: [UsersDataDegreeEnum.MdPhD] },
          lastName: { iv: 'Stark' },
        })
        .reply(200, fetchUserResponse());
      expect(
        await userDataProvider.update(userId, {
          degrees: ['MD, PhD'],
          lastName: 'Stark',
        }),
      ).not.toBeDefined();
      expect(nock.isDone()).toBe(true);
    });
    test('Should update the other degrees', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          degree: { iv: [UsersDataDegreeEnum.PhD] },
          lastName: { iv: 'Stark' },
        })
        .reply(200, fetchUserResponse());
      expect(
        await userDataProvider.update(userId, {
          degrees: ['PhD'],
          lastName: 'Stark',
        }),
      ).not.toBeDefined();
      expect(nock.isDone()).toBe(true);
    });
  });

  describe('Fetch', () => {
    beforeEach(() => {
      jest.clearAllMocks();
    });
    test('Should fetch the users from squidex graphql', async () => {
      const result = await usersMockGraphqlServer.fetch({});

      expect(result).toMatchObject({ total: 1, items: [getUserDataObject()] });
    });
    test('Should return an empty result', async () => {
      const mockResponse = getSquidexUsersGraphqlResponse();
      mockResponse.queryUsersContentsWithTotal!.items = [];
      mockResponse.queryUsersContentsWithTotal!.total = 0;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetch({});
      expect(result).toEqual({ total: 0, items: [] });
    });
    test('Should return an empty result when the client returns a response with query property set to null', async () => {
      const mockResponse = getSquidexUsersGraphqlResponse();
      mockResponse.queryUsersContentsWithTotal = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetch({});
      expect(result).toEqual({ total: 0, items: [] });
    });
    test('Should return an empty result when the client returns a response with items property set to null', async () => {
      const mockResponse = getSquidexUsersGraphqlResponse();
      mockResponse.queryUsersContentsWithTotal!.items = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetch({});
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should query with filters and return the users', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: FetchUsersOptions = {
        take: 12,
        skip: 2,
        search: 'first last',
        filter: {
          role: ['role', 'Staff'],
        },
      };
      const users = await userDataProvider.fetch(fetchOptions);

      const filterQuery =
        "((contains(data/firstName/iv, 'first')" +
        " or contains(data/lastName/iv, 'first'))" +
        ' and' +
        " (contains(data/firstName/iv, 'last')" +
        " or contains(data/lastName/iv, 'last')))";
      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 12,
          skip: 2,
          filter: filterQuery,
        },
      );
      expect(users).toMatchObject({ total: 1, items: [getUserDataObject()] });
    });
    test('Should sanitise single quotes by doubling them and encoding to hex', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: FetchUsersOptions = {
        take: 12,
        skip: 2,
        search: "'",
      };
      await userDataProvider.fetch(fetchOptions);

      const expectedFilter =
        "((contains(data/firstName/iv, '%27%27')" +
        " or contains(data/lastName/iv, '%27%27')))";

      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 12,
          skip: 2,
          filter: expectedFilter,
        },
      );
    });
    test('Should sanitise double quotation mark by encoding to hex', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: FetchUsersOptions = {
        take: 12,
        skip: 2,
        search: '"',
      };
      await userDataProvider.fetch(fetchOptions);

      const expectedFilter =
        "((contains(data/firstName/iv, '%22')" +
        " or contains(data/lastName/iv, '%22')))";

      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 12,
          skip: 2,
          filter: expectedFilter,
        },
      );
    });
    test('Should search with special characters', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: FetchUsersOptions = {
        take: 12,
        skip: 2,
        search: 'Solène',
      };
      await userDataProvider.fetch(fetchOptions);

      const expectedFilter =
        "((contains(data/firstName/iv, 'Solène')" +
        " or contains(data/lastName/iv, 'Solène')))";

      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 12,
          skip: 2,
          filter: expectedFilter,
        },
      );
    });
    test('Should query with code filters and return the users', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: FetchUsersOptions = {
        take: 1,
        skip: 0,
        filter: {
          onboarded: false,
          hidden: false,
          code: 'a-code',
        },
      };
      const users = await userDataProvider.fetch(fetchOptions);

      const filterQuery = "data/connections/iv/code eq 'a-code'";
      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 1,
          skip: 0,
          filter: filterQuery,
        },
      );
      expect(users).toMatchObject({ total: 1, items: [getUserDataObject()] });
    });
  });
});
