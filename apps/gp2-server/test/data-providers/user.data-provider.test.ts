import { NotFoundError } from '@asap-hub/errors';
import { FetchUsersOptions, gp2 } from '@asap-hub/model';
import { RestUser, SquidexRest } from '@asap-hub/squidex';
import nock from 'nock';
import {
  UsersDataDegreeEnum,
  UsersDataRegionEnum,
  UsersDataRoleEnum,
} from '../../src/autogenerated-gql/graphql';
import { appName, baseUrl } from '../../src/config';
import { UserSquidexDataProvider } from '../../src/data-providers/user.data-provider';
import { getAuthToken } from '../../src/utils/auth';
import {
  fetchUserResponse,
  getGraphQLUser,
  getSquidexUserGraphqlResponse,
  getSquidexUsersGraphqlResponse,
  getUserDataObject,
} from '../fixtures/user.fixtures';
import { identity } from '../helpers/squidex';
import { getSquidexGraphqlClientMockServer } from '../mocks/squidex-graphql-client-with-server.mock';
import { getSquidexGraphqlClientMock } from '../mocks/squidex-graphql-client.mock';

describe('User data provider', () => {
  const userRestClient = new SquidexRest<RestUser>(getAuthToken, 'users', {
    appName,
    baseUrl,
  });
  const squidexGraphqlClientMock = getSquidexGraphqlClientMock();
  const userDataProvider = new UserSquidexDataProvider(
    squidexGraphqlClientMock,
    userRestClient,
  );

  const squidexGraphqlClientMockServer = getSquidexGraphqlClientMockServer();
  const usersMockGraphqlServer = new UserSquidexDataProvider(
    squidexGraphqlClientMockServer,
    userRestClient,
  );
  beforeAll(() => {
    identity();
  });
  beforeEach(() => {
    jest.resetAllMocks();
  });
  describe('FetchById', () => {
    test('Should fetch the users from squidex graphql', async () => {
      const result = await usersMockGraphqlServer.fetchById('user-id');

      expect(result).toMatchObject(getUserDataObject());
    });
    test('Should return null when the user is not found', async () => {
      const mockResponse = getSquidexUserGraphqlResponse();
      mockResponse.findUsersContent = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(await userDataProvider.fetchById('not-found')).toBeNull();
    });

    test('Should return the user when it finds it', async () => {
      const mockResponse = getSquidexUserGraphqlResponse();
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetchById('user-id');
      expect(result).toEqual(getUserDataObject());
    });
    test('Should throw when the user has role undefined', async () => {
      const invalidRoleUser = getGraphQLUser();
      invalidRoleUser.flatData.role = null;
      const mockResponse = getSquidexUserGraphqlResponse(invalidRoleUser);
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(() =>
        userDataProvider.fetchById('user-id'),
      ).rejects.toThrowErrorMatchingInlineSnapshot('"Role not defined: null"');
    });

    test('Should throw when the user has region undefined', async () => {
      const invalidUser = getGraphQLUser();
      invalidUser.flatData.region = null;
      const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(() =>
        userDataProvider.fetchById('user-id'),
      ).rejects.toThrowErrorMatchingInlineSnapshot(
        '"Region not defined: null"',
      );
    });

    test.each(Object.values(UsersDataDegreeEnum))(
      'Should correctly map MD, PhD Correctly - %s',
      async (degree) => {
        const expected =
          degree === UsersDataDegreeEnum.MdPhD ? 'MD, PhD' : degree;
        const degreeUser = getGraphQLUser();
        degreeUser.flatData.degree = [degree];
        const mockResponse = getSquidexUserGraphqlResponse(degreeUser);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.degrees).toEqual([expected]);
      },
    );

    test.each`
      region                                       | expected
      ${UsersDataRegionEnum.Africa}                | ${'Africa'}
      ${UsersDataRegionEnum.Asia}                  | ${'Asia'}
      ${UsersDataRegionEnum.AustraliaAustraliasia} | ${'Australia/Australiasia'}
      ${UsersDataRegionEnum.Europe}                | ${'Europe'}
      ${UsersDataRegionEnum.NorthAmerica}          | ${'North America'}
      ${UsersDataRegionEnum.SouthAmerica}          | ${'South America'}
      ${UsersDataRegionEnum.LatinAmerica}          | ${'Latin America'}
    `(
      'Should correctly map regions $region => $expected',
      async ({ region, expected }) => {
        const user = getGraphQLUser();
        user.flatData.region = region;
        const mockResponse = getSquidexUserGraphqlResponse(user);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.region).toEqual(expected);
      },
    );

    test.each`
      role                                         | expected
      ${UsersDataRoleEnum.WorkingGroupParticipant} | ${'Working Group Participant'}
      ${UsersDataRoleEnum.NetworkInvestigator}     | ${'Network Investigator'}
      ${UsersDataRoleEnum.NetworkCollaborator}     | ${'Network Collaborator'}
      ${UsersDataRoleEnum.Administrator}           | ${'Administrator'}
      ${UsersDataRoleEnum.Trainee}                 | ${'Trainee'}
    `(
      'Should correctly map role $role => $expected',
      async ({ role, expected }) => {
        const user = getGraphQLUser();
        user.flatData.role = role;
        const mockResponse = getSquidexUserGraphqlResponse(user);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.role).toEqual(expected);
      },
    );
    describe('positions', () => {
      const position = {
        role: 'CEO',
        department: 'Research',
        institution: 'Stark Industries',
      };
      test.each(['role', 'department', 'institution'])(
        'Should throw when the position has %s not defined',
        async (item) => {
          const invalidRoleUser = getGraphQLUser();
          invalidRoleUser.flatData.positions = [
            {
              ...position,
              [item]: null,
            },
          ];
          const mockResponse = getSquidexUserGraphqlResponse(invalidRoleUser);
          squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

          expect(() =>
            userDataProvider.fetchById('user-id'),
          ).rejects.toThrowError('Position not defined');
        },
      );
      test('Should return empty array if positions has not been defined', async () => {
        const invalidRoleUser = getGraphQLUser();
        invalidRoleUser.flatData.positions = null;
        const mockResponse = getSquidexUserGraphqlResponse(invalidRoleUser);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.positions).toEqual([]);
      });
    });
  });

  describe('update', () => {
    afterEach(() => {
      nock.cleanAll();
    });

    const userId = 'user-id';
    test('Should throw when sync asset fails', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          firstName: { iv: 'Tony' },
        })
        .reply(404);

      await expect(
        userDataProvider.update(userId, { firstName: 'Tony' }),
      ).rejects.toThrow(NotFoundError);
      expect(nock.isDone()).toBe(true);
    });
    test('Should update first name', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          firstName: { iv: 'Tony' },
        })
        .reply(200, fetchUserResponse());

      expect(
        await userDataProvider.update(userId, { firstName: 'Tony' }),
      ).not.toBeDefined();
      expect(nock.isDone()).toBe(true);
    });
    test('Should update last name', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          lastName: { iv: 'Stark' },
        })
        .reply(200, fetchUserResponse());

      expect(
        await userDataProvider.update(userId, { lastName: 'Stark' }),
      ).not.toBeDefined();
      expect(nock.isDone()).toBe(true);
    });
    test.each`
      region                      | expected
      ${'Africa'}                 | ${UsersDataRegionEnum.Africa}
      ${'Asia'}                   | ${UsersDataRegionEnum.Asia}
      ${'Australia/Australiasia'} | ${UsersDataRegionEnum.AustraliaAustraliasia}
      ${'Europe'}                 | ${UsersDataRegionEnum.Europe}
      ${'North America'}          | ${UsersDataRegionEnum.NorthAmerica}
      ${'South America'}          | ${UsersDataRegionEnum.SouthAmerica}
      ${'Latin America'}          | ${UsersDataRegionEnum.LatinAmerica}
    `(
      'Should update the region $region => $expected',
      async ({ region, expected }) => {
        nock(baseUrl)
          .patch(`/api/content/${appName}/users/${userId}`, {
            region: { iv: expected },
          })
          .reply(200, fetchUserResponse());
        expect(
          await userDataProvider.update(userId, {
            region,
          }),
        ).not.toBeDefined();
        expect(nock.isDone()).toBe(true);
      },
    );
    test.each`
      role                           | expected
      ${'Working Group Participant'} | ${UsersDataRoleEnum.WorkingGroupParticipant}
      ${'Network Investigator'}      | ${UsersDataRoleEnum.NetworkInvestigator}
      ${'Network Collaborator'}      | ${UsersDataRoleEnum.NetworkCollaborator}
      ${'Administrator'}             | ${UsersDataRoleEnum.Administrator}
      ${'Trainee'}                   | ${UsersDataRoleEnum.Trainee}
    `(
      'Should update the role $role => $expected',
      async ({ role, expected }) => {
        nock(baseUrl)
          .patch(`/api/content/${appName}/users/${userId}`, {
            role: { iv: expected },
          })
          .reply(200, fetchUserResponse());
        expect(
          await userDataProvider.update(userId, {
            role,
          }),
        ).not.toBeDefined();
        expect(nock.isDone()).toBe(true);
      },
    );
    test.each(Object.values(UsersDataDegreeEnum))(
      'Should update the degree %s',
      async (degree) => {
        const expected =
          degree === UsersDataDegreeEnum.MdPhD ? 'MD, PhD' : degree;
        nock(baseUrl)
          .patch(`/api/content/${appName}/users/${userId}`, {
            degree: { iv: [degree] },
          })
          .reply(200, fetchUserResponse());
        expect(
          await userDataProvider.update(userId, {
            degrees: [expected],
          }),
        ).not.toBeDefined();
        expect(nock.isDone()).toBe(true);
      },
    );
  });

  describe('Fetch', () => {
    beforeEach(() => {
      jest.clearAllMocks();
    });
    test('Should fetch the users from squidex graphql', async () => {
      const result = await usersMockGraphqlServer.fetch({});

      expect(result).toMatchObject({ total: 1, items: [getUserDataObject()] });
    });
    test('Should return an empty result', async () => {
      const mockResponse = getSquidexUsersGraphqlResponse();
      mockResponse.queryUsersContentsWithTotal!.items = [];
      mockResponse.queryUsersContentsWithTotal!.total = 0;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetch({});
      expect(result).toEqual({ total: 0, items: [] });
    });
    test('Should return an empty result when the client returns a response with query property set to null', async () => {
      const mockResponse = getSquidexUsersGraphqlResponse();
      mockResponse.queryUsersContentsWithTotal = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetch({});
      expect(result).toEqual({ total: 0, items: [] });
    });
    test('Should return an empty result when the client returns a response with items property set to null', async () => {
      const mockResponse = getSquidexUsersGraphqlResponse();
      mockResponse.queryUsersContentsWithTotal!.items = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetch({});
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should query with filters and return the users', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: gp2.FetchUsersOptions = {
        take: 12,
        skip: 2,
        search: '',
        filter: {
          region: ['Europe', 'Asia'],
        },
      };
      const users = await userDataProvider.fetch(fetchOptions);

      const filterQuery =
        "data/region/iv eq 'Europe'" + " or data/region/iv eq 'Asia'";
      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 12,
          skip: 2,
          filter: filterQuery,
        },
      );
      expect(users).toMatchObject({ total: 1, items: [getUserDataObject()] });
    });
    test('Should query with code filters and return the users', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: FetchUsersOptions = {
        take: 1,
        skip: 0,
        filter: {
          onboarded: false,
          hidden: false,
          code: 'a-code',
        },
      };
      const users = await userDataProvider.fetch(fetchOptions);

      const filterQuery = "data/connections/iv/code eq 'a-code'";
      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 1,
          skip: 0,
          filter: filterQuery,
        },
      );
      expect(users).toMatchObject({ total: 1, items: [getUserDataObject()] });
    });
  });
});
