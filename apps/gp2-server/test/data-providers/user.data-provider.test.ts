import { GenericError, NotFoundError } from '@asap-hub/errors';
import { FetchUsersOptions, gp2 as gp2Model } from '@asap-hub/model';
import { gp2 as gp2Squidex, SquidexRest } from '@asap-hub/squidex';
import nock from 'nock';
import {
  ProjectsDataMembersRoleEnum,
  ProjectsDataStatusEnum,
  UsersDataDegreeEnum,
  UsersDataRegionEnum,
  UsersDataRoleEnum,
  WorkingGroupsDataMembersRoleEnum,
} from '../../src/autogenerated-gql/graphql';
import { appName, baseUrl } from '../../src/config';
import { UserSquidexDataProvider } from '../../src/data-providers/user.data-provider';
import { getAuthToken } from '../../src/utils/auth';
import {
  fetchUserResponse,
  getGraphQLProjectMembers,
  getGraphQLUser,
  getGraphQLWorkingGroupMembers,
  getSquidexProjectsMembersGraphqlResponse,
  getSquidexUserGraphqlResponse,
  getSquidexUsersGraphqlResponse,
  getSquidexWorkingGroupsMembersGraphqlResponse,
  getUserCreateDataObject,
  getUserDataObject,
  getUserInput,
} from '../fixtures/user.fixtures';
import { identity } from '../helpers/squidex';
import { getSquidexGraphqlClientMockServer } from '../mocks/squidex-graphql-client-with-server.mock';
import { getSquidexGraphqlClientMock } from '../mocks/squidex-graphql-client.mock';

describe('User data provider', () => {
  const userRestClient = new SquidexRest<
    gp2Squidex.RestUser,
    gp2Squidex.InputUser
  >(getAuthToken, 'users', {
    appName,
    baseUrl,
  });
  const squidexGraphqlClientMock = getSquidexGraphqlClientMock();
  const userDataProvider = new UserSquidexDataProvider(
    squidexGraphqlClientMock,
    userRestClient,
  );

  const squidexGraphqlClientMockServer = getSquidexGraphqlClientMockServer();
  const usersMockGraphqlServer = new UserSquidexDataProvider(
    squidexGraphqlClientMockServer,
    userRestClient,
  );

  beforeAll(identity);
  beforeEach(jest.resetAllMocks);

  describe('FetchById', () => {
    test('Should fetch the users from squidex graphql', async () => {
      const result = await usersMockGraphqlServer.fetchById('user-id');

      expect(result).toMatchObject(getUserDataObject());
    });
    test('Should return null when the user is not found', async () => {
      const mockResponse = getSquidexUserGraphqlResponse();
      mockResponse.findUsersContent = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(await userDataProvider.fetchById('not-found')).toBeNull();
    });

    test('Should return the user when it finds it', async () => {
      const mockResponse = getSquidexUserGraphqlResponse();
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetchById('user-id');
      expect(result).toEqual(getUserDataObject());
    });
    test('Should throw when the user has role undefined', async () => {
      const invalidRoleUser = getGraphQLUser();
      invalidRoleUser.flatData.role = null;
      const mockResponse = getSquidexUserGraphqlResponse(invalidRoleUser);
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(() =>
        userDataProvider.fetchById('user-id'),
      ).rejects.toThrowErrorMatchingInlineSnapshot('"Role not defined: null"');
    });

    test('Should throw when the user has region undefined', async () => {
      const invalidUser = getGraphQLUser();
      invalidUser.flatData.region = null;
      const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(() =>
        userDataProvider.fetchById('user-id'),
      ).rejects.toThrowErrorMatchingInlineSnapshot(
        '"Region not defined: null"',
      );
    });

    test.each(Object.values(UsersDataDegreeEnum))(
      'Should correctly map MD, PhD Correctly - %s',
      async (degree) => {
        const expected =
          degree === UsersDataDegreeEnum.MdPhD ? 'MD, PhD' : degree;
        const degreeUser = getGraphQLUser();
        degreeUser.flatData.degree = [degree];
        const mockResponse = getSquidexUserGraphqlResponse(degreeUser);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.degrees).toEqual([expected]);
      },
    );

    test.each`
      region                                       | expected
      ${UsersDataRegionEnum.Africa}                | ${'Africa'}
      ${UsersDataRegionEnum.Asia}                  | ${'Asia'}
      ${UsersDataRegionEnum.AustraliaAustraliasia} | ${'Australia/Australiasia'}
      ${UsersDataRegionEnum.Europe}                | ${'Europe'}
      ${UsersDataRegionEnum.NorthAmerica}          | ${'North America'}
      ${UsersDataRegionEnum.SouthAmerica}          | ${'South America'}
      ${UsersDataRegionEnum.LatinAmerica}          | ${'Latin America'}
    `(
      'Should correctly map regions $region => $expected',
      async ({ region, expected }) => {
        const user = getGraphQLUser();
        user.flatData.region = region;
        const mockResponse = getSquidexUserGraphqlResponse(user);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.region).toEqual(expected);
      },
    );

    test.each`
      role                                         | expected
      ${UsersDataRoleEnum.WorkingGroupParticipant} | ${'Working Group Participant'}
      ${UsersDataRoleEnum.NetworkInvestigator}     | ${'Network Investigator'}
      ${UsersDataRoleEnum.NetworkCollaborator}     | ${'Network Collaborator'}
      ${UsersDataRoleEnum.Administrator}           | ${'Administrator'}
      ${UsersDataRoleEnum.Trainee}                 | ${'Trainee'}
    `(
      'Should correctly map role $role => $expected',
      async ({ role, expected }) => {
        const user = getGraphQLUser();
        user.flatData.role = role;
        const mockResponse = getSquidexUserGraphqlResponse(user);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.role).toEqual(expected);
      },
    );

    test.each(gp2Model.keywords)('keywords are added - %s', async (keyword) => {
      const expectedKeywords = [keyword];
      const user = getGraphQLUser();
      user.flatData.keywords = expectedKeywords;
      const mockResponse = getSquidexUserGraphqlResponse(user);
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);
      const result = await userDataProvider.fetchById('user-id');
      expect(result?.keywords).toEqual(expectedKeywords);
    });

    test('keywords are valid', async () => {
      const expectedKeywords = ['invalid-keyword'];
      const user = getGraphQLUser();
      user.flatData.keywords = expectedKeywords;
      const mockResponse = getSquidexUserGraphqlResponse(user);
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);
      expect(() => userDataProvider.fetchById('user-id')).rejects.toThrow();
    });

    describe('positions', () => {
      const position = {
        role: 'CEO',
        department: 'Research',
        institution: 'Stark Industries',
      };
      test.each(['role', 'department', 'institution'])(
        'Should throw when the position has %s not defined',
        async (item) => {
          const invalidRoleUser = getGraphQLUser();
          invalidRoleUser.flatData.positions = [
            {
              ...position,
              [item]: null,
            },
          ];
          const mockResponse = getSquidexUserGraphqlResponse(invalidRoleUser);
          squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

          expect(() =>
            userDataProvider.fetchById('user-id'),
          ).rejects.toThrowError('Position not defined');
        },
      );
      test('Should return empty array if positions has not been defined', async () => {
        const invalidUser = getGraphQLUser();
        invalidUser.flatData.positions = null;
        const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.positions).toEqual([]);
      });
    });
    describe('projects', () => {
      const project = {
        status: ProjectsDataStatusEnum.Active,
        title: 'a title',
        members: [
          {
            role: ProjectsDataMembersRoleEnum.Contributor,
            user: [{ id: '11' }],
          },
        ],
      };
      test('Should return empty array if projects has not been defined', async () => {
        const invalidUser = getGraphQLUser();
        invalidUser.referencingProjectsContents = null;
        const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.projects).toEqual([]);
      });
      test('Should throw when the status is not defined', async () => {
        const invalidUser = getGraphQLUser();
        invalidUser.referencingProjectsContents = [
          {
            id: '7',
            flatData: {
              ...project,
              status: null,
            },
          },
        ];
        const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        expect(() =>
          userDataProvider.fetchById('user-id'),
        ).rejects.toThrowError('Status not defined');
      });
      test('Should throw when a members role is not defined', async () => {
        const invalidUser = getGraphQLUser();
        invalidUser.referencingProjectsContents = [
          {
            id: '7',
            flatData: {
              ...project,
              members: [
                ...project.members,
                { role: null, user: [{ id: '23' }] },
              ],
            },
          },
        ];
        const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        expect(() =>
          userDataProvider.fetchById('user-id'),
        ).rejects.toThrowError('Invalid project members');
      });
      test.each([null, []])(
        'Should throw when a members user is not defined',
        async (user) => {
          const invalidUser = getGraphQLUser();
          invalidUser.referencingProjectsContents = [
            {
              id: '7',
              flatData: {
                ...project,
                members: [
                  ...project.members,
                  { role: ProjectsDataMembersRoleEnum.Contributor, user },
                ],
              },
            },
          ];
          const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
          squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

          expect(() =>
            userDataProvider.fetchById('user-id'),
          ).rejects.toThrowError('Invalid project members');
        },
      );
      test.each`
        role                                          | expectedRole
        ${ProjectsDataMembersRoleEnum.ProjectManager} | ${'Project manager'}
        ${ProjectsDataMembersRoleEnum.ProjectLead}    | ${'Project lead'}
        ${ProjectsDataMembersRoleEnum.ProjectCoLead}  | ${'Project co-lead'}
        ${ProjectsDataMembersRoleEnum.Contributor}    | ${'Contributor'}
        ${ProjectsDataMembersRoleEnum.Investigator}   | ${'Investigator'}
      `(
        'should parse the role $role => $expectedRole',
        async ({ role, expectedRole }) => {
          const user = getGraphQLUser();
          user.referencingProjectsContents = [
            {
              id: '7',
              flatData: {
                ...project,
                members: [{ role, user: [{ id: '23' }] }],
              },
            },
          ];
          const mockResponse = getSquidexUserGraphqlResponse(user);
          squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);
          const result = await userDataProvider.fetchById('user-id');
          expect(result?.projects[0]?.members[0]!.role).toEqual(expectedRole);
        },
      );
      test('check multiple members', async () => {
        const user = getGraphQLUser();
        user.referencingProjectsContents = [
          {
            id: '7',
            flatData: {
              ...project,
              members: [
                {
                  role: ProjectsDataMembersRoleEnum.Contributor,
                  user: [{ id: '23' }],
                },
                {
                  role: ProjectsDataMembersRoleEnum.ProjectLead,
                  user: [{ id: '27' }],
                },
              ],
            },
          },
        ];
        const mockResponse = getSquidexUserGraphqlResponse(user);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);
        const result = await userDataProvider.fetchById('user-id');
        expect(result?.projects[0]?.members).toHaveLength(2);
        expect(result?.projects[0]?.members).toEqual([
          { role: 'Contributor', userId: '23' },
          { role: 'Project lead', userId: '27' },
        ]);
      });
      test('members undefined', async () => {
        const user = getGraphQLUser();
        user.referencingProjectsContents = [
          {
            id: '7',
            flatData: {
              ...project,
              members: null,
            },
          },
        ];
        const mockResponse = getSquidexUserGraphqlResponse(user);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.projects[0]?.members).toHaveLength(0);
      });
    });
    describe('working groups', () => {
      const workingGroup = {
        title: 'a title',
        members: [
          {
            role: WorkingGroupsDataMembersRoleEnum.CoLead,
            user: [{ id: '11' }],
          },
        ],
      };
      test('Should return empty array if working group has not been defined', async () => {
        const invalidUser = getGraphQLUser();
        invalidUser.referencingWorkingGroupsContents = null;
        const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.workingGroups).toEqual([]);
      });
      test('Should throw when a members role is not defined', async () => {
        const invalidUser = getGraphQLUser();
        invalidUser.referencingWorkingGroupsContents = [
          {
            id: '7',
            flatData: {
              ...workingGroup,
              members: [{ role: null, user: [{ id: '23' }] }],
            },
          },
        ];
        const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        expect(() =>
          userDataProvider.fetchById('user-id'),
        ).rejects.toThrowError('Invalid working group members');
      });
      test.each([null, []])(
        'Should throw when a members user is not defined',
        async (user) => {
          const invalidUser = getGraphQLUser();
          invalidUser.referencingWorkingGroupsContents = [
            {
              id: '7',
              flatData: {
                ...workingGroup,
                members: [
                  { role: WorkingGroupsDataMembersRoleEnum.CoLead, user },
                ],
              },
            },
          ];
          const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
          squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

          expect(() =>
            userDataProvider.fetchById('user-id'),
          ).rejects.toThrowError('Invalid working group members');
        },
      );
      test.each`
        role                                                   | expectedRole
        ${WorkingGroupsDataMembersRoleEnum.Lead}               | ${'Lead'}
        ${WorkingGroupsDataMembersRoleEnum.CoLead}             | ${'Co-lead'}
        ${WorkingGroupsDataMembersRoleEnum.WorkingGroupMember} | ${'Working group member'}
      `(
        'should parse the role $role => $expectedRole',
        async ({ role, expectedRole }) => {
          const user = getGraphQLUser();
          user.referencingWorkingGroupsContents = [
            {
              id: '7',
              flatData: {
                ...workingGroup,
                members: [{ role, user: [{ id: '23' }] }],
              },
            },
          ];
          const mockResponse = getSquidexUserGraphqlResponse(user);
          squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);
          const result = await userDataProvider.fetchById('user-id');
          expect(result?.workingGroups[0]?.members[0]!.role).toEqual(
            expectedRole,
          );
        },
      );
      test('check multiple members', async () => {
        const user = getGraphQLUser();
        user.referencingWorkingGroupsContents = [
          {
            id: '7',
            flatData: {
              ...workingGroup,
              members: [
                {
                  role: WorkingGroupsDataMembersRoleEnum.CoLead,
                  user: [{ id: '23' }],
                },
                {
                  role: WorkingGroupsDataMembersRoleEnum.Lead,
                  user: [{ id: '27' }],
                },
              ],
            },
          },
        ];
        const mockResponse = getSquidexUserGraphqlResponse(user);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);
        const result = await userDataProvider.fetchById('user-id');
        expect(result?.workingGroups[0]?.members).toHaveLength(2);
        expect(result?.workingGroups[0]?.members).toEqual([
          { role: 'Co-lead', userId: '23' },
          { role: 'Lead', userId: '27' },
        ]);
      });
      test('members undefined', async () => {
        const user = getGraphQLUser();
        user.referencingWorkingGroupsContents = [
          {
            id: '7',
            flatData: {
              ...workingGroup,
              members: null,
            },
          },
        ];
        const mockResponse = getSquidexUserGraphqlResponse(user);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.workingGroups[0]?.members).toHaveLength(0);
      });
    });
    describe('telephone', () => {
      test('Should return undefined telephone if both the number and country code have not been defined', async () => {
        const invalidUser = getGraphQLUser();
        invalidUser.flatData.telephoneNumber = null;
        invalidUser.flatData.telephoneCountryCode = null;
        const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.telephone).toBeUndefined();
      });
      test('Should return undefined telephone number if the number has not been defined', async () => {
        const invalidUser = getGraphQLUser();
        invalidUser.flatData.telephoneNumber = null;
        const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.telephone?.number).toBeUndefined();
        expect(result?.telephone?.countryCode).toEqual('+1');
      });
      test('Should return undefined telephone country code if the country code has not been defined', async () => {
        const invalidUser = getGraphQLUser();
        invalidUser.flatData.telephoneCountryCode = null;
        const mockResponse = getSquidexUserGraphqlResponse(invalidUser);
        squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

        const result = await userDataProvider.fetchById('user-id');
        expect(result?.telephone?.countryCode).toBeUndefined();
        expect(result?.telephone?.number).toEqual('212-970-4133');
      });
    });
  });

  describe('Update', () => {
    afterEach(() => {
      nock.cleanAll();
    });

    const userId = 'user-id';

    test('Should throw when the PATCH request to squidex fails', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          firstName: { iv: 'Tony' },
        })
        .reply(404);

      await expect(
        userDataProvider.update(userId, { firstName: 'Tony' }),
      ).rejects.toThrow(NotFoundError);
      expect(nock.isDone()).toBe(true);
    });

    test('Should update telephone fields', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          telephoneCountryCode: { iv: '+1' },
          telephoneNumber: { iv: '212-970-4133' },
        })
        .reply(200, fetchUserResponse());

      await userDataProvider.update(userId, {
        telephone: { countryCode: '+1', number: '212-970-4133' },
      });
      expect(nock.isDone()).toBe(true);
    });
    test('Should update allow empty telephone country code', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          telephoneCountryCode: { iv: '' },
          telephoneNumber: { iv: '212-970-4133' },
        })
        .reply(200, fetchUserResponse());

      await userDataProvider.update(userId, {
        telephone: { countryCode: '', number: '212-970-4133' },
      });
      expect(nock.isDone()).toBe(true);
    });
    test('Should update allow empty telephone number', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          telephoneCountryCode: { iv: '+1' },
          telephoneNumber: { iv: '' },
        })
        .reply(200, fetchUserResponse());

      await userDataProvider.update(userId, {
        telephone: { countryCode: '+1', number: '' },
      });
      expect(nock.isDone()).toBe(true);
    });
    test('Should update secondary email', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          secondaryEmail: { iv: '' },
        })
        .reply(200, fetchUserResponse());

      expect(
        await userDataProvider.update(userId, {
          secondaryEmail: '',
        }),
      ).not.toBeDefined();
      expect(nock.isDone()).toBe(true);
    });
    test('Should update secondary email', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          secondaryEmail: { iv: 'tony@example.com' },
        })
        .reply(200, fetchUserResponse());

      expect(
        await userDataProvider.update(userId, {
          secondaryEmail: 'tony@example.com',
        }),
      ).not.toBeDefined();
      expect(nock.isDone()).toBe(true);
    });

    test('Should update first name', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          firstName: { iv: 'Tony' },
        })
        .reply(200, fetchUserResponse());

      expect(
        await userDataProvider.update(userId, { firstName: 'Tony' }),
      ).not.toBeDefined();
      expect(nock.isDone()).toBe(true);
    });

    test('Should update last name', async () => {
      nock(baseUrl)
        .patch(`/api/content/${appName}/users/${userId}`, {
          lastName: { iv: 'Stark' },
        })
        .reply(200, fetchUserResponse());

      expect(
        await userDataProvider.update(userId, { lastName: 'Stark' }),
      ).not.toBeDefined();
      expect(nock.isDone()).toBe(true);
    });
    test.each`
      region                      | expected
      ${'Africa'}                 | ${UsersDataRegionEnum.Africa}
      ${'Asia'}                   | ${UsersDataRegionEnum.Asia}
      ${'Australia/Australiasia'} | ${UsersDataRegionEnum.AustraliaAustraliasia}
      ${'Europe'}                 | ${UsersDataRegionEnum.Europe}
      ${'North America'}          | ${UsersDataRegionEnum.NorthAmerica}
      ${'South America'}          | ${UsersDataRegionEnum.SouthAmerica}
      ${'Latin America'}          | ${UsersDataRegionEnum.LatinAmerica}
    `(
      'Should update the region $region => $expected',
      async ({ region, expected }) => {
        nock(baseUrl)
          .patch(`/api/content/${appName}/users/${userId}`, {
            region: { iv: expected },
          })
          .reply(200, fetchUserResponse());
        expect(
          await userDataProvider.update(userId, {
            region,
          }),
        ).not.toBeDefined();
        expect(nock.isDone()).toBe(true);
      },
    );
    test.each`
      role                           | expected
      ${'Working Group Participant'} | ${UsersDataRoleEnum.WorkingGroupParticipant}
      ${'Network Investigator'}      | ${UsersDataRoleEnum.NetworkInvestigator}
      ${'Network Collaborator'}      | ${UsersDataRoleEnum.NetworkCollaborator}
      ${'Administrator'}             | ${UsersDataRoleEnum.Administrator}
      ${'Trainee'}                   | ${UsersDataRoleEnum.Trainee}
    `(
      'Should update the role $role => $expected',
      async ({ role, expected }) => {
        nock(baseUrl)
          .patch(`/api/content/${appName}/users/${userId}`, {
            role: { iv: expected },
          })
          .reply(200, fetchUserResponse());
        expect(
          await userDataProvider.update(userId, {
            role,
          }),
        ).not.toBeDefined();
        expect(nock.isDone()).toBe(true);
      },
    );
    test.each(Object.values(UsersDataDegreeEnum))(
      'Should update the degree %s',
      async (degree) => {
        const expected =
          degree === UsersDataDegreeEnum.MdPhD ? 'MD, PhD' : degree;
        nock(baseUrl)
          .patch(`/api/content/${appName}/users/${userId}`, {
            degree: { iv: [degree] },
          })
          .reply(200, fetchUserResponse());
        expect(
          await userDataProvider.update(userId, {
            degrees: [expected],
          }),
        ).not.toBeDefined();
        expect(nock.isDone()).toBe(true);
      },
    );
  });

  describe('Create', () => {
    afterEach(() => {
      expect(nock.isDone()).toBe(true);
    });

    afterEach(() => {
      nock.cleanAll();
    });

    test('Should throw when the POST request to squidex fails', async () => {
      nock(baseUrl)
        .post(`/api/content/${appName}/users?publish=true`)
        .reply(500);

      await expect(
        userDataProvider.create(getUserCreateDataObject()),
      ).rejects.toThrow(GenericError);
    });

    test('Should create the user', async () => {
      const userResponse = fetchUserResponse();
      const userCreateDataObject = getUserCreateDataObject();

      nock(baseUrl)
        .post(`/api/content/${appName}/users?publish=true`, getUserInput())
        .reply(200, userResponse);

      const response = await userDataProvider.create(userCreateDataObject);

      expect(response).toEqual(userResponse.id);
    });

    test.each`
      region                      | expected
      ${'Africa'}                 | ${UsersDataRegionEnum.Africa}
      ${'Asia'}                   | ${UsersDataRegionEnum.Asia}
      ${'Australia/Australiasia'} | ${UsersDataRegionEnum.AustraliaAustraliasia}
      ${'Europe'}                 | ${UsersDataRegionEnum.Europe}
      ${'North America'}          | ${UsersDataRegionEnum.NorthAmerica}
      ${'South America'}          | ${UsersDataRegionEnum.SouthAmerica}
      ${'Latin America'}          | ${UsersDataRegionEnum.LatinAmerica}
    `(
      'Should create a user with the region $region => $expected',
      async ({ region, expected }) => {
        const userCreateDataObject = getUserCreateDataObject();

        nock(baseUrl)
          .post(`/api/content/${appName}/users?publish=true`, {
            ...getUserInput(),
            region: { iv: expected },
          })
          .reply(200, fetchUserResponse());

        await userDataProvider.create({
          ...userCreateDataObject,
          region,
        });
      },
    );

    test.each`
      role                           | expected
      ${'Working Group Participant'} | ${UsersDataRoleEnum.WorkingGroupParticipant}
      ${'Network Investigator'}      | ${UsersDataRoleEnum.NetworkInvestigator}
      ${'Network Collaborator'}      | ${UsersDataRoleEnum.NetworkCollaborator}
      ${'Administrator'}             | ${UsersDataRoleEnum.Administrator}
      ${'Trainee'}                   | ${UsersDataRoleEnum.Trainee}
    `(
      'Should create a user with the role $role => $expected',
      async ({ role, expected }) => {
        const userCreateDataObject = getUserCreateDataObject();

        nock(baseUrl)
          .post(`/api/content/${appName}/users?publish=true`, {
            ...getUserInput(),
            role: { iv: expected },
          })
          .reply(200, fetchUserResponse());

        await userDataProvider.create({
          ...userCreateDataObject,
          role,
        });
      },
    );

    test.each(Object.values(UsersDataDegreeEnum))(
      'Should create a user with the degree %s',
      async (degree) => {
        const userCreateDataObject = getUserCreateDataObject();
        const expected =
          degree === UsersDataDegreeEnum.MdPhD ? 'MD, PhD' : degree;

        nock(baseUrl)
          .post(`/api/content/${appName}/users?publish=true`, {
            ...getUserInput(),
            degree: { iv: [degree] },
          })
          .reply(200, fetchUserResponse());

        await userDataProvider.create({
          ...userCreateDataObject,
          degrees: [expected],
        });
      },
    );
  });

  describe('Fetch', () => {
    beforeEach(jest.resetAllMocks);
    test('Should fetch the users from squidex graphql', async () => {
      const result = await usersMockGraphqlServer.fetch({});

      expect(result).toMatchObject({ total: 1, items: [getUserDataObject()] });
    });
    test('Should return an empty result', async () => {
      const mockResponse = getSquidexUsersGraphqlResponse();
      mockResponse.queryUsersContentsWithTotal!.items = [];
      mockResponse.queryUsersContentsWithTotal!.total = 0;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetch({});
      expect(result).toEqual({ total: 0, items: [] });
    });
    test('Should return an empty result when the client returns a response with query property set to null', async () => {
      const mockResponse = getSquidexUsersGraphqlResponse();
      mockResponse.queryUsersContentsWithTotal = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetch({});
      expect(result).toEqual({ total: 0, items: [] });
    });
    test('Should return an empty result when the client returns a response with items property set to null', async () => {
      const mockResponse = getSquidexUsersGraphqlResponse();
      mockResponse.queryUsersContentsWithTotal!.items = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await userDataProvider.fetch({});
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should query with onboarded filter', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: gp2Model.FetchUsersOptions = {
        take: 12,
        skip: 2,
        filter: {
          onlyOnboarded: true,
        },
      };
      const users = await userDataProvider.fetch(fetchOptions);

      const filter = '(data/onboarded/iv eq true)';
      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 12,
          skip: 2,
          filter,
        },
      );
      expect(users).toMatchObject({ total: 1, items: [getUserDataObject()] });
    });

    test('Should return all users when the onlyOnboard flag is false', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: gp2Model.FetchUsersOptions = {
        take: 12,
        skip: 2,
        filter: {
          onlyOnboarded: false,
        },
      };
      const users = await userDataProvider.fetch(fetchOptions);

      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 12,
          skip: 2,
          filter: '',
        },
      );
      expect(users).toMatchObject({ total: 1, items: [getUserDataObject()] });
    });

    test.each`
      name          | value                 | fieldName
      ${'regions'}  | ${['Africa', 'Asia']} | ${'region'}
      ${'keywords'} | ${['Bash', 'R']}      | ${'keywords'}
    `('Should query with $name filters', async ({ name, value, fieldName }) => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: gp2Model.FetchUsersOptions = {
        take: 12,
        skip: 2,
        filter: {
          [name]: value,
        },
      };
      await userDataProvider.fetch(fetchOptions);

      const filter = `(data/${fieldName}/iv eq '${value[0]}' or data/${fieldName}/iv eq '${value[1]}')`;
      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 12,
          skip: 2,
          filter,
        },
      );
    });

    describe('projects filter', () => {
      test('it should be able to filter by project', async () => {
        const projectId = '140f5e15-922d-4cbf-9d39-35dd39225b03';
        const userId = '11';
        const projectMembers = getGraphQLProjectMembers({
          members: [{ user: [{ id: userId }] }],
        });
        const projectMembersResponse =
          getSquidexProjectsMembersGraphqlResponse();

        projectMembersResponse.queryProjectsContents![0] = projectMembers;

        squidexGraphqlClientMock.request
          .mockResolvedValueOnce(projectMembersResponse)
          .mockResolvedValueOnce(getSquidexUsersGraphqlResponse());
        const fetchOptions: gp2Model.FetchUsersOptions = {
          take: 12,
          skip: 2,
          filter: {
            projects: [projectId],
          },
        };
        await userDataProvider.fetch(fetchOptions);

        expect(squidexGraphqlClientMock.request).toBeCalledTimes(2);
        const projectFilter = `id eq '${projectId}'`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          1,
          expect.anything(),
          {
            filter: projectFilter,
          },
        );
        const userFilter = `(id eq '${userId}')`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          2,
          expect.anything(),
          {
            top: 12,
            skip: 2,
            filter: userFilter,
          },
        );
      });
      test('it should be able to filter by projects', async () => {
        const project1Id = '140f5e15-922d-4cbf-9d39-35dd39225b03';
        const project2Id = '140f5e15-922d-4cbf-9d39-35dd39225b04';
        const user1Id = '11';
        const user2Id = '7';
        const project1Members = getGraphQLProjectMembers({
          members: [{ user: [{ id: user1Id }] }],
        });
        const project2Members = getGraphQLProjectMembers({
          members: [{ user: [{ id: user2Id }] }],
        });
        const projectMembersResponse =
          getSquidexProjectsMembersGraphqlResponse();

        projectMembersResponse.queryProjectsContents![0] = project1Members;
        projectMembersResponse.queryProjectsContents![1] = project2Members;

        squidexGraphqlClientMock.request
          .mockResolvedValueOnce(projectMembersResponse)
          .mockResolvedValueOnce(getSquidexUsersGraphqlResponse());
        const fetchOptions: gp2Model.FetchUsersOptions = {
          take: 12,
          skip: 2,
          filter: {
            projects: [project1Id, project2Id],
          },
        };
        await userDataProvider.fetch(fetchOptions);

        expect(squidexGraphqlClientMock.request).toBeCalledTimes(2);
        const projectFilter = `id eq '${project1Id}' or id eq '${project2Id}'`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          1,
          expect.anything(),
          {
            filter: projectFilter,
          },
        );
        const userFilter = `(id eq '${user1Id}' or id eq '${user2Id}')`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          2,
          expect.anything(),
          {
            top: 12,
            skip: 2,
            filter: userFilter,
          },
        );
      });
      test('it should be able to filter by projects and users', async () => {
        const project1Id = '140f5e15-922d-4cbf-9d39-35dd39225b03';
        const project2Id = '140f5e15-922d-4cbf-9d39-35dd39225b04';
        const user1Id = '11';
        const user2Id = '7';
        const user3Id = '23';
        const project1Members = getGraphQLProjectMembers({
          members: [{ user: [{ id: user1Id }] }],
        });
        const project2Members = getGraphQLProjectMembers({
          members: [{ user: [{ id: user2Id }] }, { user: [{ id: user3Id }] }],
        });
        const projectMembersResponse =
          getSquidexProjectsMembersGraphqlResponse();

        projectMembersResponse.queryProjectsContents![0] = project1Members;
        projectMembersResponse.queryProjectsContents![1] = project2Members;

        squidexGraphqlClientMock.request
          .mockResolvedValueOnce(projectMembersResponse)
          .mockResolvedValueOnce(getSquidexUsersGraphqlResponse());
        const fetchOptions: gp2Model.FetchUsersOptions = {
          take: 12,
          skip: 2,
          filter: {
            projects: [project1Id, project2Id],
          },
        };
        await userDataProvider.fetch(fetchOptions);

        expect(squidexGraphqlClientMock.request).toBeCalledTimes(2);
        const projectFilter = `id eq '${project1Id}' or id eq '${project2Id}'`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          1,
          expect.anything(),
          {
            filter: projectFilter,
          },
        );
        const userFilter = `(id eq '${user1Id}' or id eq '${user2Id}' or id eq '${user3Id}')`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          2,
          expect.anything(),
          {
            top: 12,
            skip: 2,
            filter: userFilter,
          },
        );
      });
      test('it should be able to filter out duplicate user Ids', async () => {
        const project1Id = '140f5e15-922d-4cbf-9d39-35dd39225b03';
        const project2Id = '140f5e15-922d-4cbf-9d39-35dd39225b04';
        const user1Id = '11';
        const user2Id = '11';
        const project1Members = getGraphQLProjectMembers({
          members: [{ user: [{ id: user1Id }] }],
        });
        const project2Members = getGraphQLProjectMembers({
          members: [{ user: [{ id: user2Id }] }],
        });
        const projectMembersResponse =
          getSquidexProjectsMembersGraphqlResponse();

        projectMembersResponse.queryProjectsContents![0] = project1Members;
        projectMembersResponse.queryProjectsContents![1] = project2Members;

        squidexGraphqlClientMock.request
          .mockResolvedValueOnce(projectMembersResponse)
          .mockResolvedValueOnce(getSquidexUsersGraphqlResponse());
        const fetchOptions: gp2Model.FetchUsersOptions = {
          take: 12,
          skip: 2,
          filter: {
            projects: [project1Id, project2Id],
          },
        };
        await userDataProvider.fetch(fetchOptions);

        expect(squidexGraphqlClientMock.request).toBeCalledTimes(2);
        const projectFilter = `id eq '${project1Id}' or id eq '${project2Id}'`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          1,
          expect.anything(),
          {
            filter: projectFilter,
          },
        );
        const userFilter = `(id eq '${user1Id}')`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          2,
          expect.anything(),
          {
            top: 12,
            skip: 2,
            filter: userFilter,
          },
        );
      });
    });

    describe('working groups filter', () => {
      test('it should be able to filter by working group', async () => {
        const workingGroupId = '3ec68d44-82c1-4855-b6a0-ba44b9e313ba';
        const userId = '11';
        const workingGroupMembers = getGraphQLWorkingGroupMembers({
          members: [{ user: [{ id: userId }] }],
        });
        const workingGroupMembersResponse =
          getSquidexWorkingGroupsMembersGraphqlResponse();

        workingGroupMembersResponse.queryWorkingGroupsContents![0] =
          workingGroupMembers;

        squidexGraphqlClientMock.request
          .mockResolvedValueOnce(workingGroupMembersResponse)
          .mockResolvedValueOnce(getSquidexUsersGraphqlResponse());
        const fetchOptions: gp2Model.FetchUsersOptions = {
          take: 12,
          skip: 2,
          filter: {
            workingGroups: [workingGroupId],
          },
        };
        await userDataProvider.fetch(fetchOptions);

        expect(squidexGraphqlClientMock.request).toBeCalledTimes(2);
        const workingGroupFilter = `id eq '${workingGroupId}'`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          1,
          expect.anything(),
          {
            filter: workingGroupFilter,
          },
        );
        const userFilter = `(id eq '${userId}')`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          2,
          expect.anything(),
          {
            top: 12,
            skip: 2,
            filter: userFilter,
          },
        );
      });
      test('it should be able to filter by workingGroups', async () => {
        const workingGroup1Id = '3ec68d44-82c1-4855-b6a0-ba44b9e313ba';
        const workingGroup2Id = '3ec68d44-82c1-4855-b6a0-ba44b9e313bb';
        const user1Id = '11';
        const user2Id = '7';
        const workingGroup1Members = getGraphQLWorkingGroupMembers({
          members: [{ user: [{ id: user1Id }] }],
        });
        const workingGroup2Members = getGraphQLWorkingGroupMembers({
          members: [{ user: [{ id: user2Id }] }],
        });
        const workingGroupMembersResponse =
          getSquidexWorkingGroupsMembersGraphqlResponse();

        workingGroupMembersResponse.queryWorkingGroupsContents![0] =
          workingGroup1Members;
        workingGroupMembersResponse.queryWorkingGroupsContents![1] =
          workingGroup2Members;

        squidexGraphqlClientMock.request
          .mockResolvedValueOnce(workingGroupMembersResponse)
          .mockResolvedValueOnce(getSquidexUsersGraphqlResponse());
        const fetchOptions: gp2Model.FetchUsersOptions = {
          take: 12,
          skip: 2,
          filter: {
            workingGroups: [workingGroup1Id, workingGroup2Id],
          },
        };
        await userDataProvider.fetch(fetchOptions);

        expect(squidexGraphqlClientMock.request).toBeCalledTimes(2);
        const workingGroupFilter = `id eq '${workingGroup1Id}' or id eq '${workingGroup2Id}'`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          1,
          expect.anything(),
          {
            filter: workingGroupFilter,
          },
        );
        const userFilter = `(id eq '${user1Id}' or id eq '${user2Id}')`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          2,
          expect.anything(),
          {
            top: 12,
            skip: 2,
            filter: userFilter,
          },
        );
      });
      test('it should be able to filter by workingGroups and users', async () => {
        const workingGroup1Id = '3ec68d44-82c1-4855-b6a0-ba44b9e313ba';
        const workingGroup2Id = '3ec68d44-82c1-4855-b6a0-ba44b9e313bb';
        const user1Id = '11';
        const user2Id = '7';
        const user3Id = '23';
        const workingGroup1Members = getGraphQLWorkingGroupMembers({
          members: [{ user: [{ id: user1Id }] }],
        });
        const workingGroup2Members = getGraphQLWorkingGroupMembers({
          members: [{ user: [{ id: user2Id }] }, { user: [{ id: user3Id }] }],
        });
        const workingGroupMembersResponse =
          getSquidexWorkingGroupsMembersGraphqlResponse();

        workingGroupMembersResponse.queryWorkingGroupsContents![0] =
          workingGroup1Members;
        workingGroupMembersResponse.queryWorkingGroupsContents![1] =
          workingGroup2Members;

        squidexGraphqlClientMock.request
          .mockResolvedValueOnce(workingGroupMembersResponse)
          .mockResolvedValueOnce(getSquidexUsersGraphqlResponse());
        const fetchOptions: gp2Model.FetchUsersOptions = {
          take: 12,
          skip: 2,
          filter: {
            workingGroups: [workingGroup1Id, workingGroup2Id],
          },
        };
        await userDataProvider.fetch(fetchOptions);

        expect(squidexGraphqlClientMock.request).toBeCalledTimes(2);
        const workingGroupFilter = `id eq '${workingGroup1Id}' or id eq '${workingGroup2Id}'`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          1,
          expect.anything(),
          {
            filter: workingGroupFilter,
          },
        );
        const userFilter = `(id eq '${user1Id}' or id eq '${user2Id}' or id eq '${user3Id}')`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          2,
          expect.anything(),
          {
            top: 12,
            skip: 2,
            filter: userFilter,
          },
        );
      });
      test('it should be able to filter out duplicate user Ids', async () => {
        const workingGroup1Id = '3ec68d44-82c1-4855-b6a0-ba44b9e313ba';
        const workingGroup2Id = '3ec68d44-82c1-4855-b6a0-ba44b9e313bb';
        const user1Id = '11';
        const user2Id = '11';
        const workingGroup1Members = getGraphQLWorkingGroupMembers({
          members: [{ user: [{ id: user1Id }] }],
        });
        const workingGroup2Members = getGraphQLWorkingGroupMembers({
          members: [{ user: [{ id: user2Id }] }],
        });
        const workingGroupMembersResponse =
          getSquidexWorkingGroupsMembersGraphqlResponse();

        workingGroupMembersResponse.queryWorkingGroupsContents![0] =
          workingGroup1Members;
        workingGroupMembersResponse.queryWorkingGroupsContents![1] =
          workingGroup2Members;

        squidexGraphqlClientMock.request
          .mockResolvedValueOnce(workingGroupMembersResponse)
          .mockResolvedValueOnce(getSquidexUsersGraphqlResponse());
        const fetchOptions: gp2Model.FetchUsersOptions = {
          take: 12,
          skip: 2,
          filter: {
            workingGroups: [workingGroup1Id, workingGroup2Id],
          },
        };
        await userDataProvider.fetch(fetchOptions);

        expect(squidexGraphqlClientMock.request).toBeCalledTimes(2);
        const workingGroupFilter = `id eq '${workingGroup1Id}' or id eq '${workingGroup2Id}'`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          1,
          expect.anything(),
          {
            filter: workingGroupFilter,
          },
        );
        const userFilter = `(id eq '${user1Id}')`;
        expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
          2,
          expect.anything(),
          {
            top: 12,
            skip: 2,
            filter: userFilter,
          },
        );
      });
    });
    test('it should be able to filter out duplicate user Ids when both the project and working group filters are defined', async () => {
      const projectId = '140f5e15-922d-4cbf-9d39-35dd39225b03';
      const workingGroupId = '3ec68d44-82c1-4855-b6a0-ba44b9e313bb';
      const user1Id = '11';
      const user2Id = '11';
      const projectMembers = getGraphQLProjectMembers({
        members: [{ user: [{ id: user1Id }] }],
      });
      const workingGroupMembers = getGraphQLWorkingGroupMembers({
        members: [{ user: [{ id: user2Id }] }],
      });
      const projectMembersResponse = getSquidexProjectsMembersGraphqlResponse();
      const workingGroupMembersResponse =
        getSquidexWorkingGroupsMembersGraphqlResponse();

      projectMembersResponse.queryProjectsContents![0] = projectMembers;
      workingGroupMembersResponse.queryWorkingGroupsContents![0] =
        workingGroupMembers;

      squidexGraphqlClientMock.request
        .mockResolvedValueOnce(projectMembersResponse)
        .mockResolvedValueOnce(workingGroupMembersResponse)
        .mockResolvedValueOnce(getSquidexUsersGraphqlResponse());
      const fetchOptions: gp2Model.FetchUsersOptions = {
        take: 12,
        skip: 2,
        filter: {
          projects: [projectId],
          workingGroups: [workingGroupId],
        },
      };
      await userDataProvider.fetch(fetchOptions);

      expect(squidexGraphqlClientMock.request).toBeCalledTimes(3);
      const projectFilter = `id eq '${projectId}'`;
      expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
        1,
        expect.anything(),
        {
          filter: projectFilter,
        },
      );
      const workingGroupFilter = `id eq '${workingGroupId}'`;
      expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
        2,
        expect.anything(),
        {
          filter: workingGroupFilter,
        },
      );
      const userFilter = `(id eq '${user1Id}')`;
      expect(squidexGraphqlClientMock.request).toHaveBeenNthCalledWith(
        3,
        expect.anything(),
        {
          top: 12,
          skip: 2,
          filter: userFilter,
        },
      );
    });

    test('Should query with code filters', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getSquidexUsersGraphqlResponse(),
      );
      const fetchOptions: FetchUsersOptions = {
        take: 1,
        skip: 0,
        filter: {
          onboarded: false,
          hidden: false,
          code: 'a-code',
        },
      };
      await userDataProvider.fetch(fetchOptions);

      const filter = "(data/connections/iv/code eq 'a-code')";
      expect(squidexGraphqlClientMock.request).toBeCalledWith(
        expect.anything(),
        {
          top: 1,
          skip: 0,
          filter,
        },
      );
    });
  });
});
