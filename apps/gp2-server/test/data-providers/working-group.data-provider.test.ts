import {
  WorkingGroupsDataMembersRoleEnum,
  WorkingGroupsDataResourcesTypeEnum,
} from '../../src/autogenerated-gql/graphql';
import { appName, baseUrl } from '../../src/config';
import {
  parseWorkingGroupToDataObject,
  WorkingGroupSquidexDataProvider,
} from '../../src/data-providers/working-group.data-provider';
import {
  getGraphQLWorkingGroup,
  getGraphQLWorkingGroupMember,
  getGraphQLWorkingGroupResource,
  getListWorkingGroupDataObject,
  getSquidexWorkingGroupGraphqlResponse,
  getSquidexWorkingGroupsGraphqlResponse,
  getWorkingGroupDataObject,
} from '../fixtures/working-group.fixtures';
import { getSquidexGraphqlClientMockServer } from '../mocks/squidex-graphql-client-with-server.mock';
import { getSquidexGraphqlClientMock } from '../mocks/squidex-graphql-client.mock';

describe('Working Group Data Provider', () => {
  const squidexGraphqlClientMock = getSquidexGraphqlClientMock();
  const workingGroupDataProvider = new WorkingGroupSquidexDataProvider(
    squidexGraphqlClientMock,
  );

  const squidexGraphqlClientMockServer = getSquidexGraphqlClientMockServer();
  const workingGroupDataProviderMockGraphqlServer =
    new WorkingGroupSquidexDataProvider(squidexGraphqlClientMockServer);

  beforeEach(() => {
    jest.resetAllMocks();
  });

  describe('Fetch', () => {
    test('Should fetch the working group from squidex graphql', async () => {
      const result = await workingGroupDataProviderMockGraphqlServer.fetch();

      expect(result).toMatchObject(getListWorkingGroupDataObject());
    });

    test('Should return an empty result', async () => {
      const mockResponse = getSquidexWorkingGroupsGraphqlResponse();
      mockResponse.queryWorkingGroupsContentsWithTotal!.items = [];
      mockResponse.queryWorkingGroupsContentsWithTotal!.total = 0;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await workingGroupDataProvider.fetch();
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result if the client returns a response with a null items property', async () => {
      const mockResponse = getSquidexWorkingGroupsGraphqlResponse();
      mockResponse.queryWorkingGroupsContentsWithTotal = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await workingGroupDataProvider.fetch();
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result if the client returns a response with a null query property', async () => {
      const mockResponse = getSquidexWorkingGroupsGraphqlResponse();
      mockResponse.queryWorkingGroupsContentsWithTotal!.items = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await workingGroupDataProvider.fetch();
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should default null title, shortDescription and leadingMembers to an empty string', async () => {
      const mockResponse = getSquidexWorkingGroupsGraphqlResponse();
      const workingGroup = getGraphQLWorkingGroup();
      workingGroup.flatData.title = null;
      workingGroup.flatData.shortDescription = null;
      workingGroup.flatData.leadingMembers = null;
      mockResponse.queryWorkingGroupsContentsWithTotal!.items = [workingGroup];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const { items } = await workingGroupDataProvider.fetch();
      expect(items[0]).toMatchObject({
        title: '',
        shortDescription: '',
        leadingMembers: '',
      });
    });
  });
  describe('FetchById', () => {
    test('Should fetch the working group from squidex graphql', async () => {
      const result = await workingGroupDataProviderMockGraphqlServer.fetchById(
        'working-group-id',
      );

      expect(result).toMatchObject(getWorkingGroupDataObject());
    });
    test('Should return null when the working group is not found', async () => {
      const mockResponse = getSquidexWorkingGroupGraphqlResponse();
      mockResponse.findWorkingGroupsContent = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(await workingGroupDataProvider.fetchById('not-found')).toBeNull();
    });
  });

  describe('Parsing', () => {
    test('the working group is parsed', () => {
      const workingGroup = getGraphQLWorkingGroup();
      const workingGroupDataObject =
        parseWorkingGroupToDataObject(workingGroup);
      const expected = getWorkingGroupDataObject();
      expect(workingGroupDataObject).toEqual(expected);
    });

    describe('members', () => {
      test('the members in working group are parsed', () => {
        const workingGroup = getGraphQLWorkingGroup();
        workingGroup.flatData.members = [getGraphQLWorkingGroupMember()];
        const { members } = parseWorkingGroupToDataObject(workingGroup);
        expect(members).toEqual([
          {
            userId: '11',
            role: 'Lead',
            firstName: 'Tony',
            lastName: 'Stark',
          },
        ]);
      });

      test('undefined members returns empty array', () => {
        const workingGroup = getGraphQLWorkingGroup();

        workingGroup.flatData.members = null;
        const { members } = parseWorkingGroupToDataObject(workingGroup);
        expect(members).toEqual([]);
      });

      test('avatar urls are added if available', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const member = getGraphQLWorkingGroupMember();
        member!.user![0]!.flatData.avatar = [{ id: 'avatar-id' }];
        workingGroup.flatData.members = [member];
        const { members } = parseWorkingGroupToDataObject(workingGroup);
        expect(members[0]?.avatarUrl).toEqual(
          `${baseUrl}/api/assets/${appName}/avatar-id`,
        );
      });

      test('should skip the user from the result if the role property is undefined', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const member = getGraphQLWorkingGroupMember();
        member!.role = null;
        workingGroup.flatData.members = [member];
        const { members } = parseWorkingGroupToDataObject(workingGroup);
        expect(members).toEqual([]);
      });
      test.each`
        role                                                   | expectedRole
        ${WorkingGroupsDataMembersRoleEnum.Lead}               | ${'Lead'}
        ${WorkingGroupsDataMembersRoleEnum.CoLead}             | ${'Co-lead'}
        ${WorkingGroupsDataMembersRoleEnum.WorkingGroupMember} | ${'Working group member'}
      `('should parse the role', ({ role, expectedRole }) => {
        const workingGroup = getGraphQLWorkingGroup();
        const member = getGraphQLWorkingGroupMember();
        member!.role = role;
        workingGroup.flatData.members = [member];
        const { members } = parseWorkingGroupToDataObject(workingGroup);
        expect(members[0]?.role).toEqual(expectedRole);
      });

      test('should skip the user from the result if the user property is undefined', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const member = getGraphQLWorkingGroupMember();
        member!.user = null;
        workingGroup.flatData.members = [member];
        const { members } = parseWorkingGroupToDataObject(workingGroup);
        expect(members).toEqual([]);
      });
    });

    describe('resources', () => {
      test('should map a resource note', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const title = 'working group title';
        const description = 'working group description';
        const resource = getGraphQLWorkingGroupResource();
        resource.type = WorkingGroupsDataResourcesTypeEnum.Note;
        resource.title = title;
        resource.description = description;
        workingGroup.flatData.resources = [resource];
        const { resources } = parseWorkingGroupToDataObject(workingGroup);
        expect(resources).toEqual([
          {
            type: 'Note',
            title,
            description,
          },
        ]);
      });
      test('should ignore an external link for a resource note', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const title = 'working group title';
        const description = 'working group description';
        const resource = getGraphQLWorkingGroupResource();
        resource.type = WorkingGroupsDataResourcesTypeEnum.Note;
        resource.title = title;
        resource.description = description;
        resource.externalLink = 'some external link';
        workingGroup.flatData.resources = [resource];
        const { resources } = parseWorkingGroupToDataObject(workingGroup);
        expect(resources).toEqual([
          {
            type: 'Note',
            title,
            description,
          },
        ]);
      });
      test('should map a resource link', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const title = 'working group title';
        const description = 'working group description';
        const externalLink = 'this is an external link';
        const resource = getGraphQLWorkingGroupResource();
        resource.type = WorkingGroupsDataResourcesTypeEnum.Link;
        resource.title = title;
        resource.description = description;
        resource.externalLink = externalLink;
        workingGroup.flatData.resources = [resource];
        const { resources } = parseWorkingGroupToDataObject(workingGroup);
        expect(resources).toEqual([
          {
            type: 'Link',
            title,
            description,
            externalLink,
          },
        ]);
      });
      test('should ignore a resource if title is undefined.', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const title = null;
        const description = 'working group description';
        const externalLink = 'this is an external link';
        const resource = getGraphQLWorkingGroupResource();
        resource.type = WorkingGroupsDataResourcesTypeEnum.Link;
        resource.title = title;
        resource.description = description;
        resource.externalLink = externalLink;
        workingGroup.flatData.resources = [resource];
        const { resources } = parseWorkingGroupToDataObject(workingGroup);
        expect(resources).toEqual([]);
      });
      test('should return a resource if description is undefined.', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const title = 'working group title';
        const description = null;
        const externalLink = 'this is an external link';
        const resource = getGraphQLWorkingGroupResource();
        resource.type = WorkingGroupsDataResourcesTypeEnum.Link;
        resource.title = title;
        resource.description = description;
        resource.externalLink = externalLink;
        workingGroup.flatData.resources = [resource];
        const { resources } = parseWorkingGroupToDataObject(workingGroup);
        expect(resources).toEqual([
          {
            type: 'Link',
            title,
            externalLink,
          },
        ]);
      });
      test('should ignore a resource if external Link is undefined for a Link.', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const title = 'working group title';
        const description = 'working group description';
        const externalLink = null;
        const resource = getGraphQLWorkingGroupResource();
        resource.type = WorkingGroupsDataResourcesTypeEnum.Link;
        resource.title = title;
        resource.description = description;
        resource.externalLink = externalLink;
        workingGroup.flatData.resources = [resource];
        const { resources } = parseWorkingGroupToDataObject(workingGroup);
        expect(resources).toEqual([]);
      });
      test('undefined resources returns empty array', () => {
        const workingGroup = getGraphQLWorkingGroup();

        workingGroup.flatData.resources = null;
        const { resources } = parseWorkingGroupToDataObject(workingGroup);
        expect(resources).toEqual([]);
      });
    });
  });
});
