import { GenericError, NotFoundError } from '@asap-hub/errors';
import { gp2 as gp2Squidex, SquidexRest } from '@asap-hub/squidex';
import nock, { DataMatcherMap } from 'nock';
import {
  WorkingGroupsDataMembersRoleEnum,
  WorkingGroupsDataResourcesTypeEnum,
} from '../../src/autogenerated-gql/graphql';
import { appName, baseUrl } from '../../src/config';
import {
  parseWorkingGroupToDataObject,
  WorkingGroupSquidexDataProvider,
} from '../../src/data-providers/working-group.data-provider';
import { getAuthToken } from '../../src/utils/auth';
import {
  getGraphQLWorkingGroup,
  getGraphQLWorkingGroupMember,
  getGraphQLWorkingGroupResource,
  getListWorkingGroupDataObject,
  getRestWorkingGroupUpdateData,
  getSquidexWorkingGroupGraphqlResponse,
  getSquidexWorkingGroupsGraphqlResponse,
  getWorkingGroupDataObject,
  getWorkingGroupUpdateDataObject,
} from '../fixtures/working-group.fixtures';
import { identity } from '../helpers/squidex';
import { getSquidexGraphqlClientMockServer } from '../mocks/squidex-graphql-client-with-server.mock';
import { getSquidexGraphqlClientMock } from '../mocks/squidex-graphql-client.mock';

describe('Working Group Data Provider', () => {
  const workingGroupRestClient = new SquidexRest<
    gp2Squidex.RestWorkingGroup,
    gp2Squidex.InputWorkingGroup
  >(getAuthToken, 'working-groups', {
    appName,
    baseUrl,
  });
  const squidexGraphqlClientMock = getSquidexGraphqlClientMock();
  const workingGroupDataProvider = new WorkingGroupSquidexDataProvider(
    squidexGraphqlClientMock,
    workingGroupRestClient,
  );

  const squidexGraphqlClientMockServer = getSquidexGraphqlClientMockServer();
  const workingGroupDataProviderMockGraphqlServer =
    new WorkingGroupSquidexDataProvider(
      squidexGraphqlClientMockServer,
      workingGroupRestClient,
    );

  beforeAll(identity);
  beforeEach(jest.resetAllMocks);

  describe('Fetch', () => {
    test('Should fetch the working group from squidex graphql', async () => {
      const result = await workingGroupDataProviderMockGraphqlServer.fetch();

      expect(result).toMatchObject(getListWorkingGroupDataObject());
    });

    test('Should return an empty result', async () => {
      const mockResponse = getSquidexWorkingGroupsGraphqlResponse();
      mockResponse.queryWorkingGroupsContentsWithTotal!.items = [];
      mockResponse.queryWorkingGroupsContentsWithTotal!.total = 0;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await workingGroupDataProvider.fetch();
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result if the client returns a response with a null items property', async () => {
      const mockResponse = getSquidexWorkingGroupsGraphqlResponse();
      mockResponse.queryWorkingGroupsContentsWithTotal = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await workingGroupDataProvider.fetch();
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result if the client returns a response with a null query property', async () => {
      const mockResponse = getSquidexWorkingGroupsGraphqlResponse();
      mockResponse.queryWorkingGroupsContentsWithTotal!.items = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await workingGroupDataProvider.fetch();
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should default null title, shortDescription and leadingMembers to an empty string', async () => {
      const mockResponse = getSquidexWorkingGroupsGraphqlResponse();
      const workingGroup = getGraphQLWorkingGroup();
      workingGroup.flatData.title = null;
      workingGroup.flatData.shortDescription = null;
      workingGroup.flatData.leadingMembers = null;
      mockResponse.queryWorkingGroupsContentsWithTotal!.items = [workingGroup];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const { items } = await workingGroupDataProvider.fetch();
      expect(items[0]).toMatchObject({
        title: '',
        shortDescription: '',
        leadingMembers: '',
      });
    });
  });
  describe('FetchById', () => {
    test('Should fetch the working group from squidex graphql', async () => {
      const result = await workingGroupDataProviderMockGraphqlServer.fetchById(
        'working-group-id',
      );

      expect(result).toMatchObject(getWorkingGroupDataObject());
    });
    test('Should return null when the working group is not found', async () => {
      const mockResponse = getSquidexWorkingGroupGraphqlResponse();
      mockResponse.findWorkingGroupsContent = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(await workingGroupDataProvider.fetchById('not-found')).toBeNull();
    });
  });

  describe('Update', () => {
    afterEach(nock.cleanAll);
    const workingGroupId = '11';

    test('Should update the existing working group', async () => {
      const workingGroupUpdateData = getWorkingGroupUpdateDataObject();

      const restWorkingGroupUpdateData = getRestWorkingGroupUpdateData();
      nock(baseUrl)
        .patch(
          `/api/content/${appName}/working-groups/${workingGroupId}`,
          restWorkingGroupUpdateData as DataMatcherMap,
        )
        .reply(201, { id: workingGroupId });

      await workingGroupDataProvider.update(
        workingGroupId,
        workingGroupUpdateData,
      );
      expect(nock.isDone()).toBe(true);
    });

    test.each([400, 500])(
      'Should throw when fails to update the working group - %s',
      async (status) => {
        const workingGroupUpdateData = getWorkingGroupUpdateDataObject();

        nock(baseUrl)
          .patch(`/api/content/${appName}/working-groups/${workingGroupId}`)
          .reply(status);

        await expect(
          workingGroupDataProvider.update(
            workingGroupId,
            workingGroupUpdateData,
          ),
        ).rejects.toThrow(GenericError);
      },
    );

    test('Should throw when the working group cannot be found', async () => {
      const workingGroupUpdateData = getWorkingGroupUpdateDataObject();

      nock(baseUrl)
        .patch(`/api/content/${appName}/working-groups/${workingGroupId}`)
        .reply(404);

      await expect(
        workingGroupDataProvider.update(workingGroupId, workingGroupUpdateData),
      ).rejects.toThrow(NotFoundError);
    });
  });

  describe('Parsing', () => {
    test('the working group is parsed', () => {
      const workingGroup = getGraphQLWorkingGroup();
      const workingGroupDataObject =
        parseWorkingGroupToDataObject(workingGroup);
      const expected = getWorkingGroupDataObject();
      expect(workingGroupDataObject).toEqual(expected);
    });

    describe('members', () => {
      test('the members in working group are parsed', () => {
        const workingGroup = getGraphQLWorkingGroup();
        workingGroup.flatData.members = [getGraphQLWorkingGroupMember()];
        const { members } = parseWorkingGroupToDataObject(workingGroup);
        expect(members).toEqual([
          {
            userId: '11',
            role: 'Lead',
            firstName: 'Tony',
            lastName: 'Stark',
          },
        ]);
      });

      test('undefined members returns empty array', () => {
        const workingGroup = getGraphQLWorkingGroup();

        workingGroup.flatData.members = null;
        const { members } = parseWorkingGroupToDataObject(workingGroup);
        expect(members).toEqual([]);
      });

      test('avatar urls are added if available', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const member = getGraphQLWorkingGroupMember();
        member!.user![0]!.flatData.avatar = [{ id: 'avatar-id' }];
        workingGroup.flatData.members = [member];
        const { members } = parseWorkingGroupToDataObject(workingGroup);
        expect(members[0]?.avatarUrl).toEqual(
          `${baseUrl}/api/assets/${appName}/avatar-id`,
        );
      });

      test('should skip the user from the result if the role property is undefined', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const member = getGraphQLWorkingGroupMember();
        member!.role = null;
        workingGroup.flatData.members = [member];
        const { members } = parseWorkingGroupToDataObject(workingGroup);
        expect(members).toEqual([]);
      });

      test('should skip the user from the result if the user is not onboarded', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const member = getGraphQLWorkingGroupMember();
        member!.user![0]!.flatData.onboarded = false;
        workingGroup.flatData.members = [member];
        const { members } = parseWorkingGroupToDataObject(workingGroup);
        expect(members).toEqual([]);
      });

      test.each`
        role                                                   | expectedRole
        ${WorkingGroupsDataMembersRoleEnum.Lead}               | ${'Lead'}
        ${WorkingGroupsDataMembersRoleEnum.CoLead}             | ${'Co-lead'}
        ${WorkingGroupsDataMembersRoleEnum.WorkingGroupMember} | ${'Working group member'}
      `('should parse the role', ({ role, expectedRole }) => {
        const workingGroup = getGraphQLWorkingGroup();
        const member = getGraphQLWorkingGroupMember();
        member!.role = role;
        workingGroup.flatData.members = [member];
        const { members } = parseWorkingGroupToDataObject(workingGroup);
        expect(members[0]?.role).toEqual(expectedRole);
      });

      test('should skip the user from the result if the user property is undefined', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const member = getGraphQLWorkingGroupMember();
        member!.user = null;
        workingGroup.flatData.members = [member];
        const { members } = parseWorkingGroupToDataObject(workingGroup);
        expect(members).toEqual([]);
      });
    });

    describe('resources', () => {
      test('should map a resource note', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const { resources } = parseWorkingGroupToDataObject(workingGroup);
        const { resources: expectedResources } = getWorkingGroupDataObject();
        expect(resources).toStrictEqual(expectedResources);
      });
      test('should ignore an external link for a resource note', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const resource = getGraphQLWorkingGroupResource();
        resource.type = WorkingGroupsDataResourcesTypeEnum.Note;
        resource.externalLink = 'some external link';
        workingGroup.flatData.resources = [resource];
        const { resources } = parseWorkingGroupToDataObject(workingGroup);
        const { resources: expectedResources } = getWorkingGroupDataObject();
        expect(resources).toStrictEqual(expectedResources);
      });
      test('should map a resource link', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const externalLink = 'this is an external link';
        const resource = getGraphQLWorkingGroupResource();
        resource.type = WorkingGroupsDataResourcesTypeEnum.Link;
        resource.externalLink = externalLink;
        workingGroup.flatData.resources = [resource];
        const { resources } = parseWorkingGroupToDataObject(workingGroup);
        const { resources: expectedResources } = getWorkingGroupDataObject();
        expect(resources).toEqual([
          {
            ...expectedResources![0],
            type: 'Link',
            externalLink,
          },
        ]);
      });
      test('should ignore a resource if title is undefined.', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const resource = getGraphQLWorkingGroupResource();
        resource.title = null;
        workingGroup.flatData.resources = [resource];
        const { resources } = parseWorkingGroupToDataObject(workingGroup);
        expect(resources).toEqual([]);
      });
      test('should return a resource if description is undefined.', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const resource = getGraphQLWorkingGroupResource();
        resource.description = null;
        workingGroup.flatData.resources = [resource];
        const { resources } = parseWorkingGroupToDataObject(workingGroup);
        const description = resources![0]?.description;
        expect(description).toBeUndefined();
      });
      test('should ignore a resource if external Link is undefined for a Link.', () => {
        const workingGroup = getGraphQLWorkingGroup();
        const externalLink = null;
        const resource = getGraphQLWorkingGroupResource();
        resource.type = WorkingGroupsDataResourcesTypeEnum.Link;
        resource.externalLink = externalLink;
        workingGroup.flatData.resources = [resource];
        const { resources } = parseWorkingGroupToDataObject(workingGroup);
        expect(resources).toEqual([]);
      });
      test('undefined resources returns empty array', () => {
        const workingGroup = getGraphQLWorkingGroup();
        workingGroup.flatData.resources = null;
        const { resources } = parseWorkingGroupToDataObject(workingGroup);
        expect(resources).toEqual([]);
      });
    });
  });
});
