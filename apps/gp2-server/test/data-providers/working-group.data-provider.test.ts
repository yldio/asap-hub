import { WorkingGroupsDataMembersRoleEnum } from '../../src/autogenerated-gql/graphql';
import { appName, baseUrl } from '../../src/config';
import {
  parseWorkingGroupToDataObject,
  WorkingGroupSquidexDataProvider,
} from '../../src/data-providers/working-group.data-provider';
import {
  getGraphQLWorkingGroup,
  getGraphQLWorkingGroupMember,
  getListWorkingGroupDataObject,
  getSquidexWorkingGroupGraphqlResponse,
  getSquidexWorkingGroupsGraphqlResponse,
  getWorkingGroupDataObject,
} from '../fixtures/working-group.fixtures';
import { getSquidexGraphqlClientMockServer } from '../mocks/squidex-graphql-client-with-server.mock';
import { getSquidexGraphqlClientMock } from '../mocks/squidex-graphql-client.mock';

describe('Working Group Data Provider', () => {
  const squidexGraphqlClientMock = getSquidexGraphqlClientMock();
  const workingGroupDataProvider = new WorkingGroupSquidexDataProvider(
    squidexGraphqlClientMock,
  );

  const squidexGraphqlClientMockServer = getSquidexGraphqlClientMockServer();
  const workingGroupDataProviderMockGraphqlServer =
    new WorkingGroupSquidexDataProvider(squidexGraphqlClientMockServer);

  beforeEach(() => {
    jest.resetAllMocks();
  });

  describe('Fetch', () => {
    test('Should fetch the working group from squidex graphql', async () => {
      const result = await workingGroupDataProviderMockGraphqlServer.fetch();

      expect(result).toMatchObject(getListWorkingGroupDataObject());
    });

    test('Should return an empty result', async () => {
      const mockResponse = getSquidexWorkingGroupsGraphqlResponse();
      mockResponse.queryWorkingGroupsContentsWithTotal!.items = [];
      mockResponse.queryWorkingGroupsContentsWithTotal!.total = 0;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await workingGroupDataProvider.fetch();
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result if the client returns a response with a null items property', async () => {
      const mockResponse = getSquidexWorkingGroupsGraphqlResponse();
      mockResponse.queryWorkingGroupsContentsWithTotal = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await workingGroupDataProvider.fetch();
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should return an empty result if the client returns a response with a null query property', async () => {
      const mockResponse = getSquidexWorkingGroupsGraphqlResponse();
      mockResponse.queryWorkingGroupsContentsWithTotal!.items = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const result = await workingGroupDataProvider.fetch();
      expect(result).toEqual({ total: 0, items: [] });
    });

    test('Should default null title, shortDescription and leadingMembers to an empty string', async () => {
      const mockResponse = getSquidexWorkingGroupsGraphqlResponse();
      const workingGroup = getGraphQLWorkingGroup();
      workingGroup.flatData.title = null;
      workingGroup.flatData.shortDescription = null;
      workingGroup.flatData.leadingMembers = null;
      mockResponse.queryWorkingGroupsContentsWithTotal!.items = [workingGroup];
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      const { items } = await workingGroupDataProvider.fetch();
      expect(items[0]).toMatchObject({
        title: '',
        shortDescription: '',
        leadingMembers: '',
      });
    });
  });
  describe('FetchById', () => {
    test('Should fetch the working group from squidex graphql', async () => {
      const result = await workingGroupDataProviderMockGraphqlServer.fetchById(
        'working-group-id',
      );

      expect(result).toMatchObject(getWorkingGroupDataObject());
    });
    test('Should return null when the working group is not found', async () => {
      const mockResponse = getSquidexWorkingGroupGraphqlResponse();
      mockResponse.findWorkingGroupsContent = null;
      squidexGraphqlClientMock.request.mockResolvedValueOnce(mockResponse);

      expect(await workingGroupDataProvider.fetchById('not-found')).toBeNull();
    });
  });

  describe('Parsing', () => {
    test('the working group is parsed', () => {
      const workingGroup = getGraphQLWorkingGroup();
      const workingGroupDataObject =
        parseWorkingGroupToDataObject(workingGroup);
      const expected = getWorkingGroupDataObject();
      expect(workingGroupDataObject).toEqual(expected);
    });

    test('the members in working group are parsed', () => {
      const workingGroup = getGraphQLWorkingGroup();
      workingGroup.flatData.members = [getGraphQLWorkingGroupMember()];
      const { members } = parseWorkingGroupToDataObject(workingGroup);
      expect(members).toEqual([
        {
          userId: '42',
          role: 'Lead',
          firstName: 'Tony',
          lastName: 'Stark',
        },
      ]);
    });

    test('undefined members returns empty array', () => {
      const workingGroup = getGraphQLWorkingGroup();

      workingGroup.flatData.members = null;
      const { members } = parseWorkingGroupToDataObject(workingGroup);
      expect(members).toEqual([]);
    });

    test('avatar urls are added if available', () => {
      const workingGroup = getGraphQLWorkingGroup();
      const member = getGraphQLWorkingGroupMember();
      member!.user![0]!.flatData.avatar = [{ id: 'avatar-id' }];
      workingGroup.flatData.members = [member];
      const { members } = parseWorkingGroupToDataObject(workingGroup);
      expect(members[0]?.avatarUrl).toEqual(
        `${baseUrl}/api/assets/${appName}/avatar-id`,
      );
    });

    test('should skip the user from the result if the role property is undefined', () => {
      const workingGroup = getGraphQLWorkingGroup();
      const member = getGraphQLWorkingGroupMember();
      member!.role = null;
      workingGroup.flatData.members = [member];
      const { members } = parseWorkingGroupToDataObject(workingGroup);
      expect(members).toEqual([]);
    });
    test.each`
      role                                                   | expectedRole
      ${WorkingGroupsDataMembersRoleEnum.Lead}               | ${'Lead'}
      ${WorkingGroupsDataMembersRoleEnum.CoLead}             | ${'Co-lead'}
      ${WorkingGroupsDataMembersRoleEnum.WorkingGroupMember} | ${'Working group member'}
    `('should parse the role', ({ role, expectedRole }) => {
      const workingGroup = getGraphQLWorkingGroup();
      const member = getGraphQLWorkingGroupMember();
      member!.role = role;
      workingGroup.flatData.members = [member];
      const { members } = parseWorkingGroupToDataObject(workingGroup);
      expect(members[0]?.role).toEqual(expectedRole);
    });

    test('should skip the user from the result if the user property is undefined', () => {
      const workingGroup = getGraphQLWorkingGroup();
      const member = getGraphQLWorkingGroupMember();
      member!.user = null;
      workingGroup.flatData.members = [member];
      const { members } = parseWorkingGroupToDataObject(workingGroup);
      expect(members).toEqual([]);
    });
  });
});
