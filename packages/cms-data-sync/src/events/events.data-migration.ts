import { Entry, Link, Maybe } from '@asap-hub/contentful';
import { eventsQuery as squidexEventsQuery } from './events.queries';
import {
  FetchEventsQuery as SquidexFetchEventsQuery,
  FetchEventsQueryVariables as SquidexFetchEventsQueryVariables,
} from '../autogenerated-gql/graphql';
import {
  convertHtmlToContentfulFormat,
  createAsset,
  createInlineAssets,
  createMediaEntries,
  getSquidexAndContentfulClients,
  logger,
  paginatedFetch,
} from '../utils';
import { migrateFromSquidexToContentfulFactory } from '../utils/migration';
import { contentfulRateLimiter } from '../contentful-rate-limiter';

export type EventItem = NonNullable<
  NonNullable<SquidexFetchEventsQuery['queryEventsContentsWithTotal']>['items']
>[number];

export const migrateEvents = async () => {
  const { contentfulEnvironment, squidexGraphqlClient } =
    await getSquidexAndContentfulClients();

  const migrateFromSquidexToContentful = migrateFromSquidexToContentfulFactory(
    contentfulEnvironment,
    logger,
  );
  const fetchAllData = async (): Promise<EventItem[]> =>
    paginatedFetch<EventItem>(async (take: number, skip: number) => {
      const { queryEventsContentsWithTotal } =
        await squidexGraphqlClient.request<
          SquidexFetchEventsQuery,
          SquidexFetchEventsQueryVariables
        >(squidexEventsQuery, { take, skip });
      return queryEventsContentsWithTotal;
    });

  const fetchData = async () => {
    const entries = await fetchAllData();
    logger(`Loaded ${entries.length} entries...`, 'INFO');
    return entries;
  };

  const fetchContentfulEventByGoogleId = async (googleId: string) => {
    const events = await contentfulEnvironment.getEntries({
      content_type: 'events',
      'fields.googleId': googleId,
    });

    if (!events || !events.items.length) {
      return null;
    }

    return events.items[0];
  };

  const createDocumentIfNeeded = async (field: Maybe<string>) => {
    if (field) {
      const { document, inlineAssetBodies, inlineIFramesBodies } =
        convertHtmlToContentfulFormat(field);
      await createInlineAssets(contentfulEnvironment, inlineAssetBodies);
      await createMediaEntries(contentfulEnvironment, inlineIFramesBodies);
      return document;
    }
    return null;
  };

  const createSpeakerEntry = async (
    speakers: EventItem['flatData']['speakers'],
    eventId: string,
  ) => {
    if (speakers) {
      const speakersLinks = await Promise.all(
        speakers.map(async ({ team: squidexTeam, user: squidexUser }) => {
          const teamId = squidexTeam ? squidexTeam[0].id : null;
          const userId = squidexUser ? squidexUser[0].id : null;

          await contentfulRateLimiter.removeTokens(2);
          try {
            const contentfulTeam = teamId
              ? await contentfulEnvironment.getEntry(teamId)
              : null;

            const contentfulUser = userId
              ? await contentfulEnvironment.getEntry(userId)
              : null;

            if (contentfulTeam && contentfulUser) {
              const speakerEntry = await contentfulEnvironment.createEntry(
                'eventSpeakers',
                {
                  fields: {
                    team: {
                      'en-US': {
                        sys: {
                          type: 'Link',
                          linkType: 'Entry',
                          id: teamId,
                        },
                      },
                    },
                    user: {
                      'en-US': {
                        sys: {
                          type: 'Link',
                          linkType: 'Entry',
                          id: userId,
                        },
                      },
                    },
                  },
                },
              );

              await speakerEntry.publish();
              return {
                sys: {
                  type: 'Link',
                  linkType: 'Entry',
                  id: speakerEntry.sys.id,
                },
              };
            }

            if (contentfulUser) {
              const speakerEntry = await contentfulEnvironment.createEntry(
                'eventSpeakers',
                {
                  fields: {
                    user: {
                      'en-US': {
                        sys: {
                          type: 'Link',
                          linkType: 'Entry',
                          id: userId,
                        },
                      },
                    },
                  },
                },
              );

              await speakerEntry.publish();

              return {
                sys: {
                  type: 'Link',
                  linkType: 'Entry',
                  id: speakerEntry.sys.id,
                },
              };
            }
            logger(
              `There's a speaker without a user. Please review event with id ${eventId}`,
              'ERROR',
            );
            return null;
          } catch {
            // edge case, this should not happen if the migration happened in the correct order
            logger(
              `Either user ${userId} or team ${teamId} do not exist in contentful. Please review event with id ${eventId}`,
              'ERROR',
            );
          }

          return null;
        }),
      );
      return speakersLinks.filter(Boolean) as Link<'Entry'>[];
    }

    return null;
  };

  const createCalendarLink = async (
    calendar: EventItem['flatData']['calendar'],
    eventId: string,
  ) => {
    if (calendar) {
      const calendarId = calendar[0].id;

      try {
        await contentfulRateLimiter.removeTokens(1);
        await contentfulEnvironment.getEntry(calendarId);

        return {
          sys: {
            type: 'Link',
            linkType: 'Entry',
            id: calendarId,
          },
        };
      } catch {
        // edge case, this should not happen if the migration happened in the correct order
        logger(
          `Calendar ${calendarId} does not exist in contentful. Event with id ${eventId} is going to be created without a calendar.`,
          'ERROR',
        );
      }
    }

    return null;
  };

  const deletePreviousSpeakerReferences = async (contentfulEvent: Entry) => {
    if (contentfulEvent.fields.speakers) {
      await Promise.all(
        contentfulEvent.fields.speakers['en-US'].map(
          async (speakerLink: Link<'Entry'>) => {
            await contentfulRateLimiter.removeTokens(2);
            try {
              const entry = await contentfulEnvironment.getEntry(
                speakerLink.sys.id,
              );
              await entry.unpublish();
              await entry.delete();
            } catch {
              logger('Error deleting old speaker', 'ERROR');
            }
          },
        ),
      );
    }
  };

  const parseEventItem = async (event: EventItem) => {
    const { id, flatData: squidexFlatData } = event;
    const {
      googleId,
      hidden,
      meetingLink,
      hideMeetingLink,
      thumbnail,
      tags,
      speakers,
      notes,
      notesPermanentlyUnavailable,
      notesUpdatedAt,
      videoRecording,
      videoRecordingPermanentlyUnavailable,
      videoRecordingUpdatedAt,
      presentation,
      presentationPermanentlyUnavailable,
      presentationUpdatedAt,
      meetingMaterials,
      meetingMaterialsPermanentlyUnavailable,
      calendar,
    } = squidexFlatData;

    const materialsSpeakersThumbAndMeetingLink = {
      thumbnail: thumbnail?.length
        ? await createAsset(contentfulEnvironment, thumbnail)
        : null,
      speakers: await createSpeakerEntry(speakers, id),
      notes: await createDocumentIfNeeded(notes),
      videoRecording: await createDocumentIfNeeded(videoRecording),
      presentation: await createDocumentIfNeeded(presentation),
      // it throws an error if meetingLink is ''
      // because it's not a valid url
      meetingLink: meetingLink?.trim() === '' ? null : meetingLink?.trim(),
    };

    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const contentfulEvent = await fetchContentfulEventByGoogleId(googleId!);

    if (contentfulEvent) {
      await deletePreviousSpeakerReferences(contentfulEvent);

      return {
        id: contentfulEvent.sys.id,
        updateEntry: true,
        hidden,
        hideMeetingLink,
        tags,
        notesPermanentlyUnavailable,
        notesUpdatedAt,
        videoRecordingPermanentlyUnavailable,
        videoRecordingUpdatedAt,
        presentationPermanentlyUnavailable,
        presentationUpdatedAt,
        meetingMaterials,
        meetingMaterialsPermanentlyUnavailable,
        ...materialsSpeakersThumbAndMeetingLink,
      };
    }

    return {
      id,
      updateEntry: false,
      ...squidexFlatData,
      ...materialsSpeakersThumbAndMeetingLink,
      calendar: await createCalendarLink(calendar, id),
    };
  };

  // this clearPreviousEntries should be set to false
  // in case we want to update the existing Contentful events
  // created during google calendar sync instead of creating
  // the events during the migration
  const clearPreviousEntries = true;

  await migrateFromSquidexToContentful<EventItem>(
    'events',
    fetchData,
    parseEventItem,
    clearPreviousEntries,
  );
};
