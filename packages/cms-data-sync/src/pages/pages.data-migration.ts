import { Document } from '@contentful/rich-text-types';
import { RateLimiter } from 'limiter';
import {
  FetchPagesQuery,
  FetchPagesQueryVariables,
} from '../autogenerated-gql/graphql';
import { createMediaEntries } from '../utils';
import { createInlineAssets } from '../utils/assets';
import { logger } from '../utils/logs';
import { migrateFromSquidexToContentfulFactory } from '../utils/migration';
import { convertHtmlToContentfulFormat } from '../utils/rich-text';
import { getSquidexAndContentfulClients } from '../utils/setup';
import { pagesQuery } from './pages.queries';

type PageItem = NonNullable<FetchPagesQuery['queryPagesContents']>[number];

const limiter = new RateLimiter({ tokensPerInterval: 7, interval: 'second' });

export const migratePages = async () => {
  const { contentfulEnvironment, squidexGraphqlClient } =
    await getSquidexAndContentfulClients();

  const migrateFromSquidexToContentful = migrateFromSquidexToContentfulFactory(
    contentfulEnvironment,
    logger,
    limiter,
  );

  const fetchData = async () => {
    const gqlNews = await squidexGraphqlClient.request<
      FetchPagesQuery,
      FetchPagesQueryVariables
    >(pagesQuery);

    return gqlNews.queryPagesContents || [];
  };

  const parsePagesItem = async (page: PageItem) => {
    const { flatData: squidexPageItem, id } = page;

    const { title, shortText, link, linkText, text, path } = squidexPageItem;

    const pagePayload = {
      title,
      path,
      shortText,
      link,
      linkText,
      text: null as Document | null,
    };

    if (text) {
      try {
        const { document, inlineAssetBodies, inlineIFramesBodies } =
          convertHtmlToContentfulFormat(text);
        pagePayload.text = document;
        await createInlineAssets(contentfulEnvironment, inlineAssetBodies);
        await createMediaEntries(contentfulEnvironment, inlineIFramesBodies);
      } catch {
        logger(
          `There is a problem converting rich text from entry ${id}`,
          'ERROR',
        );
      }
    }

    return { id, ...pagePayload };
  };

  const fallbackParsePageItem = async (
    page: Record<string, unknown>,
  ): Promise<Record<string, unknown>> => {
    // Most probably it failed because the rich text could not be
    // processed, so here we will try to create the entry
    // without the rich text
    // eslint-disable-next-line no-param-reassign
    page.text = null;

    return page;
  };

  await migrateFromSquidexToContentful<PageItem>(
    'pages',
    fetchData,
    parsePagesItem,
    true,
    fallbackParsePageItem,
  );
};
