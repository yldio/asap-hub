import gql from 'graphql-tag';
import {
  Exact,
  Maybe,
  ResearchOutputs,
  ResearchOutputsFlatDataDto,
} from './autogenerated-gql/graphql';
import {
  convertHtmlToContentfulFormat,
  createInlineAssets,
  getSquidexAndContentfulClients,
} from './utils';
import { migrateFromSquidexToContentfulFactory } from './utils/migration';

type ResearchOutputItem = Pick<ResearchOutputs, 'id'> & {
  flatData: Pick<ResearchOutputsFlatDataDto, 'description'>;
};

(async () => {
  const { contentfulEnvironment, squidexGraphqlClient } =
    await getSquidexAndContentfulClients();
  const migrateFromSquidexToContentful = migrateFromSquidexToContentfulFactory(
    contentfulEnvironment,
    (message, level) => {
      if (level === 'ERROR-DEBUG') {
        // throw new Error(message);
      }
      console.debug(message);
    },
  );

  let total = 0;
  let successful = 0;
  let failed = 0;
  let recordCount = 0;
  let records: ResearchOutputItem[] = [];

  const fetchData = async () => {
    // const gqlNews = await squidexGraphqlClient.request<
    //   FetchNewsQuery,
    //   FetchNewsQueryVariables
    // >(newsQuery);

    // const gqlPages = await squidexGraphqlClient.request<
    //   FetchPagesQuery,
    //   FetchPagesQueryVariables
    // >(pagesQuery);

    // paginate through all research outputs
    do {
      const gqlResearchOutputs = await squidexGraphqlClient.request<
        FetchResearchOutputsQuery,
        FetchResearchOutputsQueryVariables
      >(researchOutputsQuery, { top: 50, skip: recordCount });
      total = gqlResearchOutputs.queryResearchOutputsContents?.length || 0;
      recordCount +=
        gqlResearchOutputs.queryResearchOutputsContents?.length || 0;
      records = [
        ...records,
        ...(gqlResearchOutputs.queryResearchOutputsContents || []),
      ];
      console.log(records);
      break;
    } while (recordCount < 30);

    return records;
  };

  const parseItem = async (item: ResearchOutputItem) => {
    const {
      flatData: { description },
      id,
    } = item;

    let content: any;

    if (!description) {
      return {
        id,
        content: null,
      };
    }

    try {
      // remove br and wbr html tags from text
      // const textWithoutBr = description.replace(/<br\s*\/?>/gi, '');
      const textWithoutWbr = description.replace(/<wbr\s*\/?>/gi, '');
      // remove wbr html tag with inline style from text
      const textWithoutWbrWithInlineStyle = textWithoutWbr.replace(
        /<wbr\s*style="(.*)"\s*\/?>/gi,
        '',
      );

      const { document, inlineAssetBodies } = convertHtmlToContentfulFormat(
        textWithoutWbrWithInlineStyle,
      );
      content = document;
      await createInlineAssets(contentfulEnvironment, inlineAssetBodies);
    } catch (error) {
      console.error(error);
    }

    return {
      id,
      content,
    };
  };

  let failedEmptyContent = 0;

  const onComplete = async (error: any) => {
    if (error) {
      failed++;

      const errorMessage = JSON.parse(error.message);
      if (errorMessage.status === 422) {
        if (errorMessage.details?.errors?.length > 0) {
          const errorList = errorMessage.details.errors;
          if (
            errorList.some(
              (err: any) =>
                err.expected &&
                err.expected[0]['$ref'] === '#/definitions/Inline',
            )
          ) {
            failedEmptyContent++;
          }
        }
      }
    } else {
      successful++;
    }
  };

  await migrateFromSquidexToContentful<ResearchOutputItem>(
    'testModel',
    fetchData,
    parseItem,
    undefined,
    onComplete,
  );

  console.log(
    `Total: ${total}, Successful: ${successful}, Failed: ${failed}, Failed empty content: ${failedEmptyContent}`,
  );
})();

export const researchOutputsQuery = gql`
  query QueryResearchOutputs($top: Int!, $skip: Int!) {
    queryResearchOutputsContents(top: $top, skip: $skip) {
      id
      flatData {
        description
      }
    }
  }
`;

export type FetchResearchOutputsQueryVariables = Exact<{
  top: number;
  skip: number;
}>;

export type FetchResearchOutputsQuery = {
  queryResearchOutputsContents: Maybe<
    Array<
      Pick<ResearchOutputs, 'id'> & {
        flatData: Pick<ResearchOutputsFlatDataDto, 'description'>;
      }
    >
  >;
};
