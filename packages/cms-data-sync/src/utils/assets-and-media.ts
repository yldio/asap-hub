/* eslint-disable no-console */

import {
  InlineAssetBody,
  InlineIFrameBody,
} from 'contentful-html-rich-text-converter';
import {
  Asset as ContentfulAsset,
  Entry,
  Environment,
  SysLink,
} from 'contentful-management';
import { Asset } from '../autogenerated-gql/graphql';
import { checkIfEntryAlreadyExistsInContentful } from './entries';

export const checkIfAssetAlreadyExistsInContentful = async (
  contentfulEnvironment: Environment,
  id: string,
) => {
  try {
    const asset = await contentfulEnvironment.getAsset(id);
    return !!asset;
  } catch (error) {
    if (error instanceof Error) {
      const errorParsed = JSON.parse(error?.message);
      if (errorParsed.status === 404) {
        return false;
      }
    }

    throw error;
  }
};

export const processAndPublishEntry = async (
  entry: ContentfulAsset | Entry,
) => {
  try {
    if ('processForAllLocales' in entry) {
      const processedEntry = await entry.processForAllLocales();
      await processedEntry.publish();
    } else {
      await entry.publish();
    }
  } catch (error) {
    if (error instanceof Error) {
      const errorParsed = JSON.parse(error?.message);
      if (errorParsed.message === 'File has already been processed.') {
        return;
      }
    }
    throw error;
  }
};

export const createAndPublishIfNonExistent = async (
  type: 'asset' | 'media',
  contentfulEnvironment: Environment,
  id: string,
  checkIfExistsFn: (
    contentfulEnvironment: Environment,
    id: string,
  ) => Promise<boolean>,
  createFn: () => Promise<ContentfulAsset> | Promise<Entry>,
  handleErrorFn: (
    contentfulEnvironment: Environment,
    id: string,
  ) => Promise<void>,
) => {
  const isAlreadyInContentful = await checkIfExistsFn(
    contentfulEnvironment,
    id,
  );

  if (!isAlreadyInContentful) {
    try {
      console.log(`Creating ${type} with id ${id}.`);

      const entry = await createFn();
      await processAndPublishEntry(entry);
    } catch (error) {
      if (error instanceof Error) {
        try {
          const errorParsed = JSON.parse(error?.message);
          if (errorParsed.status === 409) {
            await handleErrorFn(contentfulEnvironment, id);
            return;
          }
        } catch (e) {
          throw error;
        }
      }

      throw error;
    }
  }
};

export const handleMediaConflictError = async (
  contentfulEnvironment: Environment,
  id: string,
) => {
  const entry = await contentfulEnvironment.getEntry(id);
  await processAndPublishEntry(entry);
};

export const createMediaEntries = async (
  contentfulEnvironment: Environment,
  inlineIFramesBodies: InlineIFrameBody[],
) => {
  for (const [id, fields] of inlineIFramesBodies) {
    const createEntryFunction = () =>
      contentfulEnvironment.createEntryWithId('media', id, fields);

    await createAndPublishIfNonExistent(
      'media',
      contentfulEnvironment,
      id,
      checkIfEntryAlreadyExistsInContentful,
      createEntryFunction,
      handleMediaConflictError,
    );
  }
};

export const handleAssetConflictError = async (
  contentfulEnvironment: Environment,
  id: string,
) => {
  const asset = await contentfulEnvironment.getAsset(id);
  await processAndPublishEntry(asset);
};

export const createInlineAssets = async (
  contentfulEnvironment: Environment,
  inlineAssetBodies: InlineAssetBody[],
) => {
  for (const [id, fields] of inlineAssetBodies) {
    const createAssetFunction = () =>
      contentfulEnvironment.createAssetWithId(id, fields);
    await createAndPublishIfNonExistent(
      'asset',
      contentfulEnvironment,
      id,
      checkIfAssetAlreadyExistsInContentful,
      createAssetFunction,
      handleAssetConflictError,
    );
  }
};

export const migrateAsset = async (
  contentfulEnvironment: Environment,
  thumbnails: Pick<
    Asset,
    'id' | 'fileName' | 'thumbnailUrl' | 'mimeType' | 'fileType'
  >[],
) => {
  for (const { id, fileName, thumbnailUrl, mimeType, fileType } of thumbnails) {
    if (thumbnailUrl) {
      const createAssetFunction = () =>
        contentfulEnvironment.createAssetWithId(id, {
          fields: {
            title: {
              'en-US': fileName.replace(`.${fileType}`, ''),
            },
            file: {
              'en-US': {
                contentType: mimeType,
                fileName,
                upload: thumbnailUrl,
              },
            },
          },
        });
      await createAndPublishIfNonExistent(
        'asset',
        contentfulEnvironment,
        id,
        checkIfAssetAlreadyExistsInContentful,
        createAssetFunction,
        handleAssetConflictError,
      );
    }
  }
};

export const createAsset = async (
  contentfulEnvironment: Environment,
  asset: Pick<
    Asset,
    'id' | 'fileName' | 'thumbnailUrl' | 'mimeType' | 'fileType'
  >[],
): Promise<SysLink> => {
  await migrateAsset(contentfulEnvironment, asset);
  return {
    sys: {
      type: 'Link',
      linkType: 'Asset',
      // in thumbnail it's possible to load only one asset
      id: asset[0]?.id,
    },
  };
};
