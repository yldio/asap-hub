import { SquidexGraphqlClient, createUrlFactory } from '@asap-hub/squidex';
import { Environment } from 'contentful-management';
import { migrateEvents } from '../../src/events/events.data-migration';
import type { EventItem } from '../../src/events/events.data-migration';
import { getEntry, eventEntry } from '../fixtures';
import {
  clearContentfulEntries,
  getSquidexAndContentfulClients,
} from '../../src/utils';
import { getContentfulEnvironmentMock } from '../mocks/contentful.mocks';
import { FetchEventsQuery } from '../../src/autogenerated-gql/graphql';

jest.mock('../../src/utils/setup');
jest.mock('../../src/utils/assets');
jest.mock('../../src/utils/entries');

const getEventSquidex = (): EventItem => ({
  id: 'event-1',
  flatData: {
    googleId: '1jhm4181bs6ck0esegje4nf6ur',
    description: null,
    endDate: '2023-04-03T17:00:00Z',
    endDateTimeZone: 'America/Sao_Paulo',
    startDate: '2023-04-03T16:00:00Z',
    startDateTimeZone: 'America/Sao_Paulo',
    meetingLink: 'https://meet.google.com/idr-kixv-hhm',
    hideMeetingLink: true,
    eventLink: null,
    status: 'Confirmed',
    hidden: true,
    tags: ['googleMeet', 'science'],
    title: 'Amazing event!!!',
    notesPermanentlyUnavailable: null,
    notes: '<p>notes</p>',
    notesUpdatedAt: '2023-05-17T13:38:51.128Z',
    videoRecordingPermanentlyUnavailable: null,
    videoRecording: null,
    videoRecordingUpdatedAt: null,
    presentationPermanentlyUnavailable: null,
    presentation: null,
    presentationUpdatedAt: null,
    meetingMaterialsPermanentlyUnavailable: null,
    meetingMaterials: [
      {
        url: 'https://drive.google.com/drive/folders/id',
        title: 'Drive folder',
      },
      {
        url: 'https://slack.com/intl/pt-br/',
        title: 'Slack',
      },
    ],
    calendar: [
      {
        id: '1e34bfaa-6752-41ec-a796-eca801228a90',
      },
    ],
    thumbnail: [
      {
        id: '371b0102-7cf1-425f-bec5-8d03accaf91b',
        fileName: 'ASAP Network thumbnail.jpg',
        thumbnailUrl:
          'https://cloud.squidex.io/api/assets/crn-3046/371b0102-7cf1-425f-bec5-8d03accaf91b?width=100&mode=Max',
        mimeType: 'image/jpeg',
        fileType: 'jpg',
      },
    ],
    speakers: [
      {
        team: [
          {
            id: 'team-1',
          },
        ],
        user: [
          {
            __typename: 'Users',
            id: 'user-1',
          },
        ],
      },
      {
        team: null,
        user: [
          {
            __typename: 'ExternalAuthors',
            id: 'external-user-1',
          },
        ],
      },
    ],
  },
});

const getEventSquidexResponse = (): FetchEventsQuery => ({
  queryEventsContentsWithTotal: {
    total: 1,
    items: [getEventSquidex()],
  },
});

describe('Migrate events', () => {
  let contentfulEnv: Environment;
  let squidexGraphqlClientMock: jest.Mocked<SquidexGraphqlClient>;

  const consoleLogRef = console.log;
  beforeEach(() => {
    console.log = jest.fn();
    contentfulEnv = getContentfulEnvironmentMock();
    squidexGraphqlClientMock = {
      request: jest.fn(),
    };

    (getSquidexAndContentfulClients as jest.Mock).mockResolvedValueOnce({
      contentfulEnvironment: contentfulEnv,
      squidexGraphqlClient: squidexGraphqlClientMock,
    });

    jest.spyOn(contentfulEnv, 'getEntries').mockResolvedValueOnce({
      total: 1,
      items: [eventEntry],
      skip: 0,
      limit: 10,
      toPlainObject: jest.fn(),
      sys: { type: 'Array' },
    });
    jest.spyOn(contentfulEnv, 'getEntry').mockResolvedValue(getEntry({}));
    jest.spyOn(contentfulEnv, 'createEntry').mockResolvedValue(getEntry({}));

    jest.spyOn(eventEntry, 'publish').mockResolvedValue(getEntry({}));
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  afterAll(() => {
    console.log = consoleLogRef;
  });

  it('does not call clear contentful entries for events', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );

    await migrateEvents();

    const clearContentfulEntriesMock = clearContentfulEntries as jest.Mock;
    expect(clearContentfulEntriesMock).not.toHaveBeenCalled();
  });

  it('unpublishes and deletes previous speakers from existing Contentful event', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );
    const eventWithSpeakers = {
      ...eventEntry,
      fields: {
        ...eventEntry.fields,
        speakers: {
          'en-US': [
            {
              sys: { id: 'old-speaker', linkType: 'Entry', type: 'Link' },
            },
          ],
        },
      },
    };
    jest
      .spyOn(contentfulEnv, 'getEntries')
      .mockReset()
      .mockResolvedValueOnce({
        total: 1,
        items: [eventWithSpeakers],
        skip: 0,
        limit: 10,
        toPlainObject: jest.fn(),
        sys: { type: 'Array' },
      });

    const previousSpeakerMock = getEntry({});
    jest
      .spyOn(contentfulEnv, 'getEntry')
      .mockClear()
      .mockResolvedValueOnce(getEntry({})) // team
      .mockResolvedValueOnce(getEntry({})) // user
      .mockResolvedValueOnce(getEntry({})) // external-user
      .mockResolvedValueOnce(previousSpeakerMock); // speaker

    await migrateEvents();

    expect(previousSpeakerMock.unpublish).toHaveBeenCalled();
    expect(previousSpeakerMock.delete).toHaveBeenCalled();
  });

  it('outputs an error if it is not possible to unpublish and delete previous speakers from existing Contentful event', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );
    const eventWithSpeakers = {
      ...eventEntry,
      fields: {
        ...eventEntry.fields,
        speakers: {
          'en-US': [
            {
              sys: { id: 'old-speaker', linkType: 'Entry', type: 'Link' },
            },
          ],
        },
      },
    };
    jest
      .spyOn(contentfulEnv, 'getEntries')
      .mockReset()
      .mockResolvedValueOnce({
        total: 1,
        items: [eventWithSpeakers],
        skip: 0,
        limit: 10,
        toPlainObject: jest.fn(),
        sys: { type: 'Array' },
      });

    jest
      .spyOn(contentfulEnv, 'getEntry')
      .mockClear()
      .mockResolvedValueOnce(getEntry({})) // team
      .mockResolvedValueOnce(getEntry({})) // user
      .mockResolvedValueOnce(getEntry({})) // external-user
      .mockRejectedValueOnce(new Error()); // speaker

    await migrateEvents();

    expect(console.log).toHaveBeenCalledWith(
      '\x1b[31m',
      '[ERROR] Error deleting old speaker',
    );
  });

  it('outputs a message when user or team is not found in contentful', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );
    jest
      .spyOn(contentfulEnv, 'getEntry')
      .mockRejectedValue(new Error('not-found'));

    await migrateEvents();

    expect(console.log).toHaveBeenCalledWith(
      '\x1b[31m',
      '[ERROR] Either user external-user-1 or team null do not exist in contentful. Please review event with id event-1',
    );
  });

  it('creates eventSpeakers entries', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );

    const eventSpeakersMock = getEntry({});
    jest
      .spyOn(contentfulEnv, 'createEntry')
      .mockResolvedValue(eventSpeakersMock);

    await migrateEvents();

    expect(contentfulEnv.createEntry).toHaveBeenCalledTimes(2);
    expect(contentfulEnv.createEntry).toHaveBeenNthCalledWith(
      1,
      'eventSpeakers',
      {
        fields: {
          user: {
            'en-US': {
              sys: { id: 'external-user-1', linkType: 'Entry', type: 'Link' },
            },
          },
        },
      },
    );

    expect(contentfulEnv.createEntry).toHaveBeenNthCalledWith(
      2,
      'eventSpeakers',
      {
        fields: {
          team: {
            'en-US': {
              sys: { id: 'team-1', linkType: 'Entry', type: 'Link' },
            },
          },
          user: {
            'en-US': {
              sys: { id: 'user-1', linkType: 'Entry', type: 'Link' },
            },
          },
        },
      },
    );

    expect(eventSpeakersMock.publish).toHaveBeenCalled();
  });

  it("does not create eventSpeakers entries if there isn't any", async () => {
    const eventWithoutSpeakers = getEventSquidexResponse();
    eventWithoutSpeakers.queryEventsContentsWithTotal!.items![0].flatData.speakers =
      [];
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      eventWithoutSpeakers,
    );
    jest
      .spyOn(contentfulEnv, 'getEntries')
      .mockReset()
      .mockImplementation(() =>
        Promise.resolve({
          total: 0,
          items: [],
          skip: 0,
          limit: 10,
          toPlainObject: jest.fn(),
          sys: { type: 'Array' },
        }),
      );
    await migrateEvents();

    expect(contentfulEnv.createEntry).not.toHaveBeenCalled();
    expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
      'events',
      'event-1',
      {
        fields: {
          calendar: {
            'en-US': {
              sys: {
                id: '1e34bfaa-6752-41ec-a796-eca801228a90',
                linkType: 'Entry',
                type: 'Link',
              },
            },
          },
          description: { 'en-US': null },
          endDate: { 'en-US': '2023-04-03T17:00:00Z' },
          endDateTimeZone: { 'en-US': 'America/Sao_Paulo' },
          eventLink: { 'en-US': null },
          googleId: { 'en-US': '1jhm4181bs6ck0esegje4nf6ur' },
          hidden: { 'en-US': true },
          hideMeetingLink: { 'en-US': true },
          meetingLink: { 'en-US': 'https://meet.google.com/idr-kixv-hhm' },
          meetingMaterials: {
            'en-US': [
              {
                title: 'Drive folder',
                url: 'https://drive.google.com/drive/folders/id',
              },
              { title: 'Slack', url: 'https://slack.com/intl/pt-br/' },
            ],
          },
          meetingMaterialsPermanentlyUnavailable: { 'en-US': null },
          notes: {
            'en-US': {
              content: [
                {
                  content: [
                    { data: {}, marks: [], nodeType: 'text', value: 'notes' },
                  ],
                  data: {},
                  nodeType: 'paragraph',
                },
              ],
              data: {},
              nodeType: 'document',
            },
          },
          notesPermanentlyUnavailable: { 'en-US': null },
          notesUpdatedAt: { 'en-US': '2023-05-17T13:38:51.128Z' },
          presentation: { 'en-US': null },
          presentationPermanentlyUnavailable: { 'en-US': null },
          presentationUpdatedAt: { 'en-US': null },
          speakers: { 'en-US': [] },
          startDate: { 'en-US': '2023-04-03T16:00:00Z' },
          startDateTimeZone: { 'en-US': 'America/Sao_Paulo' },
          status: { 'en-US': 'Confirmed' },
          tags: { 'en-US': ['googleMeet', 'science'] },
          thumbnail: { 'en-US': undefined },
          title: { 'en-US': 'Amazing event!!!' },
          videoRecording: { 'en-US': null },
          videoRecordingPermanentlyUnavailable: { 'en-US': null },
          videoRecordingUpdatedAt: { 'en-US': null },
        },
      },
    );
  });

  it('updates existing Contentful event', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );
    const eventMock = getEntry({});

    jest
      .spyOn(contentfulEnv, 'getEntry')
      .mockClear()
      .mockResolvedValueOnce(getEntry({})) // team
      .mockResolvedValueOnce(getEntry({})) // user
      .mockResolvedValueOnce(getEntry({})) // external-user
      .mockResolvedValueOnce(eventMock); // event

    await migrateEvents();

    expect(eventMock.fields).toEqual({
      hidden: { 'en-US': true },
      hideMeetingLink: { 'en-US': true },
      meetingLink: { 'en-US': 'https://meet.google.com/idr-kixv-hhm' },
      meetingMaterials: {
        'en-US': [
          {
            title: 'Drive folder',
            url: 'https://drive.google.com/drive/folders/id',
          },
          { title: 'Slack', url: 'https://slack.com/intl/pt-br/' },
        ],
      },
      meetingMaterialsPermanentlyUnavailable: { 'en-US': null },
      notes: {
        'en-US': {
          content: [
            {
              content: [
                { data: {}, marks: [], nodeType: 'text', value: 'notes' },
              ],
              data: {},
              nodeType: 'paragraph',
            },
          ],
          data: {},
          nodeType: 'document',
        },
      },
      notesPermanentlyUnavailable: { 'en-US': null },
      notesUpdatedAt: { 'en-US': '2023-05-17T13:38:51.128Z' },
      presentation: { 'en-US': null },
      presentationPermanentlyUnavailable: { 'en-US': null },
      presentationUpdatedAt: { 'en-US': null },
      speakers: {
        'en-US': [
          { sys: { id: 'entry-id', linkType: 'Entry', type: 'Link' } },
          { sys: { id: 'entry-id', linkType: 'Entry', type: 'Link' } },
        ],
      },
      tags: { 'en-US': ['googleMeet', 'science'] },
      thumbnail: { 'en-US': undefined },
      videoRecording: { 'en-US': null },
      videoRecordingPermanentlyUnavailable: { 'en-US': null },
      videoRecordingUpdatedAt: { 'en-US': null },
    });
    expect(eventMock.update).toHaveBeenCalled();
  });

  it('creates a new Contentful event when it does not exist there yet', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );

    jest.spyOn(contentfulEnv, 'getEntry').mockResolvedValue(getEntry({}));
    jest.spyOn(contentfulEnv, 'createEntry').mockResolvedValue(getEntry({}));

    jest
      .spyOn(contentfulEnv, 'getEntries')
      .mockReset()
      .mockImplementation(() =>
        Promise.resolve({
          total: 0,
          items: [],
          skip: 0,
          limit: 10,
          toPlainObject: jest.fn(),
          sys: { type: 'Array' },
        }),
      );
    await migrateEvents();

    expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
      'events',
      'event-1',
      {
        fields: {
          calendar: {
            'en-US': {
              sys: {
                id: '1e34bfaa-6752-41ec-a796-eca801228a90',
                linkType: 'Entry',
                type: 'Link',
              },
            },
          },
          description: { 'en-US': null },
          endDate: { 'en-US': '2023-04-03T17:00:00Z' },
          endDateTimeZone: { 'en-US': 'America/Sao_Paulo' },
          eventLink: { 'en-US': null },
          googleId: { 'en-US': '1jhm4181bs6ck0esegje4nf6ur' },
          hidden: { 'en-US': true },
          hideMeetingLink: { 'en-US': true },
          meetingLink: { 'en-US': 'https://meet.google.com/idr-kixv-hhm' },
          meetingMaterials: {
            'en-US': [
              {
                title: 'Drive folder',
                url: 'https://drive.google.com/drive/folders/id',
              },
              { title: 'Slack', url: 'https://slack.com/intl/pt-br/' },
            ],
          },
          meetingMaterialsPermanentlyUnavailable: { 'en-US': null },
          notes: {
            'en-US': {
              content: [
                {
                  content: [
                    { data: {}, marks: [], nodeType: 'text', value: 'notes' },
                  ],
                  data: {},
                  nodeType: 'paragraph',
                },
              ],
              data: {},
              nodeType: 'document',
            },
          },
          notesPermanentlyUnavailable: { 'en-US': null },
          notesUpdatedAt: { 'en-US': '2023-05-17T13:38:51.128Z' },
          presentation: { 'en-US': null },
          presentationPermanentlyUnavailable: { 'en-US': null },
          presentationUpdatedAt: { 'en-US': null },
          speakers: {
            'en-US': [
              {
                sys: {
                  type: 'Link',
                  linkType: 'Entry',
                  id: 'entry-id',
                },
              },
              {
                sys: {
                  type: 'Link',
                  linkType: 'Entry',
                  id: 'entry-id',
                },
              },
            ],
          },
          startDate: { 'en-US': '2023-04-03T16:00:00Z' },
          startDateTimeZone: { 'en-US': 'America/Sao_Paulo' },
          status: { 'en-US': 'Confirmed' },
          tags: { 'en-US': ['googleMeet', 'science'] },
          thumbnail: { 'en-US': undefined },
          title: { 'en-US': 'Amazing event!!!' },
          videoRecording: { 'en-US': null },
          videoRecordingPermanentlyUnavailable: { 'en-US': null },
          videoRecordingUpdatedAt: { 'en-US': null },
        },
      },
    );
  });

  it('outputs a message if a calendar does not exists in Contentful', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );

    jest.spyOn(contentfulEnv, 'createEntry').mockResolvedValue(getEntry({}));

    jest
      .spyOn(contentfulEnv, 'getEntry')
      .mockClear()
      .mockResolvedValueOnce(getEntry({})) // team
      .mockResolvedValueOnce(getEntry({})) // user
      .mockResolvedValueOnce(getEntry({})) // external-user
      .mockRejectedValueOnce(new Error('not-found')); // calendar
    jest
      .spyOn(contentfulEnv, 'getEntries')
      .mockReset()
      .mockImplementation(() =>
        Promise.resolve({
          total: 0,
          items: [],
          skip: 0,
          limit: 10,
          toPlainObject: jest.fn(),
          sys: { type: 'Array' },
        }),
      );
    await migrateEvents();

    expect(console.log).toHaveBeenCalledWith(
      '\x1b[31m',
      '[ERROR] Calendar 1e34bfaa-6752-41ec-a796-eca801228a90 does not exist in contentful. Event with id event-1 is going to be created without a calendar.',
    );
  });
});
