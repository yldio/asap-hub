/* eslint-disable no-console */
import { SquidexGraphqlClient } from '@asap-hub/squidex';
import { Environment } from 'contentful-management';
import { when } from 'jest-when';

import { migrateEvents } from '../../src/events/events.data-migration';
import type { EventItem } from '../../src/events/events.data-migration';
import { getEntry, eventEntry } from '../fixtures';
import {
  clearContentfulEntries,
  getSquidexAndContentfulClients,
} from '../../src/utils';
import { getContentfulEnvironmentMock } from '../mocks/contentful.mocks';
import { FetchEventsQuery } from '../../src/autogenerated-gql/graphql';

jest.mock('../../src/utils/setup');
jest.mock('../../src/utils/assets-and-media');
jest.mock('../../src/utils/entries');

const getEventSquidex = (): EventItem => ({
  id: 'event-1',
  flatData: {
    googleId: '1jhm4181bs6ck0esegje4nf6ur',
    description: null,
    endDate: '2023-04-03T17:00:00Z',
    endDateTimeZone: 'America/Sao_Paulo',
    startDate: '2023-04-03T16:00:00Z',
    startDateTimeZone: 'America/Sao_Paulo',
    meetingLink: 'https://meet.google.com/idr-kixv-hhm',
    hideMeetingLink: true,
    eventLink: null,
    status: 'Confirmed',
    hidden: true,
    tags: ['googleMeet', 'science'],
    title: 'Amazing event!!!',
    notesPermanentlyUnavailable: null,
    notes: '<p>notes</p>',
    notesUpdatedAt: '2023-05-17T13:38:51.128Z',
    videoRecordingPermanentlyUnavailable: null,
    videoRecording: null,
    videoRecordingUpdatedAt: null,
    presentationPermanentlyUnavailable: null,
    presentation: null,
    presentationUpdatedAt: null,
    meetingMaterialsPermanentlyUnavailable: null,
    meetingMaterials: [
      {
        url: 'https://drive.google.com/drive/folders/id',
        title: 'Drive folder',
      },
      {
        url: 'https://slack.com/intl/pt-br/',
        title: 'Slack',
      },
    ],
    calendar: [
      {
        id: 'calendar-1',
      },
    ],
    thumbnail: [
      {
        id: '371b0102-7cf1-425f-bec5-8d03accaf91b',
        fileName: 'ASAP Network thumbnail.jpg',
        thumbnailUrl:
          'https://cloud.squidex.io/api/assets/crn-3046/371b0102-7cf1-425f-bec5-8d03accaf91b?width=100&mode=Max',
        mimeType: 'image/jpeg',
        fileType: 'jpg',
      },
    ],
    speakers: [
      {
        team: [
          {
            id: 'team-1',
          },
        ],
        user: [
          {
            __typename: 'Users',
            id: 'user-1',
          },
        ],
      },
      {
        team: null,
        user: [
          {
            __typename: 'ExternalAuthors',
            id: 'external-user-1',
          },
        ],
      },
    ],
  },
});

const getEventSquidexResponse = (): FetchEventsQuery => ({
  queryEventsContentsWithTotal: {
    total: 1,
    items: [getEventSquidex()],
  },
});

const baseUpdatePayload = {
  hidden: { 'en-US': true },
  hideMeetingLink: { 'en-US': true },
  meetingLink: { 'en-US': 'https://meet.google.com/idr-kixv-hhm' },
  meetingMaterials: {
    'en-US': [
      {
        title: 'Drive folder',
        url: 'https://drive.google.com/drive/folders/id',
      },
      { title: 'Slack', url: 'https://slack.com/intl/pt-br/' },
    ],
  },
  meetingMaterialsPermanentlyUnavailable: { 'en-US': null },
  notes: {
    'en-US': {
      content: [
        {
          content: [{ data: {}, marks: [], nodeType: 'text', value: 'notes' }],
          data: {},
          nodeType: 'paragraph',
        },
      ],
      data: {},
      nodeType: 'document',
    },
  },
  notesPermanentlyUnavailable: { 'en-US': null },
  notesUpdatedAt: { 'en-US': '2023-05-17T13:38:51.128Z' },
  presentation: { 'en-US': null },
  presentationPermanentlyUnavailable: { 'en-US': null },
  presentationUpdatedAt: { 'en-US': null },
  speakers: {
    'en-US': [
      { sys: { id: 'entry-id', linkType: 'Entry', type: 'Link' } },
      { sys: { id: 'entry-id', linkType: 'Entry', type: 'Link' } },
    ],
  },
  tags: { 'en-US': ['googleMeet', 'science'] },
  thumbnail: { 'en-US': undefined },
  videoRecording: { 'en-US': null },
  videoRecordingPermanentlyUnavailable: { 'en-US': null },
  videoRecordingUpdatedAt: { 'en-US': null },
};

const baseCreatePayload = {
  ...baseUpdatePayload,
  calendar: {
    'en-US': {
      sys: {
        id: 'calendar-1',
        linkType: 'Entry',
        type: 'Link',
      },
    },
  },
  description: { 'en-US': null },
  endDate: { 'en-US': '2023-04-03T17:00:00Z' },
  endDateTimeZone: { 'en-US': 'America/Sao_Paulo' },
  eventLink: { 'en-US': null },
  googleId: { 'en-US': '1jhm4181bs6ck0esegje4nf6ur' },
  startDate: { 'en-US': '2023-04-03T16:00:00Z' },
  startDateTimeZone: { 'en-US': 'America/Sao_Paulo' },
  status: { 'en-US': 'Confirmed' },
  title: { 'en-US': 'Amazing event!!!' },
};

describe('Migrate events', () => {
  let contentfulEnv: Environment;
  let squidexGraphqlClientMock: jest.Mocked<SquidexGraphqlClient>;

  const consoleLogRef = console.log;
  beforeEach(() => {
    console.log = jest.fn();
    contentfulEnv = getContentfulEnvironmentMock();
    squidexGraphqlClientMock = {
      request: jest.fn(),
    };

    (getSquidexAndContentfulClients as jest.Mock).mockResolvedValueOnce({
      contentfulEnvironment: contentfulEnv,
      squidexGraphqlClient: squidexGraphqlClientMock,
    });

    eventEntry.sys.id = 'event-1';
    jest.spyOn(contentfulEnv, 'getEntries').mockResolvedValueOnce({
      total: 1,
      items: [eventEntry],
      skip: 0,
      limit: 10,
      toPlainObject: jest.fn(),
      sys: { type: 'Array' },
    });

    when(contentfulEnv.getEntry)
      .calledWith('team-1')
      .mockResolvedValue(getEntry({}));

    when(contentfulEnv.getEntry)
      .calledWith('user-1')
      .mockResolvedValue(getEntry({}));

    when(contentfulEnv.getEntry)
      .calledWith('external-user-1')
      .mockResolvedValue(getEntry({}));

    jest.spyOn(contentfulEnv, 'createEntry').mockResolvedValue(getEntry({}));

    jest.spyOn(eventEntry, 'publish').mockResolvedValue(getEntry({}));
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  afterAll(() => {
    console.log = consoleLogRef;
  });

  it('calls clear contentful entries for events', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );

    await migrateEvents();

    const clearContentfulEntriesMock = clearContentfulEntries as jest.Mock;
    expect(clearContentfulEntriesMock).toHaveBeenCalled();
  });

  it('unpublishes and deletes previous speakers from existing Contentful event', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );
    const eventWithSpeakers = {
      ...eventEntry,
      fields: {
        ...eventEntry.fields,
        speakers: {
          'en-US': [
            {
              sys: { id: 'old-speaker', linkType: 'Entry', type: 'Link' },
            },
          ],
        },
      },
    };
    jest
      .spyOn(contentfulEnv, 'getEntries')
      .mockReset()
      .mockResolvedValueOnce({
        total: 1,
        items: [eventWithSpeakers],
        skip: 0,
        limit: 10,
        toPlainObject: jest.fn(),
        sys: { type: 'Array' },
      });

    const previousSpeakerMock = getEntry({});
    when(contentfulEnv.getEntry)
      .calledWith('old-speaker')
      .mockResolvedValueOnce(previousSpeakerMock);

    await migrateEvents();

    expect(previousSpeakerMock.unpublish).toHaveBeenCalled();
    expect(previousSpeakerMock.delete).toHaveBeenCalled();
  });

  it('outputs an error if it is not possible to unpublish and delete previous speakers from existing Contentful event', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );
    const eventWithSpeakers = {
      ...eventEntry,
      fields: {
        ...eventEntry.fields,
        speakers: {
          'en-US': [
            {
              sys: { id: 'old-speaker', linkType: 'Entry', type: 'Link' },
            },
          ],
        },
      },
    };
    jest
      .spyOn(contentfulEnv, 'getEntries')
      .mockReset()
      .mockResolvedValueOnce({
        total: 1,
        items: [eventWithSpeakers],
        skip: 0,
        limit: 10,
        toPlainObject: jest.fn(),
        sys: { type: 'Array' },
      });

    when(contentfulEnv.getEntry)
      .calledWith('old-speaker')
      .mockRejectedValueOnce(new Error());

    await migrateEvents();

    expect(console.log).toHaveBeenCalledWith(
      '\x1b[31m',
      '[ERROR] Error deleting old speaker',
    );
  });

  it('outputs an error when user or team is not found in contentful', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );
    jest
      .spyOn(contentfulEnv, 'getEntry')
      .mockRejectedValue(new Error('not-found'));

    await migrateEvents();

    expect(console.log).toHaveBeenCalledWith(
      '\x1b[31m',
      '[ERROR] Either user external-user-1 or team null do not exist in contentful. Please review event with id event-1',
    );
  });

  it('creates eventSpeakers entries when speakers format is as expected', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );

    const eventSpeakersMock = getEntry({});
    jest
      .spyOn(contentfulEnv, 'createEntry')
      .mockResolvedValue(eventSpeakersMock);

    await migrateEvents();

    expect(contentfulEnv.createEntry).toHaveBeenCalledTimes(2);
    expect(eventSpeakersMock.publish).toHaveBeenCalled();
  });

  it('creates eventSpeakers entries when speakers user is an empty array', async () => {
    const eventSquidexResponse = getEventSquidexResponse();
    eventSquidexResponse.queryEventsContentsWithTotal!.items![0]!.flatData!.speakers =
      [
        {
          team: [
            {
              id: 'team-1',
            },
          ],
          user: [],
        },
      ];
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      eventSquidexResponse,
    );

    const eventSpeakersMock = getEntry({});
    jest
      .spyOn(contentfulEnv, 'createEntry')
      .mockResolvedValue(eventSpeakersMock);

    await migrateEvents();

    expect(contentfulEnv.createEntry).toHaveBeenCalledTimes(1);
    expect(eventSpeakersMock.publish).toHaveBeenCalled();
  });

  it("does not create eventSpeakers entries if there isn't any", async () => {
    const eventWithoutSpeakers = getEventSquidexResponse();
    eventWithoutSpeakers.queryEventsContentsWithTotal!.items![0].flatData.speakers =
      null;
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      eventWithoutSpeakers,
    );
    jest
      .spyOn(contentfulEnv, 'getEntries')
      .mockReset()
      .mockImplementation(() =>
        Promise.resolve({
          total: 0,
          items: [],
          skip: 0,
          limit: 10,
          toPlainObject: jest.fn(),
          sys: { type: 'Array' },
        }),
      );
    await migrateEvents();

    expect(contentfulEnv.createEntry).not.toHaveBeenCalled();
    expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
      'events',
      'event-1',
      {
        fields: {
          ...baseCreatePayload,
          speakers: { 'en-US': null },
        },
      },
    );
  });

  it('updates existing Contentful event', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );
    const eventMock = getEntry({});

    when(contentfulEnv.getEntry)
      .calledWith('event-1')
      .mockResolvedValueOnce(eventMock);

    await migrateEvents();

    expect(eventMock.fields).toEqual(baseUpdatePayload);
    expect(eventMock.update).toHaveBeenCalled();
  });

  it('updates an event without thumbnail', async () => {
    const eventWithoutThumbnail = getEventSquidexResponse();
    eventWithoutThumbnail.queryEventsContentsWithTotal!.items![0].flatData.thumbnail =
      null;
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      eventWithoutThumbnail,
    );

    jest
      .spyOn(contentfulEnv, 'getEntries')
      .mockReset()
      .mockImplementation(() =>
        Promise.resolve({
          total: 0,
          items: [],
          skip: 0,
          limit: 10,
          toPlainObject: jest.fn(),
          sys: { type: 'Array' },
        }),
      );
    await migrateEvents();

    expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
      'events',
      'event-1',
      {
        fields: {
          ...baseCreatePayload,
          thumbnail: { 'en-US': null },
        },
      },
    );
  });

  it('handles empty meeting link', async () => {
    const eventWithEmptyMeetingLink = getEventSquidexResponse();
    eventWithEmptyMeetingLink.queryEventsContentsWithTotal!.items![0].flatData.meetingLink =
      '';
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      eventWithEmptyMeetingLink,
    );

    jest
      .spyOn(contentfulEnv, 'getEntries')
      .mockReset()
      .mockImplementation(() =>
        Promise.resolve({
          total: 0,
          items: [],
          skip: 0,
          limit: 10,
          toPlainObject: jest.fn(),
          sys: { type: 'Array' },
        }),
      );
    await migrateEvents();

    expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
      'events',
      'event-1',
      {
        fields: {
          ...baseCreatePayload,
          meetingLink: { 'en-US': null },
        },
      },
    );
  });

  it('creates a new Contentful event when it does not exist there yet', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );

    jest.spyOn(contentfulEnv, 'getEntry').mockResolvedValue(getEntry({}));
    jest.spyOn(contentfulEnv, 'createEntry').mockResolvedValue(getEntry({}));

    jest
      .spyOn(contentfulEnv, 'getEntries')
      .mockReset()
      .mockImplementation(() =>
        Promise.resolve({
          total: 0,
          items: [],
          skip: 0,
          limit: 10,
          toPlainObject: jest.fn(),
          sys: { type: 'Array' },
        }),
      );
    await migrateEvents();

    expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
      'events',
      'event-1',
      {
        fields: baseCreatePayload,
      },
    );
  });

  it('outputs a message if a calendar does not exists in Contentful', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getEventSquidexResponse(),
    );

    when(contentfulEnv.getEntry)
      .calledWith('calendar-1')
      .mockRejectedValueOnce(new Error('not-found'));

    jest
      .spyOn(contentfulEnv, 'getEntries')
      .mockReset()
      .mockImplementation(() =>
        Promise.resolve({
          total: 0,
          items: [],
          skip: 0,
          limit: 10,
          toPlainObject: jest.fn(),
          sys: { type: 'Array' },
        }),
      );
    await migrateEvents();

    expect(console.log).toHaveBeenCalledWith(
      '\x1b[31m',
      '[ERROR] Calendar calendar-1 does not exist in contentful. Event with id event-1 is going to be created without a calendar.',
    );
  });

  it('creates a calendar as null if it comes as null', async () => {
    const event = getEventSquidexResponse();
    event.queryEventsContentsWithTotal!.items![0].flatData.calendar = null;
    squidexGraphqlClientMock.request.mockResolvedValueOnce(event);

    jest
      .spyOn(contentfulEnv, 'getEntries')
      .mockReset()
      .mockImplementation(() =>
        Promise.resolve({
          total: 0,
          items: [],
          skip: 0,
          limit: 10,
          toPlainObject: jest.fn(),
          sys: { type: 'Array' },
        }),
      );
    await migrateEvents();

    expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
      'events',
      'event-1',
      {
        fields: {
          ...baseCreatePayload,
          calendar: { 'en-US': null },
        },
      },
    );
  });

  it('creates a calendar as null if it comes as empty array', async () => {
    const event = getEventSquidexResponse();
    event.queryEventsContentsWithTotal!.items![0].flatData.calendar = [];
    squidexGraphqlClientMock.request.mockResolvedValueOnce(event);

    jest
      .spyOn(contentfulEnv, 'getEntries')
      .mockReset()
      .mockImplementation(() =>
        Promise.resolve({
          total: 0,
          items: [],
          skip: 0,
          limit: 10,
          toPlainObject: jest.fn(),
          sys: { type: 'Array' },
        }),
      );
    await migrateEvents();

    expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
      'events',
      'event-1',
      {
        fields: {
          ...baseCreatePayload,
          calendar: { 'en-US': null },
        },
      },
    );
  });
});
