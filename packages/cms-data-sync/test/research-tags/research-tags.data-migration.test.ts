import { SquidexGraphqlClient, createUrlFactory } from '@asap-hub/squidex';
import { Environment } from 'contentful-management';
import { migrateResearchTags } from '../../src/research-tags/research-tags.data-migration';
import { getEntry, researchTagEntry } from '../fixtures';
import {
  clearContentfulEntries,
  publishContentfulEntries,
  getSquidexAndContentfulClients,
} from '../../src/utils';
import { getContentfulEnvironmentMock } from '../mocks/contentful.mocks';
import { FetchResearchTagsQuery } from '../../src/autogenerated-gql/graphql';

jest.mock('../../src/utils/setup');
jest.mock('../../src/utils/entries');

const getResearchTagsSquidex: (
  props: Record<string, unknown>,
) => FetchResearchTagsQuery['queryResearchTagsContentsWithTotal']['items'][number] = (
  props = {},
) => ({
  id: 'tag-1',
  created: '2023-03-15T00:00:00.0000Z',
  lastModified: '2023-03-15T00:00:00.0000Z',
  version: 10,
  status: 'PUBLISHED',
  flatData: {
    name: 'Test tag',
    types: ['Report', 'Proposal'],
    entities: ['Research Output'],
    category: 'Method',
    ...props,
  },
});

const getResearchTagsSquidexResponse: (
  props: Record<string, unknown>,
) => NonNullable<
  FetchResearchTagsQuery['queryResearchTagsContentsWithTotal']
> = (props) => ({
  queryResearchTagsContentsWithTotal: {
    total: 1,
    items: [getResearchTagsSquidex(props)],
  },
});

describe('Migrate research tags', () => {
  let contentfulEnv: Environment;
  let squidexGraphqlClientMock: jest.Mocked<SquidexGraphqlClient>;

  const consoleLogRef = console.log;

  beforeEach(() => {
    console.log = jest.fn();

    contentfulEnv = getContentfulEnvironmentMock();
    contentfulEnv.createEntryWithId.mockResolvedValue(researchTagEntry);
    squidexGraphqlClientMock = {
      request: jest.fn(),
    };

    (getSquidexAndContentfulClients as jest.Mock).mockResolvedValueOnce({
      contentfulEnvironment: contentfulEnv,
      squidexGraphqlClient: squidexGraphqlClientMock,
    });

    jest.spyOn(contentfulEnv, 'getEntries').mockResolvedValueOnce({
      total: 1,
      items: [researchTagEntry],
      skip: 0,
      limit: 10,
      toPlainObject: jest.fn(),
      sys: { type: 'Array' },
    });

    jest
      .spyOn(researchTagEntry, 'publish')
      .mockImplementationOnce(() => Promise.resolve(researchTagEntry));
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  afterAll(() => {
    console.log = consoleLogRef;
  });

  it('clears contentful discover entries', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getResearchTagsSquidexResponse(),
    );

    await migrateResearchTags();

    const clearContentfulEntriesMock = clearContentfulEntries as jest.Mock;
    expect(clearContentfulEntriesMock).toHaveBeenCalledTimes(1);
    expect(clearContentfulEntriesMock).toHaveBeenCalledWith(
      expect.anything(),
      'researchTags',
    );
  });

  it('fetches all pages of data from squidex', async () => {
    squidexGraphqlClientMock.request.mockResolvedValue({
      queryResearchTagsContentsWithTotal: {
        total: 200,
        items: Array(100).fill({ id: '1', flatData: { name: 'Test' } }),
      },
    });

    await migrateResearchTags();

    expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
      expect.anything(),
      { take: 100, skip: 0 },
    );
    expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
      expect.anything(),
      { take: 100, skip: 100 },
    );
  }, 100000);

  it('does not fail if no data in squidex', async () => {
    squidexGraphqlClientMock.request.mockResolvedValue({
      queryResearchTagsContentsWithTotal: null,
    });

    await migrateResearchTags();

    expect(contentfulEnv.createEntryWithId).not.toHaveBeenCalled();
  });

  it('creates contentful entries', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getResearchTagsSquidexResponse(),
    );

    await migrateResearchTags();

    expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
      'researchTags',
      'tag-1',
      {
        fields: {
          name: { 'en-US': 'Test tag' },
          types: { 'en-US': ['Report', 'Proposal'] },
          category: { 'en-US': 'Method' },
          entities: { 'en-US': ['Research Output'] },
        },
      },
    );
  });

  it('publishes contentful entries', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getResearchTagsSquidexResponse(),
    );
    const publishContentfulEntriesMock = publishContentfulEntries as jest.Mock;

    await migrateResearchTags();

    expect(publishContentfulEntriesMock).toHaveBeenCalledWith([
      researchTagEntry,
    ]);
  });
});
