import { SquidexGraphqlClient } from '@asap-hub/squidex';
import { Environment } from 'contentful-management';
import { migrateTeams } from '../../src/teams/teams.data-migration';
import { getEntry, teamEntry } from '../fixtures';
import {
  clearContentfulEntries,
  publishContentfulEntries,
  getSquidexAndContentfulClients,
} from '../../src/utils';
import { getContentfulEnvironmentMock } from '../mocks/contentful.mocks';
import { FetchTeamsQuery } from '../../src/autogenerated-gql/graphql';

jest.mock('../../src/utils/setup');
jest.mock('../../src/utils/entries');

const getTeamSquidexResponse: () => NonNullable<
  FetchTeamsQuery['queryTeamsContents']
>[number] = () => ({
  id: 'team-1',
  created: '2023-03-15T00:00:00.0000Z',
  lastModified: '2023-03-15T00:00:00.0000Z',
  version: 10,
  flatData: {
    displayName: 'Team ASAP',
    applicationNumber: '2023',
    projectTitle: 'Beautiful Title',
    projectSummary: null,
    inactiveSince: null,
    expertiseAndResourceTags: [],
    tools: [],
  },
});

const teamWithoutTools = getTeamSquidexResponse();
const squidexResponseWithoutTools: FetchTeamsQuery = {
  queryTeamsContents: [teamWithoutTools],
};

const tool = {
  name: 'Drive folder',
  url: 'http://www.google-drive.com/123',
  description: 'Where files are stored',
};
const teamWithTools = getTeamSquidexResponse();
teamWithTools.flatData.tools = [tool];
const squidexResponseWithTools: FetchTeamsQuery = {
  queryTeamsContents: [teamWithTools],
};

describe('Migrate teams', () => {
  let contenfulEnv: Environment;
  let squidexGraphqlClientMock: jest.Mocked<SquidexGraphqlClient>;

  const consoleLogRef = console.log;

  beforeEach(() => {
    console.log = jest.fn();

    contenfulEnv = getContentfulEnvironmentMock();
    squidexGraphqlClientMock = {
      request: jest.fn(),
    };

    (getSquidexAndContentfulClients as jest.Mock).mockResolvedValueOnce({
      contentfulEnvironment: contenfulEnv,
      squidexGraphqlClient: squidexGraphqlClientMock,
    });

    jest.spyOn(contenfulEnv, 'getEntries').mockResolvedValueOnce({
      total: 1,
      items: [teamEntry],
      skip: 0,
      limit: 10,
      toPlainObject: jest.fn(),
      sys: { type: 'Array' },
    });

    jest
      .spyOn(teamEntry, 'publish')
      .mockImplementationOnce(() => Promise.resolve(teamEntry));
  });

  afterEach(() => {
    jest.resetModules();
    jest.clearAllMocks();
  });

  afterAll(() => {
    console.log = consoleLogRef;
  });

  it('clears contentful teams and externalTools entries', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      squidexResponseWithoutTools,
    );

    await migrateTeams();

    const clearContentfulEntriesMock = clearContentfulEntries as jest.Mock;
    expect(clearContentfulEntriesMock).toHaveBeenCalledTimes(2);
    expect(clearContentfulEntriesMock).toHaveBeenNthCalledWith(
      1,
      expect.anything(),
      'externalTools',
    );
    expect(clearContentfulEntriesMock).toHaveBeenNthCalledWith(
      2,
      expect.anything(),
      'teams',
    );
  });

  describe('creates contentful entries', () => {
    it('for a team that does not contain tools', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexResponseWithoutTools,
      );

      await migrateTeams();

      expect(contenfulEnv.createEntryWithId).toHaveBeenCalledWith(
        'teams',
        'team-1',
        {
          fields: {
            displayName: { 'en-US': 'Team ASAP' },
            applicationNumber: { 'en-US': '2023' },
            expertiseAndResourceTags: { 'en-US': [] },
            inactiveSince: { 'en-US': null },
            projectSummary: { 'en-US': null },
            projectTitle: { 'en-US': 'Beautiful Title' },
            tools: { 'en-US': [] },
          },
        },
      );
    });

    it('for a team that contains tools', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexResponseWithTools,
      );

      const toolMock = getEntry({});
      toolMock.publish = jest.fn().mockResolvedValueOnce(getEntry({}));
      contenfulEnv.createEntry = jest.fn().mockResolvedValueOnce(toolMock);

      await migrateTeams();

      expect(contenfulEnv.createEntry).toHaveBeenCalledWith('externalTools', {
        fields: {
          description: { 'en-US': tool.description },
          name: { 'en-US': tool.name },
          url: { 'en-US': tool.url },
        },
      });
      expect(toolMock.publish).toBeCalled();

      expect(contenfulEnv.createEntryWithId).toHaveBeenCalledWith(
        'teams',
        'team-1',
        {
          fields: {
            displayName: { 'en-US': 'Team ASAP' },
            applicationNumber: { 'en-US': '2023' },
            expertiseAndResourceTags: { 'en-US': [] },
            inactiveSince: { 'en-US': null },
            projectSummary: { 'en-US': null },
            projectTitle: { 'en-US': 'Beautiful Title' },
            tools: {
              'en-US': [
                {
                  sys: {
                    id: 'entry-id',
                    linkType: 'Entry',
                    type: 'Link',
                  },
                },
              ],
            },
          },
        },
      );
    });

    it('for a team that contains tools with empty description', async () => {
      const toolWithEmptyDescription = {
        name: 'Drive folder',
        description: '',
        url: 'http://www.google-drive.com/123',
      };
      const teamWithToolWithEmptyDescription = getTeamSquidexResponse();
      teamWithToolWithEmptyDescription.flatData.tools = [
        toolWithEmptyDescription,
      ];

      squidexGraphqlClientMock.request.mockResolvedValueOnce({
        queryTeamsContents: [teamWithToolWithEmptyDescription],
      });

      const toolMock = getEntry({});
      toolMock.publish = jest.fn().mockResolvedValueOnce(getEntry({}));
      contenfulEnv.createEntry = jest.fn().mockResolvedValueOnce(toolMock);

      await migrateTeams();

      expect(contenfulEnv.createEntry).toHaveBeenCalledWith('externalTools', {
        fields: {
          name: { 'en-US': toolWithEmptyDescription.name },
          url: { 'en-US': toolWithEmptyDescription.url },
        },
      });
      expect(toolMock.publish).toBeCalled();

      expect(contenfulEnv.createEntryWithId).toHaveBeenCalledWith(
        'teams',
        'team-1',
        {
          fields: {
            displayName: { 'en-US': 'Team ASAP' },
            applicationNumber: { 'en-US': '2023' },
            expertiseAndResourceTags: { 'en-US': [] },
            inactiveSince: { 'en-US': null },
            projectSummary: { 'en-US': null },
            projectTitle: { 'en-US': 'Beautiful Title' },
            tools: {
              'en-US': [
                {
                  sys: {
                    id: 'entry-id',
                    linkType: 'Entry',
                    type: 'Link',
                  },
                },
              ],
            },
          },
        },
      );
    });
  });

  it('outputs an error message when trying to input a tool with invalid link', async () => {
    const tool = {
      name: 'Invalid link',
      description: 'It contains a not valid url',
      url: '123',
    };
    const teamWithInvalidURLTool = getTeamSquidexResponse();
    teamWithInvalidURLTool.id = 'team-invalid-url-tool';
    teamWithInvalidURLTool.flatData.tools = [tool];

    squidexGraphqlClientMock.request.mockResolvedValueOnce({
      queryTeamsContents: [teamWithInvalidURLTool],
    });

    await migrateTeams();

    expect(console.log).toHaveBeenCalledWith(
      '\x1b[31m',
      '[ERROR] Invalid tool URL linked to team with id: team-invalid-url-tool',
    );
  });

  it('still creates the team even if there is a tool with invalid link', async () => {
    const tool = {
      name: 'Invalid link',
      description: 'It contains a not valid url',
      url: '123',
    };
    const teamWithInvalidURLTool = getTeamSquidexResponse();
    teamWithInvalidURLTool.id = 'team-invalid-url-tool';
    teamWithInvalidURLTool.flatData.tools = [tool];

    squidexGraphqlClientMock.request.mockResolvedValueOnce({
      queryTeamsContents: [teamWithInvalidURLTool],
    });

    await migrateTeams();

    expect(contenfulEnv.createEntryWithId).toHaveBeenCalledWith(
      'teams',
      'team-invalid-url-tool',
      {
        fields: {
          displayName: { 'en-US': 'Team ASAP' },
          applicationNumber: { 'en-US': '2023' },
          expertiseAndResourceTags: { 'en-US': [] },
          inactiveSince: { 'en-US': null },
          projectSummary: { 'en-US': null },
          projectTitle: { 'en-US': 'Beautiful Title' },
          tools: { 'en-US': [] },
        },
      },
    );
  });

  it('does not fail if squidex does not return anything', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce({});
    const publishContentfulEntriesMock = publishContentfulEntries as jest.Mock;

    await migrateTeams();

    expect(contenfulEnv.createEntryWithId).not.toHaveBeenCalled();
    expect(publishContentfulEntriesMock).toHaveBeenCalled();
  });

  it('publish contentful entries', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      squidexResponseWithoutTools,
    );
    const publishContentfulEntriesMock = publishContentfulEntries as jest.Mock;

    await migrateTeams();

    expect(publishContentfulEntriesMock).toHaveBeenCalled();
  });
});
