import { SquidexGraphqlClient } from '@asap-hub/squidex';
import { Environment } from 'contentful-management';
import { migrateTeams } from '../../src/teams/teams.data-migration';
import { getEntry, teamEntry } from '../fixtures';
import {
  clearContentfulEntries,
  createExternalTool,
  getSquidexAndContentfulClients,
} from '../../src/utils';
import { getContentfulEnvironmentMock } from '../mocks/contentful.mocks';
import { FetchTeamsQuery } from '../../src/autogenerated-gql/graphql';

jest.mock('../../src/utils/setup');
jest.mock('../../src/utils/entries');
jest.mock('../../src/utils/external-tools');

const getTeamSquidexResponse: () => NonNullable<
  FetchTeamsQuery['queryTeamsContents']
>[number] = () => ({
  id: 'team-1',
  created: '2023-03-15T00:00:00.0000Z',
  lastModified: '2023-03-15T00:00:00.0000Z',
  version: 10,
  flatData: {
    displayName: 'Team ASAP',
    applicationNumber: '2023',
    projectTitle: 'Beautiful Title',
    projectSummary: null,
    inactiveSince: null,
    expertiseAndResourceTags: [],
    tools: [],
  },
});

const teamWithoutTools = getTeamSquidexResponse();
const squidexResponseWithoutTools: FetchTeamsQuery = {
  queryTeamsContents: [teamWithoutTools],
};

const teamWithTools = getTeamSquidexResponse();
teamWithTools.flatData.tools = [
  {
    name: 'Drive folder',
    url: 'http://www.google-drive.com/123',
    description: 'Where files are stored',
  },
];
const squidexResponseWithTools: FetchTeamsQuery = {
  queryTeamsContents: [teamWithTools],
};

describe('Migrate teams', () => {
  let contenfulEnv: Environment;
  let squidexGraphqlClientMock: jest.Mocked<SquidexGraphqlClient>;

  const consoleLogRef = console.log;

  beforeEach(() => {
    console.log = jest.fn();

    contenfulEnv = getContentfulEnvironmentMock();
    squidexGraphqlClientMock = {
      request: jest.fn(),
    };

    (getSquidexAndContentfulClients as jest.Mock).mockResolvedValueOnce({
      contentfulEnvironment: contenfulEnv,
      squidexGraphqlClient: squidexGraphqlClientMock,
    });

    jest.spyOn(contenfulEnv, 'getEntries').mockResolvedValueOnce({
      total: 1,
      items: [teamEntry],
      skip: 0,
      limit: 10,
      toPlainObject: jest.fn(),
      sys: { type: 'Array' },
    });

    jest
      .spyOn(teamEntry, 'publish')
      .mockImplementationOnce(() => Promise.resolve(teamEntry));
  });

  afterEach(() => {
    jest.resetModules();
    jest.clearAllMocks();
  });

  afterAll(() => {
    console.log = consoleLogRef;
  });

  it('clears contentful teams and externalTools entries', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      squidexResponseWithoutTools,
    );

    await migrateTeams();
    const clearContentfulEntriesMock = clearContentfulEntries as jest.Mock;

    expect(clearContentfulEntriesMock).toHaveBeenCalledTimes(2);

    expect(clearContentfulEntriesMock).toHaveBeenNthCalledWith(
      1,
      expect.anything(),
      'externalTools',
    );

    expect(clearContentfulEntriesMock).toHaveBeenNthCalledWith(
      2,
      expect.anything(),
      'teams',
    );
  });

  describe('creates contentful entries', () => {
    it('for a team that does not contain tools', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexResponseWithoutTools,
      );

      await migrateTeams();

      expect(contenfulEnv.createEntryWithId).toHaveBeenCalledWith(
        'teams',
        'team-1',
        {
          fields: {
            displayName: { 'en-US': 'Team ASAP' },
            applicationNumber: { 'en-US': 2023 },
            expertiseAndResourceTags: { 'en-US': undefined },
            inactiveSince: { 'en-US': undefined },
            projectSummary: { 'en-US': undefined },
            projectTitle: { 'en-US': 'Beautiful Title' },
            tools: { 'en-US': [] },
          },
        },
      );
    });

    it.only('for a team that contains tools', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        squidexResponseWithTools,
      );

      // const createExternalToolMock = createExternalTool as jest.Mock;
      // const entry = getEntry({});
      // createExternalToolMock.mockResolvedValue(entry);

      await migrateTeams();

      expect(contenfulEnv.createEntryWithId).not.toHaveBeenCalled();

      // expect(contenfulEnv.createEntryWithId).toHaveBeenCalledWith(
      //   'news',
      //   'news-1',
      //   {
      //     fields: {
      //       frequency: { 'en-US': 'News Articles' },
      //       link: { 'en-US': undefined },
      //       linkText: { 'en-US': undefined },
      //       shortText: { 'en-US': undefined },
      //       text: { 'en-US': null },
      //       thumbnail: { 'en-US': contenfulUploadAssetFields['file']['en-US'] },
      //       title: { 'en-US': 'news' },
      //       publishDate: { 'en-US': undefined },
      //     },
      //   },
      // );
    });
  });

  // describe('error handling', () => {
  //   it('outputs a message when converting from html to contenful format gives an error', async () => {
  //     squidexGraphqlClientMock.request.mockResolvedValueOnce(
  //       squidexResponseWithText,
  //     );

  //     const convertHtmlToContentfulFormatMock =
  //       convertHtmlToContentfulFormat as jest.Mock;
  //     convertHtmlToContentfulFormatMock.mockImplementationOnce(() => {
  //       throw new Error();
  //     });

  //     jest
  //       .spyOn(contenfulEnv, 'createEntryWithId')
  //       .mockResolvedValueOnce(newsEntry);

  //     const publishContentfulEntriesMock =
  //       publishContentfulEntries as jest.Mock;

  //     await migrateNews();

  //     expect(console.log).toHaveBeenCalledWith(
  //       '\x1b[31m',
  //       '[ERROR] There is a problem converting rich text from entry news-1',
  //     );

  //     expect(contenfulEnv.createEntryWithId).toHaveBeenCalledWith(
  //       'news',
  //       'news-1',
  //       {
  //         fields: {
  //           frequency: { 'en-US': 'News Articles' },
  //           link: { 'en-US': undefined },
  //           linkText: { 'en-US': undefined },
  //           shortText: { 'en-US': undefined },
  //           text: { 'en-US': null },
  //           thumbnail: { 'en-US': null },
  //           title: { 'en-US': 'news' },
  //           publishDate: { 'en-US': undefined },
  //         },
  //       },
  //     );

  //     expect(publishContentfulEntriesMock).toHaveBeenCalledWith([newsEntry]);
  //   });

  //   it('tries to create the entry again if it fails the first time', async () => {
  //     squidexGraphqlClientMock.request.mockResolvedValueOnce(
  //       squidexResponseWithText,
  //     );

  //     const publishContentfulEntriesMock =
  //       publishContentfulEntries as jest.Mock;

  //     jest
  //       .spyOn(contenfulEnv, 'createEntryWithId')
  //       .mockImplementationOnce(() => {
  //         throw new Error();
  //       })
  //       .mockImplementationOnce(() => {
  //         return Promise.resolve(newsEntry);
  //       });

  //     await migrateNews();

  //     expect(console.log).toHaveBeenCalledWith(
  //       '\x1b[31m',
  //       '[ERROR] Entry with ID news-1 was uploaded with fallback data',
  //     );
  //     expect(contenfulEnv.createEntryWithId).toHaveBeenCalledTimes(2);
  //     expect(publishContentfulEntriesMock).toHaveBeenCalledWith([newsEntry]);
  //   });

  //   it('outputs a message create entry fails for the second time', async () => {
  //     squidexGraphqlClientMock.request.mockResolvedValueOnce(
  //       squidexResponseWithText,
  //     );

  //     const publishContentfulEntriesMock =
  //       publishContentfulEntries as jest.Mock;

  //     jest.spyOn(contenfulEnv, 'createEntryWithId').mockImplementation(() => {
  //       throw new Error();
  //     });

  //     await migrateNews();

  //     expect(contenfulEnv.createEntryWithId).toHaveBeenCalledTimes(2);
  //     expect(console.log).toHaveBeenCalledWith(
  //       '\x1b[31m',
  //       '[ERROR] There is a problem creating entry news-1',
  //     );

  //     expect(publishContentfulEntriesMock).toHaveBeenCalledWith([]);
  //   });

  //   it('does not fail if squidex does not return anything', async () => {
  //     squidexGraphqlClientMock.request.mockResolvedValueOnce({});
  //     const publishContentfulEntriesMock =
  //       publishContentfulEntries as jest.Mock;

  //     await migrateNews();

  //     expect(contenfulEnv.createEntryWithId).not.toHaveBeenCalled();
  //     expect(publishContentfulEntriesMock).toHaveBeenCalled();
  //   });
  // });

  // it('publish contentful entries', async () => {
  //   squidexGraphqlClientMock.request.mockResolvedValueOnce(
  //     squidexResponseWithTitleOnly,
  //   );
  //   const publishContentfulEntriesMock = publishContentfulEntries as jest.Mock;

  //   await migrateNews();

  //   expect(publishContentfulEntriesMock).toHaveBeenCalled();
  // });
});
