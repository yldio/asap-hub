import { SquidexGraphqlClient, createUrlFactory } from '@asap-hub/squidex';
import { Environment } from 'contentful-management';
import { migrateUsers } from '../../src/users/users.data-migration';
import {
  getEntry,
  userEntry,
  teamMembershipEntry,
  contenfulAsset,
} from '../fixtures';
import {
  clearContentfulEntries,
  createAsset,
  createAssetUrl,
  publishContentfulEntries,
  getSquidexAndContentfulClients,
} from '../../src/utils';
import { getContentfulEnvironmentMock } from '../mocks/contentful.mocks';
import { FetchUsersQuery } from '../../src/autogenerated-gql/graphql';

const mockCreateAssetUrl = createUrlFactory({
  appName: 'test',
  baseUrl: 'https://test.squidex.io',
});

jest.mock('../../src/utils/setup');
jest.mock('../../src/utils/assets');
jest.mock('../../src/utils/entries');

createAssetUrl.mockImplementation(mockCreateAssetUrl);

const getUserSquidex: (
  props: Record<string, unknown>,
) => FetchUsersQuery['queryUsersContentsWithTotal']['items'][number] = (
  props = {},
) => ({
  id: 'user-1',
  created: '2023-03-15T00:00:00.0000Z',
  lastModified: '2023-03-15T00:00:00.0000Z',
  version: 10,
  flatData: {
    firstName: 'Test',
    lastName: 'User',
    email: 'test@example.com',
    ...props,
  },
});

const getUserSquidexResponse: (
  props: Record<string, unknown>,
) => NonNullable<FetchUsersQuery['queryUsersContentsWithTotal']> = (props) => ({
  queryUsersContentsWithTotal: {
    total: 1,
    items: [getUserSquidex(props)],
  },
});

describe('Migrate users', () => {
  let contentfulEnv: Environment;
  let squidexGraphqlClientMock: jest.Mocked<SquidexGraphqlClient>;

  const consoleLogRef = console.log;

  beforeEach(() => {
    console.log = jest.fn();

    contentfulEnv = getContentfulEnvironmentMock();
    contentfulEnv.createEntryWithId.mockResolvedValue(userEntry);
    squidexGraphqlClientMock = {
      request: jest.fn(),
    };

    (getSquidexAndContentfulClients as jest.Mock).mockResolvedValueOnce({
      contentfulEnvironment: contentfulEnv,
      squidexGraphqlClient: squidexGraphqlClientMock,
    });

    jest.spyOn(contentfulEnv, 'getEntries').mockResolvedValueOnce({
      total: 1,
      items: [userEntry],
      skip: 0,
      limit: 10,
      toPlainObject: jest.fn(),
      sys: { type: 'Array' },
    });

    jest
      .spyOn(userEntry, 'publish')
      .mockImplementationOnce(() => Promise.resolve(userEntry));
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  afterAll(() => {
    console.log = consoleLogRef;
  });

  it('clears contentful users and teamMemberships entries', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getUserSquidexResponse(),
    );

    await migrateUsers();

    const clearContentfulEntriesMock = clearContentfulEntries as jest.Mock;
    expect(clearContentfulEntriesMock).toHaveBeenCalledTimes(2);
    expect(clearContentfulEntriesMock).toHaveBeenNthCalledWith(
      1,
      expect.anything(),
      'teamMembership',
      expect.anything(),
    );
    expect(clearContentfulEntriesMock).toHaveBeenNthCalledWith(
      2,
      expect.anything(),
      'users',
      expect.anything(),
    );
  });

  it('fetches all pages of data from squidex', async () => {
    squidexGraphqlClientMock.request.mockResolvedValue({
      queryUsersContentsWithTotal: {
        total: 200,
        items: Array(100).fill(getUserSquidex()),
      },
    });

    await migrateUsers();

    expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
      expect.anything(),
      { take: 100, skip: 0 },
    );
    expect(squidexGraphqlClientMock.request).toHaveBeenCalledWith(
      expect.anything(),
      { take: 100, skip: 100 },
    );
  }, 100000);

  it('does not fail if no data in squidex', async () => {
    squidexGraphqlClientMock.request.mockResolvedValue({
      queryUsersContentsWithTotal: null,
    });

    await migrateUsers();

    expect(contentfulEnv.createEntryWithId).not.toHaveBeenCalled();
  });

  describe('creates contentful entries', () => {
    it('for a user', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getUserSquidexResponse(),
      );

      await migrateUsers();

      expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
        'users',
        'user-1',
        {
          fields: {
            createdDate: { 'en-US': '2023-03-15T00:00:00.0000Z' },
            firstName: { 'en-US': 'Test' },
            lastName: { 'en-US': 'User' },
            email: { 'en-US': 'test@example.com' },
            orcid: { 'en-US': null },
            orcidLastSyncDate: { 'en-US': null },
            orcidLastModifiedDate: { 'en-US': null },
            contactEmail: { 'en-US': null },
            questions: { 'en-US': null },
            connections: { 'en-US': null },
            labs: { 'en-US': null },
            teams: { 'en-US': [] },
            avatar: { 'en-US': undefined },
          },
        },
      );
    });

    it('for a user with empty orcid or contactEmail fields', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getUserSquidexResponse({
          orcid: '',
          contactEmail: '',
        }),
      );

      await migrateUsers();

      expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
        'users',
        'user-1',
        {
          fields: expect.objectContaining({
            orcid: { 'en-US': null },
            contactEmail: { 'en-US': null },
          }),
        },
      );
    });

    it('for a user with social profiles', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getUserSquidexResponse({
          social: [
            {
              twitter: '@asap',
              github: 'asap',
            },
          ],
        }),
      );

      await migrateUsers();

      expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
        'users',
        'user-1',
        {
          fields: expect.objectContaining({
            twitter: { 'en-US': '@asap' },
            github: { 'en-US': 'asap' },
          }),
        },
      );
    });

    it('for a user with associated labs', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getUserSquidexResponse({
          labs: [{ id: 'lab-1', name: 'Test' }],
        }),
      );

      await migrateUsers();

      expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
        'users',
        'user-1',
        {
          fields: expect.objectContaining({
            labs: {
              'en-US': [
                { sys: { type: 'Link', linkType: 'Entry', id: 'lab-1' } },
              ],
            },
          }),
        },
      );
    });

    it('for a user with connection codes', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getUserSquidexResponse({
          connections: [{ code: 'abc' }],
        }),
      );

      await migrateUsers();

      expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
        'users',
        'user-1',
        {
          fields: expect.objectContaining({
            connections: { 'en-US': ['abc'] },
          }),
        },
      );
    });

    it('for a user with open questions', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getUserSquidexResponse({
          questions: [{ question: 'What is a duck?' }],
        }),
      );

      await migrateUsers();

      expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
        'users',
        'user-1',
        {
          fields: expect.objectContaining({
            questions: { 'en-US': ['What is a duck?'] },
          }),
        },
      );
    });

    it('for a user with teams', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getUserSquidexResponse({
          teams: [
            {
              role: 'Project Manager',
              inactiveSinceDate: '2021-12-23T12:00:00.000Z',
              id: [{ id: 'team-1' }],
            },
          ],
        }),
      );

      contentfulEnv.createEntry.mockResolvedValue(teamMembershipEntry);

      await migrateUsers();

      expect(contentfulEnv.createEntry).toHaveBeenCalledWith('teamMembership', {
        fields: {
          role: { 'en-US': 'Project Manager' },
          inactiveSinceDate: { 'en-US': '2021-12-23T12:00:00.000Z' },
          team: {
            'en-US': {
              sys: { type: 'Link', linkType: 'Entry', id: 'team-1' },
            },
          },
        },
      });

      expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
        'users',
        'user-1',
        {
          fields: expect.objectContaining({
            teams: {
              'en-US': [
                {
                  sys: {
                    type: 'Link',
                    linkType: 'Entry',
                    id: teamMembershipEntry.sys.id,
                  },
                },
              ],
            },
          }),
        },
      );
    });

    it('for a user with incomplete teams', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getUserSquidexResponse({
          teams: [
            {
              role: 'Project Manager',
              inactiveSinceDate: '2021-12-23T12:00:00.000Z',
              id: null,
            },
          ],
        }),
      );

      contentfulEnv.createEntry.mockResolvedValue(teamMembershipEntry);

      await migrateUsers();

      expect(contentfulEnv.createEntry).not.toHaveBeenCalled();

      expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
        'users',
        'user-1',
        {
          fields: expect.objectContaining({
            teams: {
              'en-US': [],
            },
          }),
        },
      );
    });

    it('for a user with an avatar', async () => {
      squidexGraphqlClientMock.request.mockResolvedValueOnce(
        getUserSquidexResponse({
          avatar: [
            {
              id: 'asset-1',
              fileName: 'avatar.jpg',
              mimeType: 'image/jpeg',
              fileType: 'jpeg',
            },
          ],
        }),
      );

      const createAssetMock = createAsset as jest.Mock;
      createAssetMock.mockResolvedValueOnce({
        sys: {
          type: 'Link',
          linkType: 'Asset',
          id: 'contentful-asset-id',
        },
      });

      await migrateUsers();

      expect(createAssetMock).toHaveBeenCalledWith(
        expect.anything(),
        [
          {
            fileName: 'avatar.jpg',
            fileType: 'jpeg',
            id: 'asset-1',
            mimeType: 'image/jpeg',
            thumbnailUrl: 'https://test.squidex.io/api/assets/test/asset-1',
          },
        ],
        expect.anything(),
      );

      expect(contentfulEnv.createEntryWithId).toHaveBeenCalledWith(
        'users',
        'user-1',
        {
          fields: expect.objectContaining({
            avatar: {
              'en-US': {
                sys: {
                  type: 'Link',
                  linkType: 'Asset',
                  id: 'contentful-asset-id',
                },
              },
            },
          }),
        },
      );
    });
  });

  it('publishes contentful entries', async () => {
    squidexGraphqlClientMock.request.mockResolvedValueOnce(
      getUserSquidexResponse(),
    );
    const publishContentfulEntriesMock = publishContentfulEntries as jest.Mock;

    await migrateUsers();

    expect(publishContentfulEntriesMock).toHaveBeenCalledWith(
      [userEntry],
      expect.anything(),
    );
  });
});
