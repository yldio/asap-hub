import { Entry } from 'contentful-management';
import { Document, Node } from '@contentful/rich-text-types';
import { documentToHtmlString } from '@contentful/rich-text-html-renderer';
import { Asset, Sys } from './crn/autogenerated-gql/graphql';

type InlineEntry = { sys: Pick<Sys, 'id'>; url: string };

export type RichTextFromQuery = {
  json: Document;
  links: {
    entries: {
      inline: InlineEntry[];
    };
    assets: {
      block: Array<
        Pick<
          Asset,
          | 'url'
          | 'description'
          | 'contentType'
          | 'width'
          | 'height'
          | 'description'
        > & { sys: { id: string } }
      >;
    };
  };
};

type AssetById = {
  [assetId: string]: Pick<
    Asset,
    'url' | 'description' | 'contentType' | 'width' | 'height' | 'description'
  >;
};

type EntryById = {
  [entryId: string]: { url: string };
};

export const parseRichText = (rtf: RichTextFromQuery) => {
  const assetById: AssetById = rtf.links.assets.block?.reduce(
    (assetInfoById: AssetById, asset) => ({
      ...assetInfoById,
      [asset.sys.id]: {
        ...asset,
      },
    }),
    {},
  );
  const entryById: EntryById = rtf.links.entries.inline?.reduce(
    (entryInfoById: EntryById, entry: InlineEntry) => ({
      ...entryInfoById,
      [entry.sys.id]: {
        url: entry?.url,
      },
    }),
    {},
  );
  const options = {
    renderNode: {
      'embedded-entry-inline': (node: Node) => {
        const entryId = node.data.target.sys.id as string;

        if (entryById && entryById[entryId]) {
          const { url } = entryById[entryId];
          return `<iframe src="${url}"/>`;
        }
        throw new Error(
          `Entry with id ${entryId} does not exist in contentful`,
        );
      },
      'embedded-asset-block': (node: Node) => {
        const assetId = node.data.target.sys.id as string;

        if (assetId && assetById[assetId]) {
          const { url, description, contentType, width, height } =
            assetById[assetId];
          const dimensions =
            width && height ? ` width="${width}" height="${height}"` : '';

          switch (contentType) {
            case 'application/pdf':
              return `<iframe src="${url}"${dimensions}>`;

            case 'video/mp4':
              return `<iframe src="${url}"${dimensions} allowFullScreen>`;

            default:
              return `<img src="${url}"${dimensions} alt=${
                description || ''
              }/>`;
          }
        }
        throw new Error(
          `Asset with id ${assetId} does not exist in contentful`,
        );
      },
    },
  };
  return documentToHtmlString(rtf?.json, options);
};

export const addLocaleToFields = (payload: Record<string, unknown>) =>
  Object.entries(payload).reduce(
    (acc, [key, value]) => ({
      ...acc,
      [key]: { 'en-US': value },
    }),
    {},
  );

export const updateEntryFields = (
  entry: Entry,
  fields: Record<string, unknown>,
) => {
  const updatedEntry = { ...entry };
  Object.entries(fields).forEach(([fieldName, fieldValue]) => {
    updatedEntry.fields[fieldName] = { 'en-US': fieldValue };
  });
  return updatedEntry;
};

export const patchAndPublish = async (
  entry: Entry,
  fields: Record<string, unknown>,
): Promise<Entry> => {
  const patch: Parameters<Entry['patch']>[0] = Object.entries(fields).map(
    ([key, value]) => ({
      op: Object.prototype.hasOwnProperty.call(entry.fields, key)
        ? 'replace'
        : 'add',
      path: `/fields/${key}`,
      value: {
        'en-US': value,
      },
    }),
  );
  const result = await entry.patch(patch);
  return result.publish();
};
