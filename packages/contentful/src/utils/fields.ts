import retry from 'async-retry';
import { Entry as CDAEntry, EntrySkeletonType, FieldsType } from 'contentful';
import { Entry } from 'contentful-management';
import { Document, Node } from '@contentful/rich-text-types';
import { documentToHtmlString } from '@contentful/rich-text-html-renderer';
import { Document, Node } from '@contentful/rich-text-types';
import { Entry } from 'contentful-management';
import { Asset, Sys } from '../crn/autogenerated-gql/graphql';

type InlineEntry = { sys: Pick<Sys, 'id'>; url: string };

export type RichTextFromQuery = {
  json: Document;
  links: {
    entries: {
      inline: InlineEntry[];
    };
    assets: {
      block: Array<
        Pick<
          Asset,
          | 'url'
          | 'description'
          | 'contentType'
          | 'width'
          | 'height'
          | 'description'
        > & { sys: { id: string } }
      >;
    };
  };
};

type AssetById = {
  [assetId: string]: Pick<
    Asset,
    'url' | 'description' | 'contentType' | 'width' | 'height' | 'description'
  >;
};

type EntryById = {
  [entryId: string]: { url: string };
};

export const parseRichText = (rtf: RichTextFromQuery) => {
  const assetById: AssetById = rtf.links.assets.block?.reduce(
    (assetInfoById: AssetById, asset) => ({
      ...assetInfoById,
      [asset.sys.id]: {
        ...asset,
      },
    }),
    {},
  );
  const entryById: EntryById = rtf.links.entries.inline?.reduce(
    (entryInfoById: EntryById, entry: InlineEntry) => ({
      ...entryInfoById,
      [entry.sys.id]: {
        url: entry?.url,
      },
    }),
    {},
  );
  const options = {
    renderNode: {
      'embedded-entry-inline': (node: Node) => {
        const entryId = node.data.target.sys.id as string;

        if (entryById && entryById[entryId]) {
          const { url } = entryById[entryId];
          return `<iframe src="${url}"/>`;
        }
        throw new Error(
          `Entry with id ${entryId} does not exist in contentful`,
        );
      },
      'embedded-asset-block': (node: Node) => {
        const assetId = node.data.target.sys.id as string;

        if (assetId && assetById[assetId]) {
          const { url, description, contentType, width, height } =
            assetById[assetId];
          const dimensions =
            width && height ? ` width="${width}" height="${height}"` : '';

          switch (contentType) {
            case 'application/pdf':
              return `<iframe src="${url}"${dimensions}>`;

            case 'video/mp4':
              return `<iframe src="${url}"${dimensions} allowFullScreen>`;

            default:
              return `<img src="${url}"${dimensions} alt=${
                description || ''
              }/>`;
          }
        }
        throw new Error(
          `Asset with id ${assetId} does not exist in contentful`,
        );
      },
    },
  };
  return documentToHtmlString(rtf?.json, options);
};

export const addLocaleToFields = (payload: Record<string, unknown>) =>
  Object.entries(payload).reduce(
    (acc, [key, value]) => ({
      ...acc,
      [key]: { 'en-US': value },
    }),
    {},
  );

export const updateEntryFields = (
  entry: Entry,
  fields: Record<string, unknown>,
) => {
  const updatedEntry = { ...entry };
  Object.entries(fields).forEach(([fieldName, fieldValue]) => {
    updatedEntry.fields[fieldName] = { 'en-US': fieldValue };
  });
  return updatedEntry;
};

export const patchAndPublish = async (
  entry: Entry,
  fields: Record<string, unknown>,
): Promise<Entry> => {
  const patch: Parameters<Entry['patch']>[0] = Object.entries(fields).map(
    ([key, value]) => ({
      op: Object.prototype.hasOwnProperty.call(entry.fields, key)
        ? 'replace'
        : 'add',
      path: `/fields/${key}`,
      value: {
        'en-US': value,
      },
    }),
  );
  const result = await entry.patch(patch);
  return result.publish();
};

type Entity = 'events' | 'users';
type OptionalExceptFor<T, TRequired extends keyof T> = Partial<T> &
  Pick<T, TRequired>;

type DataContent = {
  sys: OptionalExceptFor<Sys, 'publishedVersion'>;
};

type Data = {
  [K in Entity]?: DataContent | null;
};

const pollContentful = async <T extends EntrySkeletonType<FieldsType, string>>(
  fetchEntry: (() => Promise<CDAEntry<T>>) | (() => Promise<Data>),
  revision: number,
  entity?: Entity,
) =>
  retry(
    // eslint-disable-next-line consistent-return
    async (bail) => {
      const entry = await fetchEntry();

      if (!entry) {
        return bail(new Error('Not found'));
      }

      if ('sys' in entry) {
        if ((entry.sys.revision || 0) < revision) {
          throw new Error('Not synced');
        }
        return entry;
      }

      if (entity) {
        const data = entry[entity];
        if (!data) {
          return bail(new Error('Not found'));
        }

        if ((data.sys.publishedVersion || 0) < revision) {
          throw new Error('Not synced');
        }
      }
    },
    { minTimeout: 100 },
  );

export const pollContentfulDeliveryApi = async <
  T extends EntrySkeletonType<FieldsType, string>,
>(
  fetchEntry: () => Promise<CDAEntry<T>>,
  revision: number,
) => pollContentful(fetchEntry, revision) as Promise<CDAEntry<T>>;

export const pollContentfulGql = async <FetchType extends Data>(
  version: number,
  fetchData: () => Promise<FetchType>,
  entity: Entity,
) => pollContentful(fetchData, version, entity) as Promise<void>;
